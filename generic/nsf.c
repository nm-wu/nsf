/*
 *  nsf.c --
 *
 *      Basic Machinery of the Next Scripting Framework, a Tcl-based framework
 *      for supporting language-oriented programming.  For details, see
 *      https://next-scripting.org/.
 *
 * Copyright (C) 1999-2020 Gustaf Neumann (a) (b)
 * Copyright (C) 1999-2007 Uwe Zdun (a) (b)
 * Copyright (C) 2007-2008 Martin Matuska (b)
 * Copyright (C) 2010-2019 Stefan Sobernig (b)
 * Copyright (C) 2020 Nathan Coulter (b)
 *
 *
 * (a) University of Essen
 *     Specification of Software Systems
 *     Altendorferstrasse 97-101
 *     D-45143 Essen, Germany
 *
 * (b) Vienna University of Economics and Business
 *     Institute of Information Systems and New Media
 *     A-1020, Welthandelsplatz 1
 *     Vienna, Austria
 *
 * This work is licensed under the MIT License
 * https://www.opensource.org/licenses/MIT
 *
 * Copyright:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *  This software is based upon MIT Object Tcl by David Wetherall and
 *  Christopher J. Lindblad, that contains the following copyright
 *  message:
 *
 *   "Copyright 1993 Massachusetts Institute of Technology
 *
 *    Permission to use, copy, modify, distribute, and sell this
 *    software and its documentation for any purpose is hereby granted
 *    without fee, provided that the above copyright notice appear in
 *    all copies and that both that copyright notice and this
 *    permission notice appear in supporting documentation, and that
 *    the name of M.I.T. not be used in advertising or publicity
 *    pertaining to distribution of the software without specific,
 *    written prior permission.  M.I.T. makes no representations about
 *    the suitability of this software for any purpose.  It is
 *    provided "as is" without express or implied warranty."
 */

#define NSF_FORWARD_WITH_ONERROR 1

#define NSF_C 1
#include "nsfInt.h"
#include "nsfAccessInt.h"

#ifdef COMPILE_NSF_STUBS
# if defined(PRE86)
EXTERN NsfStubs nsfStubs;
# else
MODULE_SCOPE const NsfStubs nsfStubs;
# endif
#endif

#ifdef USE_TCL_STUBS
# define Nsf_ExprObjCmd(clientData, interp, objc, objv)        \
  NsfCallCommand(interp, NSF_EXPR, objc, objv)
#else
# define Nsf_ExprObjCmd(clientData, interp, objc, objv)        \
  Tcl_ExprObjCmd(clientData, interp, objc, objv)
#endif

/*
 * Call Stack specific definitions
 */

typedef enum { CALLING_LEVEL, ACTIVE_LEVEL } CallStackLevel;

typedef struct callFrameContext {
  Tcl_CallFrame *framePtr;
  Tcl_CallFrame *varFramePtr;
  bool           frameSaved;
} callFrameContext;

/* #define COLON_CMD_STATS 1 */

typedef struct {
  void        *context;
  Tcl_Command  cmd;
  NsfClass    *class;
  unsigned int methodEpoch;
  unsigned int flags;
#if defined(COLON_CMD_STATS)
  size_t       hits;
  size_t       invalidates;
  size_t       requiredRefetches;
  Tcl_Obj     *obj;
#endif
} NsfColonCmdContext;

typedef struct NsfProcContext {
  ClientData          oldDeleteData;
  Tcl_CmdDeleteProc  *oldDeleteProc;
  NsfParamDefs       *paramDefs;
  int                *colonLocalVarCache;
  unsigned int        checkAlwaysFlag;
  Tcl_Namespace      *execNsPtr;
  Tcl_Obj            *returnsObj;
} NsfProcContext;

/*
 * TclCmdClientdata is an incomplete type containing the common field(s) of
 * ForwardCmdClientData, AliasCmdClientData and SetterCmdClientData, used for
 * filling in the actual object at run time.
 */
typedef struct TclCmdClientData {
  NsfObject *object;
} TclCmdClientData;

typedef struct SetterCmdClientData {
  NsfObject *object;
  Nsf_Param *paramsPtr;
} SetterCmdClientData;

typedef struct ForwardCmdClientData {
  NsfObject      *object;
  Tcl_Obj        *cmdName;
  Tcl_ObjCmdProc *objProc;
  ClientData      clientData;
  bool            passthrough;
  bool            needobjmap;
  bool            verbose;
  bool            hasNonposArgs;
  Tcl_Obj        *args;
  int             nr_args;
  int             frame;
#if defined(NSF_FORWARD_WITH_ONERROR)
  Tcl_Obj        *onerror;
#endif
  Tcl_Obj        *prefix;
  Tcl_Obj        *subcommands;
  int             nr_subcommands;
} ForwardCmdClientData;

typedef struct AliasCmdClientData {
  NsfObject      *object;
  Tcl_Obj        *cmdName;
  Tcl_ObjCmdProc *objProc;
  ClientData      clientData;
  NsfClass       *class;
  Tcl_Interp     *interp;
  Tcl_Command     aliasedCmd;
  Tcl_Command     aliasCmd;
} AliasCmdClientData;

/*
 * NSF_MEM_COUNT enables tracing the mem counting and freeing in an interp.
 * Therefore, a special client data structure is needed.
 */
#ifdef NSF_MEM_COUNT
typedef struct NsfNamespaceClientData {
  NsfObject     *object;
  Tcl_Namespace *nsPtr;
  Tcl_Interp    *interp;
} NsfNamespaceClientData;
#endif

/*
 * Argv parsing specific definitions.
 */

#define PARSE_CONTEXT_PREALLOC 20
typedef struct {
  ClientData   *clientData;   /* 4 members pointer to the actual parse context data */
  Tcl_Obj     **objv;
  Tcl_Obj     **full_objv;    /* contains method as well */
  unsigned int *flags;
  ClientData    clientData_static[PARSE_CONTEXT_PREALLOC]; /* 3 preallocated parse context data */
  Tcl_Obj      *objv_static[PARSE_CONTEXT_PREALLOC+1];
  unsigned int  flags_static[PARSE_CONTEXT_PREALLOC+1];
  unsigned int  status;
  int           lastObjc;     /* points to the first "unprocessed" argument */
  int           objc;
  NsfObject    *object;
  bool          varArgs;      /* does the parameter end with some kind of "args" */
} ParseContext;

static Nsf_TypeConverter ConvertToNothing, ConvertViaCmd, ConvertToObjpattern;

static const char  *autonamePrefix = "::nsf::__#";
static const size_t autonamePrefixLength = 10u;
static const char * nsfClassesPrefix = "::nsf::classes";
static const size_t nsfClassesPrefixLength = 14u;
/*
 * Tcl_Obj Types for Next Scripting Objects.
 */

static Tcl_ObjType CONST86
  *Nsf_OT_byteCodeType = NULL,
  *Nsf_OT_tclCmdNameType = NULL,
  *Nsf_OT_listType = NULL,
  *Nsf_OT_doubleType = NULL,
  *Nsf_OT_intType = NULL,
  *Nsf_OT_parsedVarNameType = NULL,
  *Nsf_OT_byteArrayType = NULL,
  *Nsf_OT_properByteArrayType = NULL,
  *Nsf_OT_bignumType = NULL;

/*
 * Function prototypes.
 */

/*
 * Prototypes for method definitions.
 */
static Tcl_ObjCmdProc NsfForwardMethod;
static Tcl_ObjCmdProc NsfObjscopedMethod;
static Tcl_ObjCmdProc NsfSetterMethod;
static Tcl_ObjCmdProc NsfProcAliasMethod;
static Tcl_ObjCmdProc NsfAsmProc;
Tcl_ObjCmdProc NsfProcStub;

/*
 * Prototypes for interpreter life-cyle.
 */
EXTERN Tcl_PackageInitProc Nsf_SafeInit;
EXTERN Tcl_PackageInitProc Nsf_Init;
static Tcl_ExitProc Nsf_ExitProc;
static Tcl_ExitProc ExitHandler;

#if defined(TCL_THREADS)
static Tcl_ExitProc Nsf_ThreadExitProc;
#endif


/*
 * Prototypes for methods called directly when CallDirectly() returns NULL.
 */
static int NsfCAllocMethod(Tcl_Interp *interp, NsfClass *class, Tcl_Obj *nameObj)
  nonnull(1) nonnull(2);
static int NsfCAllocMethod_(Tcl_Interp *interp, NsfClass *class, Tcl_Obj *nameObj, Tcl_Namespace *parentNsPtr)
  nonnull(1) nonnull(2) nonnull(3);
static int NsfCCreateMethod(Tcl_Interp *interp, NsfClass *class, Tcl_Obj *nameObj, int objc, Tcl_Obj *const objv[])
  nonnull(1) nonnull(2) nonnull(3) nonnull(5);
static int NsfOCleanupMethod(Tcl_Interp *interp, NsfObject *object)
  nonnull(1) nonnull(2);
static int NsfOConfigureMethod(Tcl_Interp *interp, NsfObject *object, int objc, Tcl_Obj *const objv[], Tcl_Obj *objv0)
  nonnull(1) nonnull(2) nonnull(4) nonnull(5);
static int NsfODestroyMethod(Tcl_Interp *interp, NsfObject *object)
  nonnull(1) nonnull(2);
static int MethodDispatch(
    Tcl_Interp *interp, int objc, Tcl_Obj *const objv[],
    Tcl_Command cmd, NsfObject *object, NsfClass *class,
    const char *methodName, unsigned short frameType, unsigned int flags
) nonnull(1) nonnull(3) nonnull(4) nonnull(5) nonnull(7);
static int DispatchDefaultMethod(Tcl_Interp *interp, NsfObject *object, Tcl_Obj *obj, unsigned int flags)
  nonnull(1) nonnull(2) nonnull(3);
static int DispatchDestroyMethod(Tcl_Interp *interp, NsfObject *object, unsigned int flags)
  nonnull(1) nonnull(2);
static int DispatchUnknownMethod(
    Tcl_Interp *interp, NsfObject *object,
    int objc, Tcl_Obj *const objv[], Tcl_Obj *callInfoObj,
    Tcl_Obj *methodObj, unsigned int flags
) nonnull(1) nonnull(2) nonnull(4) nonnull(6);

NSF_INLINE static int ObjectDispatch(
    ClientData clientData, Tcl_Interp *interp, int objc,
    Tcl_Obj *const objv[], unsigned int flags
) nonnull(1) nonnull(2) nonnull(4);

NSF_INLINE static int ObjectDispatchFinalize(
    Tcl_Interp *interp, NsfCallStackContent *cscPtr,
    int result /*, const char *string , const char *methodName*/
) nonnull(1) nonnull(2);

/*
 * Prototypes for object life-cycle management
 */
static int RecreateObject(Tcl_Interp *interp, NsfClass *class, NsfObject *object, int objc, Tcl_Obj *const objv[])
  nonnull(1) nonnull(2) nonnull(3) nonnull(5);
static void FinalObjectDeletion(Tcl_Interp *interp, NsfObject *object)
  nonnull(1) nonnull(2);

#if defined(DO_CLEANUP)
static void FreeAllNsfObjectsAndClasses(Tcl_Interp *interp,  NsfCmdList **instances)
  nonnull(1) nonnull(2);
#endif
static void CallStackDestroyObject(Tcl_Interp *interp, NsfObject *object)
  nonnull(1) nonnull(2);
static void PrimitiveCDestroy(ClientData clientData)
  nonnull(1);
static void PrimitiveODestroy(ClientData clientData)
  nonnull(1);
static void PrimitiveDestroy(ClientData clientData)
  nonnull(1);

static int VolatileMethod(Tcl_Interp *interp, NsfObject *object, bool shallow)
  nonnull(1) nonnull(2);

/*
 * Prototypes for object and command lookup
 */
static NsfObject *GetObjectFromString(Tcl_Interp *interp, const char *name)
  nonnull(1) nonnull(2);
static NsfClass *GetClassFromString(Tcl_Interp *interp, const char *name)
  nonnull(1) nonnull(2);
static int GetClassFromObj(Tcl_Interp *interp, register Tcl_Obj *objPtr, NsfClass **classPtr, bool withUnknown)
  nonnull(1) nonnull(2) nonnull(3);
static void GetAllInstances(Tcl_Interp *interp, NsfCmdList **instances, NsfClass *startClass)
  nonnull(1) nonnull(2) nonnull(3);
NSF_INLINE static Tcl_Command FindMethod(
    const Tcl_Namespace *nsPtr,
    const char *methodName
) nonnull(1) nonnull(2);
NSF_INLINE static NsfClasses *PrecedenceOrder(
    NsfClass *class
) nonnull(1);


/*
 * Prototypes for namespace-specific calls.
 */
static Tcl_Obj *NameInNamespaceObj(const char *name, Tcl_Namespace *nsPtr)
  nonnull(1) nonnull(2);
static Tcl_Namespace *CallingNameSpace(Tcl_Interp *interp)
  nonnull(1) returns_nonnull;
NSF_INLINE static Tcl_Command NSFindCommand(Tcl_Interp *interp, const char *name)
  nonnull(1) nonnull(2);
static Tcl_Namespace *NSGetFreshNamespace(Tcl_Interp *interp, NsfObject *object, const char *name)
  nonnull(1) nonnull(2) nonnull(3);
static Tcl_Namespace *RequireObjNamespace(Tcl_Interp *interp, NsfObject *object)
  nonnull(1) nonnull(2);
static int NSDeleteCmd(Tcl_Interp *interp, Tcl_Namespace *nsPtr, const char *methodName)
  nonnull(1) nonnull(2) nonnull(3);
static void NSNamespaceDeleteProc(ClientData clientData)
  nonnull(1);
static void NSNamespacePreserve(Tcl_Namespace *nsPtr)
  nonnull(1);
static void NSNamespaceRelease(Tcl_Namespace *nsPtr)
  nonnull(1);

/*
 * Prototypes for filters and mixins.
 */
static void FilterComputeDefined(Tcl_Interp *interp, NsfObject *object)
  nonnull(1) nonnull(2);
static void MixinComputeDefined(Tcl_Interp *interp, NsfObject *object)
  nonnull(1) nonnull(2);
NSF_INLINE static void GuardAdd(NsfCmdList *guardList, Tcl_Obj *guardObj)
  nonnull(1) nonnull(2);
static int GuardCall(NsfObject *object, Tcl_Interp *interp,
                     Tcl_Obj *guardObj, NsfCallStackContent *cscPtr)
  nonnull(1) nonnull(2) nonnull(3);
static void GuardDel(NsfCmdList *guardList)
  nonnull(1);

/*
 * Prototypes for forwarders.
 */
static void ForwardCmdDeleteProc(ClientData clientData)
  nonnull(1);
static int ForwardProcessOptions(
    Tcl_Interp *interp, Tcl_Obj *nameObj,
    Tcl_Obj *withDefault, int withEarlybinding,
    Tcl_Obj *withOnerror, Tcl_Obj *withMethodprefix,
    int withFrame, bool withVerbose,
    Tcl_Obj *target, int objc, Tcl_Obj * const objv[],
    ForwardCmdClientData **tcdPtr
) nonnull(1) nonnull(2) nonnull(11);

/*
 * Properties of objects and classes.
 */
static bool IsRootClass(
    const NsfClass *class
) nonnull(1) NSF_pure;

static bool IsRootMetaClass(
    const NsfClass *class
) nonnull(1) NSF_pure;

static bool IsBaseClass(
    const NsfObject *object
) nonnull(1) NSF_pure;

static bool IsMetaClass(
    Tcl_Interp *interp, NsfClass *class, bool withMixins
) nonnull(1) nonnull(2);

static bool IsSubType(
    NsfClass *subClass, const NsfClass *class
) nonnull(1) nonnull(2);

static NsfClass *DefaultSuperClass(
    Tcl_Interp *interp, const NsfClass *class, const NsfClass *metaClass, bool isMeta
) nonnull(1) nonnull(2) nonnull(3);


/*
 * Prototypes for call stack specific-calls.
 */
NSF_INLINE static void CscInit_(
    NsfCallStackContent *cscPtr,
    NsfObject *object,
    NsfClass *class,
    const Tcl_Command cmd,
    unsigned short frameType,
    unsigned int flags
) nonnull(1) nonnull(2);

NSF_INLINE static void CscFinish_(Tcl_Interp *interp, NsfCallStackContent *cscPtr)
  nonnull(1) nonnull(2);
NSF_INLINE static void CallStackDoDestroy(Tcl_Interp *interp, NsfObject *object)
  nonnull(1) nonnull(2);
static void NsfShowStack(Tcl_Interp *interp)
  nonnull(1);

/*
 * Prototypes for parameter and argument management.
 */
static int NsfParameterCacheClassInvalidateCmd(Tcl_Interp *interp, NsfClass *class)
  nonnull(1) nonnull(2);
static int ProcessMethodArguments(
    ParseContext *pcPtr,
    Tcl_Interp *interp,
    NsfObject *object,
    unsigned int processFlags,
    NsfParamDefs *paramDefs,
    Tcl_Obj *methodNameObj,
    int objc, Tcl_Obj *const objv[]
) nonnull(1) nonnull(2) nonnull(5) nonnull(6) nonnull(8);

static int ParameterCheck(
    Tcl_Interp *interp, Tcl_Obj *paramObjPtr, Tcl_Obj *valueObj,
    const char *argNamePrefix,
    unsigned int doCheckArguments,
    bool isNamed,
    bool doConfigureParameter,
    Nsf_Param **paramPtrPtr,
    const char *qualifier
) nonnull(1) nonnull(2) nonnull(3);

static void ParamDefsRefCountIncr(NsfParamDefs *paramDefs)
  nonnull(1);

static void ParamDefsRefCountDecr(
    NsfParamDefs *paramDefs
) nonnull(1);

static void ParsedParamFree(
    NsfParsedParam *parsedParamPtr
) nonnull(1);

NSF_INLINE static NsfParamDefs *ParamDefsGet(
    const Tcl_Command cmdPtr,
    unsigned int *checkAlwaysFlagPtr,
    Tcl_Namespace **execNsPtrPtr
) nonnull(1);

NSF_INLINE static NsfProcContext *ProcContextGet(
    const Tcl_Command cmdPtr
) nonnull(1) NSF_pure;

static NsfProcContext *ProcContextRequire(
    Tcl_Command cmd
) nonnull(1);

static int ArgumentParse(
    Tcl_Interp *interp,
    int objc, Tcl_Obj *const objv[],
    NsfObject *object,
    Tcl_Obj *procNameObj,
    const Nsf_Param *paramPtr,
    int nrParams,
    int serial,
    unsigned int processFlags,
    ParseContext *pcPtr
) nonnull(1) nonnull(5) nonnull(6) nonnull(10);

static int ArgumentCheck(
    Tcl_Interp *interp, Tcl_Obj *objPtr, const struct Nsf_Param *pPtr,
    unsigned int doCheckArguments,
    unsigned int *flags, ClientData *clientData, Tcl_Obj **outObjPtr
) nonnull(1) nonnull(2) nonnull(3) nonnull(5) nonnull(6) nonnull(7);

static int GetMatchObject(
    Tcl_Interp *interp, Tcl_Obj *patternObj, Tcl_Obj *origObj,
    NsfObject **matchObjectPtr, const char **patternPtr
) nonnull(1) nonnull(4) nonnull(5);

static void NsfProcDeleteProc(ClientData clientData)
  nonnull(1);

static int NsfParameterCacheObjectInvalidateCmd(
    Tcl_Interp *interp, NsfObject *object
) nonnull(1) nonnull(2);

static int GetObjectParameterDefinition(
    Tcl_Interp *interp, Tcl_Obj *procNameObj,
    NsfObject *object, NsfClass *class,
    NsfParsedParam *parsedParamPtr
) nonnull(1) nonnull(2) nonnull(5);

typedef Tcl_Obj *(NsfFormatFunction)(
    Tcl_Interp *interp, const Nsf_Param *paramsPtr,
    NsfObject *contextObject, const char *pattern
);

static Tcl_Obj *NsfParamDefsVirtualFormat(
    Tcl_Interp *interp, const Nsf_Param *pPtr,
    NsfObject *contextObject, const char *pattern,
    NsfFormatFunction formatFunction
) nonnull(1) nonnull(2) nonnull(3) nonnull(5);

static bool NsfParamDefsAppendVirtual(
    Tcl_Interp *interp, Tcl_Obj *listObj,
    const Nsf_Param *paramsPtr,
    NsfObject *contextObject,
    const char *pattern,
    NsfFormatFunction formatFunction
) nonnull(1) nonnull(2) nonnull(3) nonnull(6);

/*
 * Prototypes for alias management.
 */
static int AliasDelete(Tcl_Interp *interp, Tcl_Obj *cmdName, const char *methodName, bool withPer_object)
  nonnull(1) nonnull(2) nonnull(3);

static Tcl_Obj *AliasGet(Tcl_Interp *interp, Tcl_Obj *cmdName, const char *methodName,
                         bool withPer_object, bool leaveError)
  nonnull(1) nonnull(2) nonnull(3);

static bool AliasDeleteObjectReference(Tcl_Interp *interp, Tcl_Command cmd)
  nonnull(1) nonnull(2);

static int AliasRefetch(Tcl_Interp *interp, NsfObject *object, const char *methodName,
                        AliasCmdClientData *tcd)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

NSF_INLINE static Tcl_Command AliasDereference(Tcl_Interp *interp, NsfObject *object,
                                               const char *methodName, Tcl_Command cmd)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

/*
 * Prototypes for (class) list handling.
 */
static NsfClasses ** NsfClassListAdd(NsfClasses **firstPtrPtr, NsfClass *class, ClientData clientData)
  nonnull(1) returns_nonnull;

/*
 * Misc prototypes.
 */
static int SetInstVar(Tcl_Interp *interp, NsfObject *object, Tcl_Obj *nameObj, Tcl_Obj *valueObj, unsigned int flags)
  nonnull(1) nonnull(2) nonnull(3);

static int UnsetInstVar(Tcl_Interp *interp, int withNocomplain, NsfObject *object, const char *name)
  nonnull(1) nonnull(3) nonnull(4);

static int NextSearchAndInvoke(
    Tcl_Interp *interp,
    const char *methodName, int objc, Tcl_Obj *const objv[],
    NsfCallStackContent *cscPtr, bool freeArgumentVector
) nonnull(1) nonnull(2) nonnull(5);

static void CmdListFree(NsfCmdList **cmdList, NsfFreeCmdListClientData *freeFct)
  nonnull(1);
static void NsfCommandPreserve(Tcl_Command cmd)
  nonnull(1);
static void NsfCommandRelease(Tcl_Command cmd)
  nonnull(1);
static Tcl_Command GetOriginalCommand(Tcl_Command cmd)
  nonnull(1) returns_nonnull;

EXTERN void NsfDStringArgv(Tcl_DString *dsPtr, int objc, Tcl_Obj *const objv[])
  nonnull(1) nonnull(3);

static NsfObjectOpt *NsfRequireObjectOpt(NsfObject *object)
  nonnull(1) returns_nonnull;

static int ObjectSystemsCheckSystemMethod(
    Tcl_Interp *interp, const char *methodName,
    const NsfObject *object, unsigned int flags
) nonnull(1) nonnull(2) nonnull(3);

#ifdef DO_CLEANUP
static void DeleteNsfProcs(Tcl_Interp *interp, Tcl_Namespace *nsPtr)
  nonnull(1);
#endif

#if defined(NSF_WITH_ASSERTIONS)
static void AssertionRemoveProc(NsfAssertionStore *aStore, const char *name)
  nonnull(1) nonnull(2);
#endif

#ifdef DO_FULL_CLEANUP
static void DeleteProcsAndVars(Tcl_Interp *interp, Tcl_Namespace *nsPtr, bool withKeepvars)
  nonnull(1) nonnull(2);
#endif


/*
 *----------------------------------------------------------------------
 *
 * NsfDListInit, NsfDListAppend, NsfDListFree   --
 *
 *      Like the corresponding Tcl_DString functions but accept (void*)
 *      elements instead of chars. NsfDList routines work with static memory
 *      until more space is needed, and double the allocated space thereafter.
 *      The worst case, where half allocated storage is unused, is no worse
 *      than the overhead of a singly-linked list.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Allocates and deallocates memory.
 *
 *----------------------------------------------------------------------
 */
static void
NsfDListInit(NsfDList *dlPtr) {
  dlPtr->data = &dlPtr->static_data[0];
  dlPtr->avail = nr_elements(dlPtr->static_data);
  dlPtr->size = 0u;
}

static void
NsfDListAppend(NsfDList *dlPtr, void *element) {
  if (dlPtr->avail < 1) {
    size_t requiredSize = dlPtr->size * 2u;

    if (dlPtr->data != &dlPtr->static_data[0]) {
      dlPtr->data = (void **)ckrealloc((char *)dlPtr->data, sizeof(dlPtr->data[0]) * requiredSize);
    } else {
      dlPtr->data = (void **)ckalloc(sizeof(dlPtr->data[0]) * requiredSize);
      memcpy(dlPtr->data, &dlPtr->static_data[0], dlPtr->size * sizeof(dlPtr->data[0]));
    }
    dlPtr->avail = requiredSize - dlPtr->size;
  }
  dlPtr->avail --;
  dlPtr->data[dlPtr->size] = element;
  dlPtr->size ++;
}

#ifdef DO_CLEANUP
static void
NsfDListFree(NsfDList *dlPtr) {
  if (dlPtr->data != &dlPtr->static_data[0]) {
    ckfree((char*)dlPtr->data);
  }
  NsfDListInit(dlPtr);
}
#endif

/*
 *----------------------------------------------------------------------
 *
 * NsfErrorContext --
 *
 *      Prints the current errorCode and errorInfo to stderr.  Should be used
 *      as the last resort, e.g. when logging fails.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Produces output to stderr.
 *
 *----------------------------------------------------------------------
 */
static void NsfErrorContext(
    Tcl_Interp *interp, const char *context
) nonnull(1) nonnull(2);

static void
NsfErrorContext(
    Tcl_Interp *interp, const char *context
) {
  Tcl_DString ds, *dsPtr = &ds;

  nonnull_assert(interp != NULL);
  nonnull_assert(context != NULL);

  Tcl_DStringInit(dsPtr);
  Tcl_DStringAppend(dsPtr, "puts stderr \"Error in ", -1);
  Tcl_DStringAppend(dsPtr, context, -1);
  Tcl_DStringAppend(dsPtr, ":\n$::errorCode $::errorInfo\"", -1);
  Tcl_EvalEx(interp, Tcl_DStringValue(dsPtr), Tcl_DStringLength(dsPtr), 0);
  Tcl_DStringFree(dsPtr);
}

#if 0
static char *
NsfErrorInfo(
    Tcl_Interp *interp
) {
  Tcl_Obj *valueObj;
  nonnull_assert(interp != NULL);

  valueObj = Tcl_GetVar2Ex(interp, "::errorInfo", NULL, TCL_GLOBAL_ONLY);
  if (valueObj != NULL) {
    return ObjStr(valueObj);
  }
  return NULL;
}
#endif

/*
 *----------------------------------------------------------------------
 *
 * NsfDStringEval --
 *
 *      Evaluates the given Tcl_DString.  Outputs the error stack in case of a
 *      failure.
 *
 * Results:
 *      A Tcl return code.
 *
 * Side effects:
 *      See description.
 *
 *----------------------------------------------------------------------
 */
int
NsfDStringEval(
    Tcl_Interp *interp, Tcl_DString *dsPtr, const char *context,
    unsigned int traceEvalFlags
) {
  Tcl_InterpState  state = NULL;
  NsfRuntimeState *rst;
  int              result, prevDoProfile;
  unsigned int     prevPreventRecursionFlags;

  nonnull_assert(interp != NULL);
  nonnull_assert(dsPtr != NULL);
  nonnull_assert(context != NULL);

  rst = RUNTIME_STATE(interp);

  if ((traceEvalFlags & NSF_EVAL_PREVENT_RECURSION) != 0u) {
    /*
     * Don't debug the debug statements since this would lead to infinite
     * recursion.  Determine whether to allow execution of the eval call.
     */
    if ((rst->preventRecursionFlags & traceEvalFlags) != 0) {
      /*
       * Recursive case. Do NOT execute the cmd and return silently.
       */
      return TCL_OK;
    }
    prevPreventRecursionFlags = rst->preventRecursionFlags;
    rst->preventRecursionFlags |= traceEvalFlags;
  } else {
    prevPreventRecursionFlags = 0u;
  }

  if ((traceEvalFlags & NSF_EVAL_NOPROFILE) && rst->doProfile == 1) {
    /*
     * Profiling should be deactivated for the eval.
     */
    prevDoProfile = 1;
    rst->doProfile = 0;
  } else {
    prevDoProfile = 0;
  }

  if ((traceEvalFlags & NSF_EVAL_SAVE) != 0u) {
    state = Tcl_SaveInterpState(interp, TCL_OK);
  }
  result = Tcl_EvalEx(interp, Tcl_DStringValue(dsPtr), Tcl_DStringLength(dsPtr), 0);

  if (unlikely(result == TCL_ERROR)) {
    NsfErrorContext(interp, context);
  }

  if ((traceEvalFlags & NSF_EVAL_SAVE) != 0u) {
    Tcl_RestoreInterpState(interp, state);
  }
  if ((traceEvalFlags & NSF_EVAL_PREVENT_RECURSION) != 0u) {
      rst->preventRecursionFlags = prevPreventRecursionFlags;
  }

  if (prevDoProfile == 1) {
    rst->doProfile = 1;
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 *
 * NsfLog --
 *
 *      Produces a formatted warning by calling, ::nsf::log.  Defined static to
 *      enable inlining.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Outpus the warning.
 *
 *----------------------------------------------------------------------
 */

void
NsfLog(
    Tcl_Interp *interp, int requiredLevel, const char *fmt, ...
) {
  nonnull_assert(interp != NULL);
  nonnull_assert(fmt != NULL);

  if (requiredLevel >= RUNTIME_STATE(interp)->logSeverity) {
    int          destroyRound = RUNTIME_STATE(interp)->exitHandlerDestroyRound;
    Tcl_DString  cmdString, ds;
    const char  *level;
    va_list      ap;

    switch (requiredLevel) {
    case NSF_LOG_DEBUG: level = "Debug"; break;
    case NSF_LOG_NOTICE: level = "Notice"; break;
    default: level = "Warning"; break;
    }

    Tcl_DStringInit(&ds);
    va_start(ap, fmt);
    NsfDStringVPrintf(&ds, fmt, ap);
    va_end(ap);

    Tcl_DStringInit(&cmdString);
    Tcl_DStringAppendElement(&cmdString, "::nsf::log");
    Tcl_DStringAppendElement(&cmdString, level);
    Tcl_DStringAppendElement(&cmdString, Tcl_DStringValue(&ds));

    if (destroyRound != NSF_EXITHANDLER_ON_PHYSICAL_DESTROY) {
      NsfDStringEval(interp, &cmdString, "log command", (NSF_EVAL_LOG|NSF_EVAL_NOPROFILE));
    } else {
      /*
       * On physical destruction don't rely on NsfDStringEval() working
       * properly.
       */
      fprintf(stderr, "%s", cmdString.string);
    }
    Tcl_DStringFree(&cmdString);
    Tcl_DStringFree(&ds);
  }
}


/*
 *----------------------------------------------------------------------
 *
 * NsfDeprecatedCmd --
 *
 *      Calls the ::nsf::deprecated to provide a warning about a deprecated
 *      command or method, temporarily disabling profiling. Called before the
 *      body of the command is executed, so saving the interp result should not
 *      be an issue.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Outputs the warning.
 *
 *----------------------------------------------------------------------
 */
void
NsfDeprecatedCmd(
    Tcl_Interp *interp, const char *what, const char *oldCmd, const char *newCmd
) {
  Tcl_DString ds, *dsPtr = &ds;

  nonnull_assert(interp != NULL);
  nonnull_assert(newCmd != NULL);
  nonnull_assert(what != NULL);
  nonnull_assert(oldCmd != NULL);

  Tcl_DStringInit(dsPtr);
  Tcl_DStringAppendElement(dsPtr, "::nsf::deprecated");
  Tcl_DStringAppendElement(dsPtr, what);
  Tcl_DStringAppendElement(dsPtr, oldCmd);
  Tcl_DStringAppendElement(dsPtr, newCmd);

  NsfDStringEval(interp, dsPtr, "deprecated command", (NSF_EVAL_DEPRECATED|NSF_EVAL_NOPROFILE));

  Tcl_DStringFree(dsPtr);
}


/***********************************************************************
 * argv parsing
 ***********************************************************************/
/*
 *----------------------------------------------------------------------
 *
 * ParseContextInit --
 *
 *      Initializes a ParseContext with default values, allocating
 *      memory if needed. Every ParseContext must be initialized
 *      before usage and must be freed with ParseContextRelease().
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      May allocate memory.
 *
 *----------------------------------------------------------------------
 */
static void ParseContextInit(
    ParseContext *pcPtr, int objc, NsfObject *object, Tcl_Obj *procName
) nonnull(1) nonnull(4);

static void
ParseContextInit(
    ParseContext *pcPtr, int objc, NsfObject *object, Tcl_Obj *procName
) {
  nonnull_assert(pcPtr != NULL);
  nonnull_assert(procName != NULL);

  if (likely(objc < PARSE_CONTEXT_PREALLOC)) {
    /*
     * The single larger memset below ....
     */
    memset(pcPtr, 0, sizeof(ParseContext));
    /*
     * ... is faster than the two smaller memsets below.
     */
    /* memset(pcPtr->clientData_static, 0, sizeof(ClientData)*(objc));
       memset(pcPtr->objv_static, 0, sizeof(Tcl_Obj *)*(objc+1));*/
    pcPtr->full_objv  = &pcPtr->objv_static[0];
    pcPtr->clientData = &pcPtr->clientData_static[0];
    pcPtr->flags      = &pcPtr->flags_static[0];
  } else {
    pcPtr->full_objv  = (Tcl_Obj **)ckalloc((int)sizeof(Tcl_Obj *) * ((unsigned)objc+1u));
    pcPtr->flags      = (unsigned *)ckalloc((unsigned)sizeof(int) * ((unsigned)objc+1u));
    MEM_COUNT_ALLOC("pcPtr.objv", pcPtr->full_objv);
    pcPtr->clientData = (ClientData *)ckalloc((unsigned)sizeof(ClientData) * (unsigned)objc);
    MEM_COUNT_ALLOC("pcPtr.clientData", pcPtr->clientData);
    /*fprintf(stderr, "ParseContextMalloc %d objc, %p %p\n", objc, pcPtr->full_objv, pcPtr->clientData);*/
    memset(pcPtr->full_objv,  0, sizeof(Tcl_Obj *)  * (size_t)(objc+1));
    memset(pcPtr->flags,      0, sizeof(int)        * (size_t)(objc+1));
    memset(pcPtr->clientData, 0, sizeof(ClientData) * (size_t)objc);
    pcPtr->status     = NSF_PC_STATUS_FREE_OBJV|NSF_PC_STATUS_FREE_CD;
    pcPtr->varArgs    = NSF_FALSE;
    pcPtr->objc       = 0;
  }
  pcPtr->objv = &pcPtr->full_objv[1];
  pcPtr->full_objv[0] = procName;
  pcPtr->object = object;
}

/*
 *----------------------------------------------------------------------
 *
 * ParseContextExtendObjv --
 *
 *      Extends Tcl_Obj array when more elements are needed at runtime.
 *      ParesContext must already be initialized.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      May allocate memory.
 *
 *----------------------------------------------------------------------
 */

static void ParseContextExtendObjv(
    ParseContext *pcPtr, unsigned from, unsigned elts, Tcl_Obj *const source[]
) nonnull(1) nonnull(4);

static void
ParseContextExtendObjv(
    ParseContext *pcPtr, unsigned from, unsigned elts, Tcl_Obj *const source[]
) {
  unsigned requiredSize = from + elts + 1;

  nonnull_assert(pcPtr != NULL);
  nonnull_assert(source != NULL);

  /*NsfPrintObjv("BEFORE: ", pcPtr->objc, pcPtr->full_objv);*/

  if (unlikely(requiredSize >= PARSE_CONTEXT_PREALLOC)) {
    if (pcPtr->objv == &pcPtr->objv_static[1]) {
      /*
       * Realloc from preallocated memory
       */
      pcPtr->full_objv = (Tcl_Obj **)ckalloc((int)sizeof(Tcl_Obj *) * requiredSize);
      pcPtr->flags     = (unsigned *)ckalloc((int)sizeof(int) * requiredSize);
      MEM_COUNT_ALLOC("pcPtr.objv", pcPtr->full_objv);
      memcpy(pcPtr->full_objv, &pcPtr->objv_static[0], sizeof(Tcl_Obj *) * PARSE_CONTEXT_PREALLOC);
      memcpy(pcPtr->flags, &pcPtr->flags_static[0], sizeof(int) * PARSE_CONTEXT_PREALLOC);
      /* fprintf(stderr, "ParseContextExtendObjv: extend %p alloc %d new objv=%p pcPtr %p\n",
         pcPtr, requiredSize, pcPtr->full_objv, pcPtr);*/

      pcPtr->status     |= NSF_PC_STATUS_FREE_OBJV;
    } else {
      /*
       *  Realloc from mallocated memory
       */
      pcPtr->full_objv = (Tcl_Obj **)ckrealloc((char *)pcPtr->full_objv, (unsigned)sizeof(Tcl_Obj *) * requiredSize);
      pcPtr->flags     = (unsigned *)ckrealloc((char *)pcPtr->flags,     (unsigned)sizeof(int) * requiredSize);
      /*fprintf(stderr, "ParseContextExtendObjv: extend %p realloc %d  new objv=%p pcPtr %p\n",
        pcPtr, requiredSize, pcPtr->full_objv, pcPtr);*/
    }
    pcPtr->objv = &pcPtr->full_objv[1];
  }

  memcpy(pcPtr->objv + from,  source, sizeof(Tcl_Obj *) * (size_t)elts);
  memset(pcPtr->flags + from, 0,      sizeof(int) * (size_t)elts);
  pcPtr->objc += (int)elts;

  /*NsfPrintObjv("AFTER:  ", pcPtr->objc, pcPtr->full_objv);*/
}

/*
 *----------------------------------------------------------------------
 *
 * ParseContextRelease --
 *
 *      Releases and possibly frees the content of a ParseContext. This is the
 *      counterpart of ParseContextInit().
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      May free memory.
 *
 *----------------------------------------------------------------------
 */
static void ParseContextRelease(ParseContext *pcPtr)
  nonnull(1);

static void
ParseContextRelease(ParseContext *pcPtr) {
  unsigned int status;

  nonnull_assert(pcPtr != NULL);

  status = pcPtr->status;

  /*fprintf(stderr, "ParseContextRelease %p status %.6x %d elements\n",
    pcPtr, status, pcPtr->objc);*/

#if defined(NSF_DEVELOPMENT_TEST)
  {
    /*
     * Check for general consistency: Although the contents of the parse
     * context may only be partially initialized at release time, follow these
     * rules to correctly release a Tcl_obj:
     *
     *    If NSF_PC_MUST_DECR is set for any object, the status flag
     *    NSF_PC_STATUS_MUST_DECR must be set as well.
     *
     *    If any flag is set for an object, a pointer to that object must
     *    exist.
     *
     *    Sanity check: For preallocated objvs, each object after the arguments
     *    must either have no flags set or have NSF_PC_IS_DEFAULT set.
     */

    /*
     *  Verify that the status correctly reflects MUST_DECR.
     */
    int i;
    if (status == 0u || (status & NSF_PC_STATUS_MUST_DECR) == 0u) {
      for (i = 0; i < pcPtr->objc - 1; i++) {
        assert((pcPtr->flags[i] & NSF_PC_MUST_DECR) == 0);
      }
    }

    /*
     * Verify that there is a pointer to each Tcl_Obj whose reference count is
     * to be decremented
     */
    if (pcPtr->objc > 0) {
      /*fprintf(stderr, "%s ", ObjStr(pcPtr->full_objv[0]));*/
      for (i = 0; i < pcPtr->objc; i++) {
        if (pcPtr->flags[i] != 0u) {
          assert(pcPtr->objv[i]);
          /*fprintf(stderr, "[%d]%s %.6x ", i, ObjStr(pcPtr->objv[i]), pcPtr->flags[i]);*/
        }
      }
    }
    /*
     * Flags for any additional object must be unset or NSF_PC_IS_DEFAULT must
     * be set.
     */
    if (pcPtr->full_objv == &pcPtr->objv_static[0] && pcPtr->objc > 0) {
      for (i = pcPtr->objc; i < PARSE_CONTEXT_PREALLOC; i++) {
        assert(pcPtr->flags[i] == 0u || pcPtr->flags[i] == NSF_PC_IS_DEFAULT);
      }
    }
  }
#endif

  if (unlikely(status != 0u)) {
    if ((status & NSF_PC_STATUS_MUST_DECR) != 0u) {
      int i;
      /*fprintf(stderr, "ParseContextRelease %p loop from 0 to %d\n", pcPtr, pcPtr->objc-1);*/
      for (i = 0; i < pcPtr->objc; i++) {
        /*fprintf(stderr, "ParseContextRelease %p check [%d] obj %p flags %.6x & %p\n",
                pcPtr, i, pcPtr->objv[i],
                pcPtr->flags[i], &(pcPtr->flags[i]));*/
        if ((pcPtr->flags[i] & NSF_PC_MUST_DECR) != 0u) {
          assert(pcPtr->objv[i]);
          assert(pcPtr->objv[i]->refCount > 0);
          /*fprintf(stderr, "... decr ref count on %p\n", pcPtr->objv[i]);*/
          DECR_REF_COUNT2("valueObj", pcPtr->objv[i]);
        }
      }
    }
    /*
     * If memory was allocated for objv then memory was also allocated for
     * flags.
     */
    if (unlikely((status & NSF_PC_STATUS_FREE_OBJV) != 0u)) {
      /*fprintf(stderr, "ParseContextRelease %p free %p %p\n",
        pcPtr, pcPtr->full_objv, pcPtr->clientData);*/
      MEM_COUNT_FREE("pcPtr.objv", pcPtr->full_objv);
      ckfree((char *)pcPtr->full_objv);
      ckfree((char *)pcPtr->flags);
    }
    /*
     * If memory was allocated for the parameter definition then memory was
     * also allocated for clientData.
     */
    if ((status & NSF_PC_STATUS_FREE_CD) != 0u) {
      /*fprintf(stderr, "free client-data for %p\n", pcPtr);*/
      MEM_COUNT_FREE("pcPtr.clientData", pcPtr->clientData);
      ckfree((char *)pcPtr->clientData);
    }
  }
}

/*
 *----------------------------------------------------------------------
 *
 * CallMethod --
 *
 *      Calls a Next Scripting method. clientData contains the object on which
 *      to dispatch the method, methodObj provides the method, and objc, which
 *      must >=2, together with objv provides the arguments.
 *
 * Results:
 *      A Tcl return code.
 *
 * Side effects:
 *      Arbitrary.
 *
 *----------------------------------------------------------------------
 */
/*
 * call a Next Scripting method
 */
static int
CallMethod(ClientData clientData, Tcl_Interp *interp, Tcl_Obj *methodObj,
           int objc, Tcl_Obj *const objv[], unsigned int flags)
  nonnull(1) nonnull(2) nonnull(3);

static int
CallMethod(ClientData clientData, Tcl_Interp *interp, Tcl_Obj *methodObj,
           int objc, Tcl_Obj *const objv[], unsigned int flags) {
  NsfObject *object;
  int        result;
  ALLOC_ON_STACK(Tcl_Obj*, objc, tov);

  nonnull_assert(clientData != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(methodObj != NULL);
  assert(objc > 1);

  object = (NsfObject *) clientData;
  tov[0] = object->cmdName;
  tov[1] = methodObj;

  if (likely(objc > 2)) {
    memcpy(tov+2, objv, sizeof(Tcl_Obj *) * ((size_t)objc - 2u));
  }

  /*fprintf(stderr, "%%%% CallMethod cmdName=%s, method=%s, objc=%d\n",
    ObjStr(tov[0]), ObjStr(tov[1]), objc);
    {int i; fprintf(stderr, "\t CALL: %s ", ObjStr(methodObj));for(i = 0; i < objc-2; i++) {
    fprintf(stderr, "%s ", ObjStr(objv[i]));} fprintf(stderr, "\n");}*/

  result = ObjectDispatch(clientData, interp, objc, tov, flags);

  FREE_ON_STACK(Tcl_Obj*, tov);

  return result;
}

/*
 *----------------------------------------------------------------------
 *
 * NsfCallMethodWithArgs --
 *
 *      Dispatches "methodObj" on "object", passing the often-provided arg1 and
 *      any additional values in "objv".  This avoids a memcpy in the common
 *      case that case no argument or a single argument are provided.
 *
 * Results:
 *      A Tcl return code.
 *
 * Side effects:
 *      Arbitrary.
 *
 *----------------------------------------------------------------------
 */

int NsfCallMethodWithArgs(Tcl_Interp *interp, Nsf_Object *object, Tcl_Obj *methodObj,
                      Tcl_Obj *arg1, int givenObjc, Tcl_Obj *const objv[], unsigned int flags)
  nonnull(1) nonnull(2) nonnull(3);

int
NsfCallMethodWithArgs(Tcl_Interp *interp, Nsf_Object *object, Tcl_Obj *methodObj,
                      Tcl_Obj *arg1, int givenObjc, Tcl_Obj *const objv[], unsigned int flags) {
  int       objc = givenObjc + 2;
  int       result;
  ALLOC_ON_STACK(Tcl_Obj*, objc, tov);

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  assert(ISOBJ_(methodObj));
  assert(objc > 1);

  tov[0] = object->cmdName;
  tov[1] = methodObj;
  if (objc > 2) {
    tov[2] = arg1;
  }
  if (objc > 3) {
    memcpy(tov+3, objv, sizeof(Tcl_Obj *) * ((size_t)objc - 3u));
  }

  /*fprintf(stderr, "%%%% CallMethodWithArgs cmdName=%s, method=%s, arg1 %s objc=%d\n",
          ObjStr(tov[0]), ObjStr(tov[1]), (objc > 2) ? ObjStr(tov[2]) : "",  objc);*/

  result = ObjectDispatch(object, interp, objc, tov, flags);

  FREE_ON_STACK(Tcl_Obj*, tov);

  return result;
}

/*
 * Support for variable hash tables.
 */
static NSF_INLINE Var *VarHashCreateVar(TclVarHashTable *tablePtr, const Tcl_Obj *key, int *newPtr)
  nonnull(1) nonnull(2);

static NSF_INLINE Var *
VarHashCreateVar(TclVarHashTable *tablePtr, const Tcl_Obj *key, int *newPtr) {
  Var                 *varPtr;
  const Tcl_HashEntry *hPtr;

  nonnull_assert(tablePtr != NULL);
  nonnull_assert(key != NULL);

  hPtr = Tcl_CreateHashEntry((Tcl_HashTable *) tablePtr,
                             (char *) key, newPtr);
  if (likely(hPtr != NULL)) {
    varPtr = TclVarHashGetValue(hPtr);
  } else {
    varPtr = NULL;
  }

  return varPtr;
}

static NSF_INLINE TclVarHashTable *
VarHashTableCreate(void) {
  TclVarHashTable *varTablePtr = (TclVarHashTable *) ckalloc((int)sizeof(TclVarHashTable));

  TclInitVarHashTable(varTablePtr, NULL);
  return varTablePtr;
}

#include "nsfCmdPtr.c"
#include "nsfStack.c"

/***********************************************************************
 * Value added replacements of Tcl functions
 ***********************************************************************/
/*
 *----------------------------------------------------------------------
 * Nsf_NextHashEntry --
 *
 *    Similar to Tcl_NextHashEntry. If an entry is moved during the iteration
 *    of hash entries, Tcl_NextHashEntry() can return an hPtr that looks valid
 *    but that is invalid because the next entry has been deleted.  This seems
 *    to occur only when there are more than 12 hash entries in the table, i.e.
 *    multiple buckets.  Uses numEntries to determine whether it is sensible to
 *    return a hash entry, and refetches the hSrchPtr when the number of
 *    expected entries differs from the numbers of the actual entries.
 *
 * Results:
 *    A hash entry or NULL.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static Tcl_HashEntry * Nsf_NextHashEntry(Tcl_HashTable *tablePtr, int expected, Tcl_HashSearch *hSrchPtr)
  nonnull(1) nonnull(3);

static Tcl_HashEntry *
Nsf_NextHashEntry(Tcl_HashTable *tablePtr, int expected, Tcl_HashSearch *hSrchPtr) {
  Tcl_HashEntry *result;

  nonnull_assert(tablePtr != NULL);
  nonnull_assert(hSrchPtr != NULL);

  /*fprintf(stderr, "Nsf_NextHashEntry %p expected %d numEntries %d\n",
    tablePtr, expected, tablePtr->numEntries);*/
  if (tablePtr->numEntries < 1) {
    result = NULL;
  } else if (tablePtr->numEntries != expected) {
    result = Tcl_FirstHashEntry(tablePtr, hSrchPtr);
  } else {
    result = Tcl_NextHashEntry(hSrchPtr);
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * NsfCommandPreserve --
 *
 *    Increments the refCount of a Tcl command.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static void
NsfCommandPreserve(Tcl_Command cmd) {

  nonnull_assert(cmd != NULL);

  Tcl_Command_refCount(cmd)++;
  MEM_COUNT_ALLOC("command.refCount", cmd);
}

/*
 *----------------------------------------------------------------------
 * NsfCommandRelease --
 *
 *    Decrements the Tcl command refCount, possibly freeing the command.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void
NsfCommandRelease(Tcl_Command cmd) {

  nonnull_assert(cmd != NULL);

  /*fprintf(stderr, "NsfCommandRelease %p\n", cmd);*/
  MEM_COUNT_FREE("command.refCount", cmd);
  TclCleanupCommandMacro((Command *)cmd);
}

/***********************************************************************
 * EXTERN callable routines for the preliminary C interface
 ***********************************************************************/
Nsf_Object * NsfGetSelfObj(const Tcl_Interp *interp)
  nonnull(1) NSF_pure;
Nsf_Object * NsfGetObject(Tcl_Interp *interp, const char *name)
  nonnull(1) nonnull(2);
Nsf_Class * NsfGetClass(Tcl_Interp *interp, const char *name)
  nonnull(1) nonnull(2);
Nsf_Class * NsfIsClass(Tcl_Interp *interp, ClientData clientData)
  nonnull(1) nonnull(2) NSF_pure;
void NsfRequireObjNamespace(Tcl_Interp *interp, Nsf_Object *object)
  nonnull(1) nonnull(2);
Tcl_Obj * Nsf_ObjSetVar2(Nsf_Object *object, Tcl_Interp *interp, Tcl_Obj *name1, Tcl_Obj *name2,
                         Tcl_Obj *valueObj, unsigned int flags)
  nonnull(1) nonnull(2) nonnull(3) nonnull(5);
Tcl_Obj * Nsf_ObjGetVar2(Nsf_Object *object, Tcl_Interp *interp, Tcl_Obj *name1, Tcl_Obj *name2, unsigned int flags)
  nonnull(1) nonnull(2) nonnull(3);
int NsfCreate(Tcl_Interp *interp, Nsf_Class *class, Tcl_Obj *nameObj, int objc, Tcl_Obj *const objv[])
  nonnull(1) nonnull(2) nonnull(3) nonnull(5);
int NsfDeleteObject(Tcl_Interp *interp, Nsf_Object *object)
  nonnull(1) nonnull(2);
int NsfRemoveObjectMethod(Tcl_Interp *interp, Nsf_Object *object, const char *methodName)
  nonnull(1) nonnull(2) nonnull(3);
int NsfRemoveClassMethod(Tcl_Interp *interp, Nsf_Class *class, const char *methodName)
  nonnull(1) nonnull(2) nonnull(3);
int Nsf_UnsetVar2(Nsf_Object *object, Tcl_Interp *interp,
                  const char *name1, const char *name2, unsigned int flags)
  nonnull(1) nonnull(2) nonnull(4);

void NsfSetObjClientData(Tcl_Interp *UNUSED(interp), Nsf_Object *object, ClientData data)
  nonnull(1) nonnull(2);
ClientData NsfGetObjClientData(Tcl_Interp *UNUSED(interp), Nsf_Object *object)
  nonnull(1) nonnull(2) NSF_pure;
void NsfSetClassClientData(Tcl_Interp *UNUSED(interp), Nsf_Class *class, ClientData data)
  nonnull(1) nonnull(2);
ClientData NsfGetClassClientData(Tcl_Interp *UNUSED(interp), Nsf_Class *class)
  nonnull(1) nonnull(2) NSF_pure;

Nsf_Object *
NsfGetSelfObj(const Tcl_Interp *interp) {
  nonnull_assert(interp != NULL);
  return (Nsf_Object *) GetSelfObj(interp);
}

Nsf_Object *
NsfGetObject(Tcl_Interp *interp, const char *name) {
  nonnull_assert(interp != NULL);
  nonnull_assert(name != NULL);
  return (Nsf_Object *) GetObjectFromString(interp, name);
}

Nsf_Class *
NsfGetClass(Tcl_Interp *interp, const char *name) {
  nonnull_assert(interp != NULL);
  nonnull_assert(name != NULL);
  return (Nsf_Class *)GetClassFromString(interp, name);
}

Nsf_Class *
NsfIsClass(Tcl_Interp *UNUSED(interp), ClientData clientData) {

  nonnull_assert(clientData != NULL);

  if (NsfObjectIsClass((NsfObject *)clientData)) {
    return (Nsf_Class *) clientData;
  }
  return NULL;
}

void
NsfRequireObjNamespace(Tcl_Interp *interp, Nsf_Object *object) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  RequireObjNamespace(interp, (NsfObject *) object);
}

Tcl_Obj *
Nsf_ObjSetVar2(Nsf_Object *object, Tcl_Interp *interp, Tcl_Obj *name1, Tcl_Obj *name2,
                 Tcl_Obj *valueObj, unsigned int flags) {
  Tcl_Obj *result;
  CallFrame frame, *framePtr = &frame;

  nonnull_assert(object != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(name1 != NULL);
  nonnull_assert(valueObj != NULL);

  Nsf_PushFrameObj(interp, (NsfObject *)object, framePtr);
  if (((NsfObject *)object)->nsPtr != NULL) {
    flags |= TCL_NAMESPACE_ONLY;
  }
  result = Tcl_ObjSetVar2(interp, name1, name2, valueObj, (int)flags);
  Nsf_PopFrameObj(interp, framePtr);
  return result;
}


Tcl_Obj *
Nsf_ObjGetVar2(Nsf_Object *object, Tcl_Interp *interp, Tcl_Obj *name1, Tcl_Obj *name2,
               unsigned int flags) {
  Tcl_Obj  *result;
  CallFrame frame, *framePtr = &frame;

  nonnull_assert(object != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(name1 != NULL);

  Nsf_PushFrameObj(interp, (NsfObject *)object, framePtr);
  if (((NsfObject *)object)->nsPtr != NULL) {
    flags |= TCL_NAMESPACE_ONLY;
  }
  result = Tcl_ObjGetVar2(interp, name1, name2, (int)flags);
  Nsf_PopFrameObj(interp, framePtr);

  return result;
}

int
Nsf_UnsetVar2(Nsf_Object *object, Tcl_Interp *interp,
                   const char *name1, const char *name2, unsigned int flags) {
  CallFrame  frame, *framePtr = &frame;
  NsfObject *o;
  int        result;

  nonnull_assert(object != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(name1 != NULL);
  nonnull_assert(name2 != NULL);

  o = (NsfObject *) object;
  Nsf_PushFrameObj(interp, o, framePtr);
  if (o->nsPtr != NULL) {
    flags |= TCL_NAMESPACE_ONLY;
  }
  result = Tcl_UnsetVar2(interp, name1, name2, (int)flags);
  Nsf_PopFrameObj(interp, framePtr);
  return result;
}

int
NsfCreate(Tcl_Interp *interp, Nsf_Class *class, Tcl_Obj *nameObj,
          int objc, Tcl_Obj *const objv[]) {
  NsfClass *cl = (NsfClass *) class;
  int       result;
  ALLOC_ON_STACK(Tcl_Obj*, objc, tov);

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(nameObj != NULL);
  nonnull_assert(objv != NULL);

  INCR_REF_COUNT2("nameObj", nameObj);

  tov[0] = NULL;
  tov[1] = nameObj;
  if (objc > 0) {
    memcpy(tov+2, objv, sizeof(Tcl_Obj *) * (size_t)objc);
  }
  result = NsfCCreateMethod(interp, cl, nameObj, objc+2, tov);

  FREE_ON_STACK(Tcl_Obj*, tov);
  DECR_REF_COUNT2("nameObj", nameObj);

  return result;
}

int
NsfDeleteObject(Tcl_Interp *interp, Nsf_Object *object) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  return DispatchDestroyMethod(interp, (NsfObject *)object, 0u);
}

int
NsfRemoveObjectMethod(Tcl_Interp *interp, Nsf_Object *object, const char *methodName) {
  NsfObject *currentObject;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodName != NULL);

  currentObject = (NsfObject *) object;
  /*fprintf(stderr, "... NsfRemoveObjectMethod %s %s\n", ObjectName(currentObject), methodName);*/

  NsfObjectMethodEpochIncr("NsfRemoveObjectMethod");
  AliasDelete(interp, currentObject->cmdName, methodName, NSF_TRUE);

#if defined(NSF_WITH_ASSERTIONS)
  if (currentObject->opt != NULL && currentObject->opt->assertions != NULL) {
    AssertionRemoveProc(currentObject->opt->assertions, methodName);
  }
#endif

  if (currentObject->nsPtr != NULL) {
    int rc = NSDeleteCmd(interp, currentObject->nsPtr, methodName);
    if (rc < 0) {
      return NsfPrintError(interp, "%s: cannot delete object specific method '%s'",
                           ObjectName_(currentObject), methodName);
    }
  }
  return TCL_OK;
}

int
NsfRemoveClassMethod(Tcl_Interp *interp, Nsf_Class *class, const char *methodName) {
  const NsfClass *c;
  int             rc;
#if defined(NSF_WITH_ASSERTIONS)
  NsfClassOpt    *opt;
#endif

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(methodName != NULL);

  c = (NsfClass *)class;
  /*fprintf(stderr, "... NsfRemoveClassMethod %s %s\n", ClassName(class), methodName);*/

  NsfInstanceMethodEpochIncr("NsfRemoveClassMethod");
  AliasDelete(interp, class->object.cmdName, methodName, NSF_FALSE);

#if defined(NSF_WITH_ASSERTIONS)
  opt = c->opt;
  if (opt != NULL && opt->assertions != NULL) {
    AssertionRemoveProc(opt->assertions, methodName);
  }
#endif

  rc = NSDeleteCmd(interp, c->nsPtr, methodName);
  if (rc < 0) {
    return NsfPrintError(interp, "%s: cannot delete method '%s'", ClassName_(c), methodName);
  }
  return TCL_OK;
}

/*
 * object ClientData setter/getter
 */

void
NsfSetObjClientData(Tcl_Interp *UNUSED(interp), Nsf_Object *object, ClientData data) {

  nonnull_assert(object != NULL);
  nonnull_assert(data != NULL);

  NsfRequireObjectOpt((NsfObject *) object) -> clientData = data;
}

ClientData
NsfGetObjClientData(Tcl_Interp *UNUSED(interp), Nsf_Object *object) {
  NsfObject *object_;

  nonnull_assert(object != NULL);

  object_ = (NsfObject *) object;
  return (object_->opt != NULL) ? object_->opt->clientData : NULL;
}

void
NsfSetClassClientData(Tcl_Interp *UNUSED(interp), Nsf_Class *class, ClientData data) {

  nonnull_assert(class != NULL);

  NsfRequireClassOpt((NsfClass *)class) -> clientData = data;
}

ClientData
NsfGetClassClientData(Tcl_Interp *UNUSED(interp), Nsf_Class *class) {
  NsfClass *c;

  c = (NsfClass *) class;
  return (c->opt != NULL) ? c->opt->clientData : NULL;
}

/***********************************************************************
 * Utility functions
 ***********************************************************************/

#if defined(NSFOBJ_TRACE)
void ObjTrace(const char *string, NsfObject *object)
  nonnull(1) nonnull(2);

void
ObjTrace(const char *string, NsfObject *object) {

  nonnull_assert(string != NULL);
  nonnull_assert(object != NULL);

  fprintf(stderr, "--- %s Tcl %p %s (%d %p) nsf %p (%d) %s \n", string,
          object->cmdName, ObjTypeStr(object->cmdName),
          object->cmdName->refCount, object->cmdName->internalRep.twoPtrValue.ptr1,
          object, object->refCount, ObjectName(object));
}
#else
# define ObjTrace(a, b)
#endif


/*
 *----------------------------------------------------------------------
 * NSTail --
 *
 *    Returns the namespace tail of the given name.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static const char * NSTail(const char *string)
  nonnull(1) NSF_pure;

static const char *
NSTail(const char *string) {
  register const char *p;

  nonnull_assert(string != NULL);

  p = string + strlen(string);
  while (p > string) {
    if (unlikely(*p == ':' && *(p-1) == ':')) {
      return p+1;
    }
    p--;
  }
  return string;
}

/*
 *----------------------------------------------------------------------
 * IsClassNsName --
 *
 *    True if the given string starts with the prefix of the classes namespace.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static bool IsClassNsName(const char *string, const char **cont)
  nonnull(1);

NSF_INLINE static bool
IsClassNsName(const char *string, const char **cont) {

  nonnull_assert(string != NULL);

  if (*string == ':' && strncmp(string, nsfClassesPrefix, nsfClassesPrefixLength) == 0) {
    if (cont != NULL) {
      *cont = string + nsfClassesPrefixLength;
    }
    return NSF_TRUE;
  }
  return NSF_FALSE;
}

/*
 *----------------------------------------------------------------------
 * GetObjectFromNsName --
 *
 *    Returns the object for the given fully-qualified cmd name, e.g.
 *    ::nsf::classes::X.  fromClassNS is true if the namespace for the given
 *    name is the namespace for Nsf classes.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static NsfObject * GetObjectFromNsName(Tcl_Interp *interp, const char *string, bool *fromClassNS)
  nonnull(1) nonnull(2) nonnull(3);

NSF_INLINE static NsfObject *
GetObjectFromNsName(Tcl_Interp *interp, const char *string, bool *fromClassNS) {
  const char *className;

  nonnull_assert(interp != NULL);
  nonnull_assert(string != NULL);
  nonnull_assert(fromClassNS != NULL);

  if (IsClassNsName(string, &className)) {
    *fromClassNS = NSF_TRUE;
    return (NsfObject *)GetClassFromString(interp, className);
  } else {
    *fromClassNS = NSF_FALSE;
    return GetObjectFromString(interp, string);
  }
}

/*
 *----------------------------------------------------------------------
 * DStringAppendQualName --
 *
 *    Fully-qualifies the given name in the given namespace, appends the result
 *    to the given DString, and returns a pointer to the DString value.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static char *DStringAppendQualName(Tcl_DString *dsPtr, const Tcl_Namespace *nsPtr, const char *name)
  nonnull(1) nonnull(2) nonnull(3);

static char *
DStringAppendQualName(Tcl_DString *dsPtr, const Tcl_Namespace *nsPtr, const char *name) {
  int oldLength;

  nonnull_assert(dsPtr != NULL);
  nonnull_assert(nsPtr != NULL);
  nonnull_assert(name != NULL);

  oldLength = Tcl_DStringLength(dsPtr);

  Tcl_DStringAppend(dsPtr, nsPtr->fullName, -1);
  if (Tcl_DStringLength(dsPtr) > (oldLength + 2)) {
    Tcl_DStringAppend(dsPtr, "::", 2);
  }
  Tcl_DStringAppend(dsPtr, name, -1);
  return Tcl_DStringValue(dsPtr);
}

/*
 *----------------------------------------------------------------------
 * NsfCleanupObject --
 *
 *    Decrements the reference count of the object possibly deallocating
 *    storage associated with the object.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
void
NsfCleanupObject_(NsfObject *object) {

  nonnull_assert(object != NULL);

  NsfObjectRefCountDecr(object);
  /*fprintf(stderr, "NsfCleanupObject obj refCount of %p after decr %d id %p interp %p flags %.6x\n",
    object, object->refCount, object->id, object->teardown, object->flags);*/

  if (unlikely(object->refCount <= 0)) {
    /*fprintf(stderr, "NsfCleanupObject %p ref-count %d\n", object, object->refCount);*/
    assert(object->refCount == 0);
    assert((object->flags & NSF_DELETED) != 0u);

    /*
     * During FinalObjectDeletion() object->teardown is NULL. Object and class
     * names are no longer accessible.
     */
    if (object->teardown && NSF_DTRACE_OBJECT_FREE_ENABLED()) {
      NSF_DTRACE_OBJECT_FREE(ObjectName(object), ClassName(object->cl));
    }

    MEM_COUNT_FREE("NsfObject/NsfClass", object);
#if defined(NSFOBJ_TRACE)
    fprintf(stderr, "CKFREE Object %p refCount=%d\n", object, object->refCount);
#endif
#if !defined(NDEBUG)
    memset(object, 0, sizeof(NsfObject));
#endif
    ckfree((char *) object);
  }
}


/*
 *  Tcl_Obj functions for objects
 */

/*
 *----------------------------------------------------------------------
 * TclObjIsNsfObject --
 *
 *    True if objPtr has an Nsf object internal representation. If true, stores
 *    the NsfObject in *objectPtr.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static bool TclObjIsNsfObject(
    Tcl_Interp *interp, Tcl_Obj *objPtr, NsfObject **objectPtr
) nonnull(1) nonnull(2) nonnull(3);

static bool
TclObjIsNsfObject(Tcl_Interp *interp, Tcl_Obj *objPtr, NsfObject **objectPtr) {
  Tcl_ObjType CONST86 *cmdType;
  bool                 result = NSF_FALSE;

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(objectPtr != NULL);

  cmdType = objPtr->typePtr;
  if (cmdType == Nsf_OT_tclCmdNameType) {
    const Tcl_Command cmd = Tcl_GetCommandFromObj(interp, objPtr);
    if (likely(cmd != NULL)) {
      NsfObject *object = NsfGetObjectFromCmdPtr(cmd);
      if (object != NULL) {
        *objectPtr = object;
        result = NSF_TRUE;
      }
    }
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * GetObjectFromObj --
 *
 *    Stores in *objectPtr the Next Scripting object for the given name if
 *    there is one.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    May change the type of objPtr.
 *
 *----------------------------------------------------------------------
 */
static int GetObjectFromObj(
    Tcl_Interp *interp, Tcl_Obj *objPtr, NsfObject **objectPtr
) nonnull(1) nonnull(2) nonnull(3);

static int
GetObjectFromObj(Tcl_Interp *interp, Tcl_Obj *objPtr, NsfObject **objectPtr) {
  NsfObject    *object;
  const char   *string;
  Tcl_Command   cmd;

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(objectPtr != NULL);

  /*fprintf(stderr, "GetObjectFromObj obj %p %s is of type %s\n",
    objPtr, ObjStr(objPtr), ObjTypeStr(objPtr));*/

  /*
   * Use the standard Tcl_GetCommandFromObj(), which might convert objPtr to
   * a cmdName type.
   */
  cmd = Tcl_GetCommandFromObj(interp, objPtr);

  /*fprintf(stderr, "GetObjectFromObj obj %p %s (type %p) => cmd=%p (refCount %d)\n",
    objPtr, ObjStr(objPtr), objPtr->typePtr, cmd, (cmd != NULL) ? Tcl_Command_refCount(cmd) : -1);*/

  if (cmd != NULL) {
    NsfObject *cmdObject;

    /*
     * Tcl returned a command. In Tcl 8.7 at least, the command can not be
     * trusted to be valid.  Unfortunately, it isn't possible to get more
     * details because "struct ResolvedCmdName" is defined locally in
     * generic/tclObj.c. For cmd epochs>0, take the conservative approach not
     * to trust in internal representation and fetch the cmd new.
     */

    cmdObject = NsfGetObjectFromCmdPtr(cmd);

    /* fprintf(stderr, "GetObjectFromObj obj %s, o is %p objProc %p NsfObjDispatch %p\n",
       ObjStr(objPtr), cmdObject, Tcl_Command_objProc(cmd), NsfObjDispatch);*/

    if (likely(cmdObject != NULL)) {
      *objectPtr = cmdObject;
      return TCL_OK;
    }
  }
  /*fprintf(stderr, "GetObjectFromObj convertFromAny for %s type %p %s\n", ObjStr(objPtr),
    objPtr->typePtr, ObjTypeStr(objPtr));*/

  string = ObjStr(objPtr);

  if (isAbsolutePath(string)) {
    object = NULL;
  } else {
    /*
     * The argument is not fully qualified. Resolve via CallingNameSpace.
     */
    Tcl_Obj    *tmpName = NameInNamespaceObj(string, CallingNameSpace(interp));
    const char *nsString = ObjStr(tmpName);

    INCR_REF_COUNT(tmpName);
    object = GetObjectFromString(interp, nsString);
    /* fprintf(stderr, " RETRY, string '%s' returned %p\n", nsString, object);*/
    DECR_REF_COUNT(tmpName);
  }

  if (likely(object != NULL)) {
    *objectPtr = object;
    return TCL_OK;
  }

  return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 * NsfCallObjectUnknownHandler --
 *
 *    Calls ::nsf::object::unknown. Typically called when an unknown object or
 *    class is passed as an argument.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */

static int NsfCallObjectUnknownHandler(
    Tcl_Interp *interp, Tcl_Obj *nameObj
) nonnull(1) nonnull(2);

static int
NsfCallObjectUnknownHandler(Tcl_Interp *interp, Tcl_Obj *nameObj) {
  int      result;
  Tcl_Obj *ov[3];

  nonnull_assert(interp != NULL);
  nonnull_assert(nameObj != NULL);

  /*fprintf(stderr, "try ::nsf::object::unknown for '%s'\n", ObjStr(nameObj));*/

  ov[0] = NsfGlobalObjs[NSF_OBJECT_UNKNOWN_HANDLER];
  ov[1] = nameObj;

  INCR_REF_COUNT(ov[1]);
  result = Tcl_EvalObjv(interp, 2, ov, 0);
  DECR_REF_COUNT(ov[1]);

  return result;
}

#if defined(NSF_EXPERIMENTAL)
static int NsfCallArgumentUnknownHandler(
    Tcl_Interp *interp,
    Tcl_Obj *methodObj,
    Tcl_Obj *argumentObj,
    NsfObject *object
) nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static int
NsfCallArgumentUnknownHandler(
    Tcl_Interp *interp,
    Tcl_Obj *methodObj,
    Tcl_Obj *argumentObj,
    NsfObject *object
) {
  Tcl_Obj *ov[4];
  int      result, oc = 3;

  nonnull_assert(interp != NULL);
  nonnull_assert(methodObj != NULL);
  nonnull_assert(argumentObj != NULL);
  nonnull_assert(object != NULL);

  /*fprintf(stderr, "try ::nsf::argument::unknown for '%s'\n", ObjStr(nameObj));*/

  ov[0] = NsfGlobalObjs[NSF_ARGUMENT_UNKNOWN_HANDLER];
  ov[1] = methodObj;
  ov[2] = argumentObj;
  if (object != NULL) {
    ov[3] = object->cmdName;
    oc ++;
  }

  INCR_REF_COUNT(ov[1]);
  result = Tcl_EvalObjv(interp, oc, ov, 0);
  DECR_REF_COUNT(ov[1]);

  return result;
}
#endif

/*
 *----------------------------------------------------------------------
 * GetClassFromObj --
 *
 *    Stores in *classPtr the a Next Scripting class that has the given name.
 *    If the class is not found and withUnknown is true, calls the unknown
 *    function, i.e.  ::nsf::object::unknown, to fetch the class, and retries
 *    the conversion.  Converts objPtr if needed and if possible.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static int
GetClassFromObj(Tcl_Interp *interp, register Tcl_Obj *objPtr,
                NsfClass **classPtr, bool withUnknown) {
  NsfObject   *object;
  NsfClass    *class;
  const char  *objName;
  Tcl_Command  cmd;
  int          result;

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(classPtr != NULL);

  objName = ObjStr(objPtr);
  cmd = Tcl_GetCommandFromObj(interp, objPtr);
  /*fprintf(stderr, "GetClassFromObj %p %s unknown %d cmd %p\n", objPtr, objName, withUnknown, cmd);*/

  if (likely(cmd != NULL)) {
    class = NsfGetClassFromCmdPtr(cmd);
    if (class == NULL) {
      /*
       * There is a cmd but no class. A class imported into a namespace is
       * already resolved. Try to resolve an alias as well.
       */
      Tcl_Interp *alias_interp;
      const char *alias_cmd_name, *qualifiedObjName;
      Tcl_Obj    *nameObj = objPtr;
      Tcl_Obj   **alias_ov;
      int         alias_oc = 0;

      if (!isAbsolutePath(objName)) {
        nameObj = NameInNamespaceObj(objName, CallingNameSpace(interp));
        qualifiedObjName = ObjStr(nameObj);
        INCR_REF_COUNT(nameObj);
      } else {
        qualifiedObjName = objName;
      }

      result = Tcl_GetAliasObj(interp, qualifiedObjName,
                               &alias_interp, &alias_cmd_name, &alias_oc, &alias_ov);
      Tcl_ResetResult(interp);

      /*
       * Only interested in interp-aliases with 0 args.
       */
      if (likely(result == TCL_OK) && likely(alias_oc == 0)) {
        cmd = NSFindCommand(interp, alias_cmd_name);
        /*fprintf(stderr, "..... alias arg 0 '%s' cmd %p\n", alias_cmd_name, cmd);*/
        if (cmd != NULL) {
          class = NsfGetClassFromCmdPtr(cmd);
        }
      }

      /*fprintf(stderr, "..... final cmd %p, class %p\n", cmd , class);*/
      if (nameObj != objPtr) {
        DECR_REF_COUNT(nameObj);
      }
    }

    if (likely(class != NULL)) {
      *classPtr = class;
      return TCL_OK;
    }
  }

  result = GetObjectFromObj(interp, objPtr, &object);
  if (likely(result == TCL_OK)) {
    class = NsfObjectToClass(object);
    if (likely(class != NULL)) {
      *classPtr = class;
      return TCL_OK;
    } else {
      /*
       * flag that no conversion was successful so far.
       */
      result = TCL_ERROR;
    }
  }

  if (withUnknown) {
    /*fprintf(stderr, "**** withUnknown 1 obj %s is shared %d\n", ObjStr(objPtr), Tcl_IsShared(objPtr));*/
    INCR_REF_COUNT(objPtr);
    result = NsfCallObjectUnknownHandler(interp, isAbsolutePath(objName) ? objPtr :
                                         NameInNamespaceObj(objName, CallingNameSpace(interp)));
    if (likely(result == TCL_OK)) {
      /*
       * Retry, this time setting withUnknown to FALSE.
       */
      result = GetClassFromObj(interp, objPtr, classPtr, NSF_FALSE);
    }
    DECR_REF_COUNT(objPtr);
    /*fprintf(stderr, "... ::nsf::object::unknown for '%s',
      result %d cl %p\n", objName, result, cl);*/
  }

  return result;
}

/*
 * Version of GetClassFromObj() with external symbol.
 */
int
NsfGetClassFromObj(Tcl_Interp *interp, Tcl_Obj *objPtr,
                   NsfClass **classPtr, bool withUnknown) {

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(classPtr != NULL);

  return GetClassFromObj(interp, objPtr, classPtr, withUnknown);
}
/*
 *----------------------------------------------------------------------
 * IsObjectOfType --
 *
 *    Verifies that the given NsfObject is of the type indicated by the given
 *    parameter definition. "what" and "objPtr" are only used for the error
 *    messages. "objPtr" is the value from which the object was derived.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static int IsObjectOfType(
    Tcl_Interp *interp, NsfObject *object, const char *what, Tcl_Obj *objPtr,
    const Nsf_Param *pPtr
) nonnull(1) nonnull(2) nonnull(3) nonnull(4) nonnull(5);

static int
IsObjectOfType(
    Tcl_Interp *interp, NsfObject *object, const char *what, Tcl_Obj *objPtr,
    const Nsf_Param *pPtr
) {
  NsfClass *class;
  int       result = TCL_ERROR;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(what != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(pPtr != NULL);

  if (unlikely((pPtr->flags & NSF_ARG_BASECLASS) != 0u)
      && !IsBaseClass(object)
     ) {
    what = "baseclass";

  } else if (unlikely((pPtr->flags & NSF_ARG_METACLASS) != 0u)
             && !IsMetaClass(interp, (NsfClass *)object, NSF_TRUE)
            ) {
    what = "metaclass";

  } else if (likely(pPtr->converterArg == NULL)) {
    result = TCL_OK;

  } else if (likely((GetClassFromObj(interp, pPtr->converterArg, &class, NSF_FALSE) == TCL_OK))
             && IsSubType(object->cl, class)
            ) {
    result = TCL_OK;
  }

  if (result == TCL_ERROR) {
    Tcl_DString ds, *dsPtr = &ds;

    DSTRING_INIT(dsPtr);
    Tcl_DStringAppend(dsPtr, what, -1);
    if (pPtr->converterArg != NULL) {
      Tcl_DStringAppend(dsPtr, " of type ", -1);
      Tcl_DStringAppend(dsPtr, ObjStr(pPtr->converterArg), -1);
    }
    NsfObjErrType(interp, NULL, objPtr, Tcl_DStringValue(dsPtr), (Nsf_Param *)pPtr);
    DSTRING_FREE(dsPtr);
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * NameInNamespaceObj --
 *
 *    Returns the given name, fully-qualified in the given namespace.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static Tcl_Obj *
NameInNamespaceObj(const char *name, Tcl_Namespace *nsPtr) {
  Tcl_Obj *objPtr;
  Tcl_DString ds, *dsPtr = &ds;

  nonnull_assert(name != NULL);
  nonnull_assert(nsPtr != NULL);

  /*fprintf(stderr, "NameInNamespaceObj %s (%p, %s) ", name, nsPtr, nsPtr->fullName);*/

  DSTRING_INIT(dsPtr);
  DStringAppendQualName(dsPtr, nsPtr, name);
  objPtr = Tcl_NewStringObj(Tcl_DStringValue(dsPtr), Tcl_DStringLength(dsPtr));

  /*fprintf(stderr, "returns %s\n", ObjStr(objPtr));*/
  DSTRING_FREE(dsPtr);
  return objPtr;
}

/*
 *----------------------------------------------------------------------
 * NewTclCommand --
 *
 *    Generates from the prefix in dsPtr the name of a command that does not
 *    exist and stores that name in dsPtr.  Used by "new" when "anonymous"
 *    objects are created.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
void NewTclCommand(Tcl_Interp *interp, Tcl_DString *dsPtr)
  nonnull(1) nonnull(2);

void
NewTclCommand(Tcl_Interp *interp, Tcl_DString *dsPtr) {
  int prefixLength;
  NsfStringIncrStruct *iss;

  nonnull_assert(interp != NULL);
  nonnull_assert(dsPtr != NULL);

  prefixLength = dsPtr->length;
  iss = &RUNTIME_STATE(interp)->iss;

  while (1) {

    (void)NsfStringIncr(iss);
    Tcl_DStringAppend(dsPtr, iss->start, (int)iss->length);
    if (!Tcl_FindCommand(interp, Tcl_DStringValue(dsPtr), NULL, TCL_GLOBAL_ONLY)) {
      break;
    }
    /*
     * Reset prefix to the original length. if the symbol existed already.
     */
    Tcl_DStringSetLength(dsPtr, prefixLength);
  }
}

/*
 *----------------------------------------------------------------------
 * NsfReverseClasses --
 *
 *    Returns a new list whose order is the reverse of the given list. The
 *    caller must free the elements of the new list.
 *
 * Results:
 *    A pointer to the reversed list.
 *
 * Side effects:
 *    Allocates new list elements.
 *
 *----------------------------------------------------------------------
 */
static NsfClasses *NsfReverseClasses(NsfClasses *sl)
  nonnull(1) returns_nonnull;

static NsfClasses *
NsfReverseClasses(NsfClasses *sl) {
  NsfClasses *firstPtr = NULL;

  nonnull_assert(sl != NULL);

  do {
    NsfClasses *element = NEW(NsfClasses);

    element->cl = sl->cl;
    element->clientData = sl->clientData;
    element->nextPtr = firstPtr;
    firstPtr = element;

    sl = sl->nextPtr;
  } while (likely(sl != NULL));

  return firstPtr;
}

/*
 *----------------------------------------------------------------------
 * NsfClassListFree --
 *
 *    Frees all items in the given list.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void NsfClassListFree(NsfClasses *classList)
  nonnull(1);

static void
NsfClassListFree(NsfClasses *classList) {
  NsfClasses *nextPtr;

 nonnull_assert(classList != NULL);

 do {
   nextPtr = classList->nextPtr;
   FREE(NsfClasses, classList);
   classList = nextPtr;
 } while (likely(classList != NULL));
}

/*
 *----------------------------------------------------------------------
 * NsfClassListAdd --
 *
 *    Adds the given class to the given list and stores a pointer to the head
 *    of the list in *firstPtrPtr if the initial list is empty.
 *
 * Results:
 *    The address of the new element.
 *
 * Side effects:
 *    Allocates a new list element.
 *
 *----------------------------------------------------------------------
 */

static NsfClasses **
NsfClassListAdd(NsfClasses **firstPtrPtr, NsfClass *class, ClientData clientData) {
  NsfClasses *classListPtr, *element = NEW(NsfClasses);

  nonnull_assert(firstPtrPtr != NULL);

  element->cl = class;
  element->clientData = clientData;
  element->nextPtr = NULL;

  classListPtr = *firstPtrPtr;
  if (classListPtr != NULL) {
    while (classListPtr->nextPtr != NULL) {
      classListPtr = classListPtr->nextPtr;
    }
    classListPtr->nextPtr = element;
  } else {
    *firstPtrPtr = element;
  }
  return &(element->nextPtr);
}

/*
 *----------------------------------------------------------------------
 * NsfClassListAddNoDup --
 *
 *    Adds the given class to the given list if it isn't there already. If the
 *    initial list is empty, stores a pointer to the new element in
 *    *firstPtrPtr.
 *
 * Results:
 *    Returns the address of the new element.
 *
 * Side effects:
 *    Allocates an element.
 *
 *----------------------------------------------------------------------
 */

static NsfClasses **NsfClassListAddNoDup(NsfClasses **firstPtrPtr, NsfClass *class,
                                         ClientData clientData)
  nonnull(1) nonnull(2);

static NsfClasses **
NsfClassListAddNoDup(NsfClasses **firstPtrPtr, NsfClass *class, ClientData clientData) {
  NsfClasses *clPtr, **nextPtr;

  nonnull_assert(firstPtrPtr != NULL);
  nonnull_assert(class != NULL);

  clPtr = *firstPtrPtr;
  if (clPtr != NULL) {
    while ((clPtr->nextPtr != NULL) && (clPtr->cl != class)) {
      clPtr = clPtr->nextPtr;
    }
    nextPtr = &clPtr->nextPtr;
  } else {
    nextPtr = firstPtrPtr;
  }

  if (*nextPtr == NULL) {
    NsfClasses *element = NEW(NsfClasses);

    element->cl = class;
    element->clientData = clientData;
    element->nextPtr = NULL;
    *nextPtr = element;
  }
  return nextPtr;
}

/*
 *----------------------------------------------------------------------
 * NsfClassListFind --
 *
 *    Returns from the given list item that contains the given class, if there
 *    is one.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static NsfClasses *NsfClassListFind(NsfClasses *clPtr, const NsfClass *class)
  nonnull(2) NSF_pure;

static NsfClasses *
NsfClassListFind(NsfClasses *clPtr, const NsfClass *class) {

  nonnull_assert(class != NULL);

  for (; clPtr != NULL; clPtr = clPtr->nextPtr) {
    if (clPtr->cl == class) {
      break;
    }
  }
  return clPtr;
}

#if defined(NSF_CLASSLIST_PRINT)
/* for debugging purposes only */
/*
 *----------------------------------------------------------------------
 * NsfClassListStats --
 *
 *    Prints statistics about generated Class List structures.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static void NsfClassListStats(const char *title, NsfClasses *classList)
  nonnull(1);

static void
NsfClassListStats(const char *title, NsfClasses *classListPtr) {
  NsfClass *class;
  int count = 0;

  nonnull_assert(title != NULL);

  class = (classListPtr != NULL) ? classListPtr->cl : NULL;
  for (; classListPtr != NULL; classListPtr = classListPtr->nextPtr) {
    count++;
  }

  fprintf(stderr, "%s class list starting with %s has %d elements\n",
          title, (class != NULL) ? ClassName(class) : "none", count);
}

static void NsfClassListPrint(const char *title, NsfClasses *clsList)
  nonnull(1);

static void
NsfClassListPrint(const char *title, NsfClasses *clsList) {

  nonnull_assert(title != NULL);

  fprintf(stderr, "%s", title);
  /* fprintf(stderr, " %p:", clsList); */
  while (clsList != NULL) {
    /* fprintf(stderr, " %p", clsList->cl); */
    fprintf(stderr, " %p", clsList);
    fprintf(stderr, " %s", ClassName(clsList->cl));
    clsList = clsList->nextPtr;
  }
  fprintf(stderr, "\n");
}
#endif

/*
 *----------------------------------------------------------------------
 * NsfClassListUnlink --
 *
 *    Removes from the given list an item matching the given key, updates
 *    *firstPtrPtr if the first item is removed, and returns the removed item.
 *    The type of key is "void" so that various things may be used as keys.
 *
 * Results:
 *    The removed item, or NULL.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static NsfClasses *NsfClassListUnlink(NsfClasses **firstPtrPtr, const void *key)
  nonnull(1) nonnull(2);

static NsfClasses *
NsfClassListUnlink(NsfClasses **firstPtrPtr, const void *key) {
  NsfClasses *entryPtr;

  nonnull_assert(firstPtrPtr != NULL);
  nonnull_assert(key != NULL);

  if (*firstPtrPtr != NULL) {
    NsfClasses *prevPtr = NULL;

    /*
     * Not an empty list.
     */
    for (entryPtr = *firstPtrPtr;
         entryPtr != NULL;
         prevPtr = entryPtr, entryPtr = entryPtr->nextPtr
         ) {
      if ((void *)entryPtr->cl == key) {
        /*
         * Found a matching item.
         */
        if (prevPtr != NULL) {
          /*
           * Not the first item.
           */
          prevPtr->nextPtr = entryPtr->nextPtr;
        } else {
          /*
           * Is the first item.
           */
          *firstPtrPtr = entryPtr->nextPtr;
        }
        entryPtr->nextPtr = NULL;
        break;
      }
    }
  } else {
    entryPtr = NULL;
  }

  return entryPtr;
}


/*
 * Functions for Computing Precedence Order
 */

/*
 *----------------------------------------------------------------------
 * TopoSortSub --
 *
 *    Stores in class->order a pointer to a new list, owned by the caller,
 *    containing the given class and all classes that depend on it:  classes
 *    the given class has been mixed into, classes in its subclass hierarchy,
 *    all classes any of them have been mixed into, recursively, with no
 *    duplicates or cycles.  During processing the encountered classes are
 *    colored WHITE, GRAY or BLACK, and finally they are all reset to WHITE.
 *
 * Results:
 *    True if the sort succeeded, i.e., if there was no cycle.
 *
 * Side effects:
 *    Allocates elements of the new list.
 *
 *----------------------------------------------------------------------
 */

enum colors { WHITE, GRAY, BLACK };

static bool TopoSortSub(NsfClass *class, NsfClass *baseClass, bool withMixinOfs)
  nonnull(1) nonnull(2);

static bool
TopoSortSub(NsfClass *class, NsfClass *baseClass, bool withMixinOfs) {
  NsfClasses *sl, *pl;
  bool        isAcyclic = NSF_TRUE;

  nonnull_assert(class != NULL);
  nonnull_assert(baseClass != NULL);

  sl = class->sub;

  /*
   * See TopoSortSuper for the meaning of the colors:
   */

  class->color = GRAY;

  for (; sl != NULL; sl = sl->nextPtr) {
    NsfClass *sc = sl->cl;

    if (sc->color == GRAY ||
        unlikely(sc->color == WHITE
                 && !TopoSortSub(sc, baseClass, withMixinOfs))
        ) {
      isAcyclic = NSF_FALSE;
      break;
    }

  }

  if (isAcyclic && withMixinOfs) {
    NsfCmdList *classMixins = ((class->opt != NULL) ? class->opt->isClassMixinOf : NULL);

    for (; classMixins != NULL; classMixins = classMixins->nextPtr) {
      NsfClass *sc = NsfGetClassFromCmdPtr(classMixins->cmdPtr);

      if (likely(sc != NULL)
          && unlikely(sc->color == WHITE &&
                      !TopoSortSub(sc, baseClass, withMixinOfs))) {
        NsfLog(sc->object.teardown, NSF_LOG_WARN,
               "cycle in the mixin graph list detected for class %s",
               ClassName_(sc));
      }
    }
  }

  class->color = BLACK;
  pl = NEW(NsfClasses);
  pl->cl = class;
  pl->nextPtr = baseClass->order;
  baseClass->order = pl;

  if (unlikely(class == baseClass)) {
    register const NsfClasses *pc;

   /*
   * Finally, reset the color of all processed classes WHITE.
   */
    for (pc = class->order; pc != NULL; pc = pc->nextPtr) {
      pc->cl->color = WHITE;
    }
    assert(isAcyclic && baseClass->order != NULL);
  }

  return isAcyclic;
}


/*
 *----------------------------------------------------------------------
 * MustBeBefore --
 *
 *    Returns true if bClass comes before aClass in a topologically-sorted
 *    list.  Compares orderings based on the class hierarchies with single
 *    inheritance and prior solved multiple inheritance orderings.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static bool MustBeBefore(const NsfClass *aClass, const NsfClass *bClass, const NsfClasses *superClasses)
  nonnull(1) nonnull(2) nonnull(3) NSF_pure;

static bool
MustBeBefore(const NsfClass *aClass, const NsfClass *bClass, const NsfClasses *superClasses) {
  bool success;

  nonnull_assert(aClass != NULL);
  nonnull_assert(bClass != NULL);
  nonnull_assert(superClasses != NULL);
  assert(bClass->order != NULL);

  /*
   * If "x" is in the precedence order of "y", E.g.
   *
   *   x {c1 object}
   *   y {c2 x object}
   *
   * then "y" must be before "x" to make the order monotonic based on
   * single inheritance.
   */
  success = (NsfClassListFind(bClass->order, aClass) != NULL);

  /*
   * When the local test doesn't indicate the order of the two classes, use
   * given multiple inheritance ordering in superClasses, e.g. coming from
   * -superclass {x y}.
   */
  if (!success) {
    const NsfClasses *sl;
    bool              found = NSF_FALSE;

#if defined(NSF_LINEARIZER_TRACE)
    fprintf(stderr, "--> check %s before %s?\n", ClassName(b), ClassName(a));
    NsfClassListPrint("superClasses", superClasses);
#endif
    for (sl = superClasses; sl != NULL; sl = sl->nextPtr) {
      if (sl->cl == bClass) {
        found = NSF_TRUE;
      } else if (found && sl->cl == aClass) {
#if defined(NSF_LINEARIZER_TRACE)
        fprintf(stderr, "%s in inheritanceList before %s therefore a < b\n",
                ClassName(bClass), ClassName(aClass));
#endif
        success = NSF_TRUE;
        break;
      }
    }
  }

#if defined(NSF_LINEARIZER_TRACE)
  fprintf(stderr, "compare a: %s %p b: %s %p -> %d\n",
          ClassName(aClass), aClass->order,
          ClassName(bClass), bClass->order, (int)success);
  NsfClassListPrint("\ta", aClass->order);
  NsfClassListPrint("\tb", bClass->order);
#endif
  return success;
}


/*
 *----------------------------------------------------------------------
 * ValidClassListTail --
 *
 *    Debugging function that assures that the provided list is valid.
 *    classListPtr must be a base class of the object system.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
#if defined(NSF_DEVELOPMENT_TEST)
static void ValidClassListTail(const char *what, NsfClasses *classListPtr) {
  NsfClasses *sl, *tail;

  for (sl = classListPtr, tail = NULL; sl != NULL; sl = sl->nextPtr) {
    tail = sl;
  }
  if (tail != NULL) {
    /* fprintf(stderr, "check tail what %s %p\n", what, ClassName(tail->cl), tail->nextPtr);*/
    assert(IsBaseClass(&tail->cl->object));
    assert(tail->nextPtr == NULL);
  }
}
#else
# define ValidClassListTail(what, classListPtr)
#endif

/*
 *----------------------------------------------------------------------
 * MergeInheritanceLists --
 *
 *    Merges the class and all the classes in its superclass hierarchy into the
 *    given list, keeping the list monotonic by adding items in precedence
 *    order.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static NsfClasses *MergeInheritanceLists(NsfClasses *pl, NsfClass *class)
  nonnull(1) nonnull(2) returns_nonnull;

static NsfClasses *
MergeInheritanceLists(NsfClasses *pl, NsfClass *class) {
  NsfClasses *sl, *baseList, **plNext, *superClasses,
    *deletionList = NULL;

  nonnull_assert(pl != NULL);
  nonnull_assert(class != NULL);

#if defined(NSF_LINEARIZER_TRACE)
  fprintf(stderr, "=== MergeInheritanceLists working on %s\n", ClassName(class));
#endif

  /*
   * The available multiple inheritance list is in reverse order. Reverse it
   * to obtain superClasses in the provided order.
   */
  superClasses = NsfReverseClasses(class->super);

  /*
   * The first baseList is the precedence list of the first element of the
   * given superclasses.  Additional baseLists are the results of partial
   * merges.
   *
   * A mergeList is merged, order-preserving, into the baseList.
   *
   */

  baseList = superClasses->cl->order;
  assert(baseList != NULL);

#if defined(NSF_LINEARIZER_TRACE)
  fprintf(stderr, "=== baseList from %s = %p\n", ClassName(superClasses->cl), baseList);
  NsfClassListPrint("baseList", baseList);
#endif

  /*
   * The first element of the result list of the merge operation is the first
   * element of the baseList.
   */
  plNext = NsfClassListAdd(&pl, baseList->cl, NULL);

  /*
   * Perform the merge operation for every element but the first, which is
   * already in the baseList.  For n elements in superClasses the merge
   * operation is performed n-1 times.
   */

  sl = superClasses->nextPtr;
  assert(superClasses->nextPtr != NULL);

  do {
    NsfClasses *mergeList = sl->cl->order, *baseListCurrent;

#if defined(NSF_LINEARIZER_TRACE)
    NsfClassListPrint("mergeList", mergeList);
#endif

    /*
     * Merge mergeList into baseList. Start with the 2nd (later probably
     * nth) entry of the baseList
     */
    baseListCurrent = baseList->nextPtr;
    assert(baseListCurrent != NULL);

    while (mergeList != NULL) {
      NsfClass *addClass;

      ValidClassListTail("baseList",  baseList);
      ValidClassListTail("mergeList", mergeList);

      assert(baseListCurrent != NULL);
      /* NsfClassListPrint("baseListCurrent", baseListCurrent); */

      if (mergeList->cl == baseListCurrent->cl) {
        /*
         * The class is already in the result. Advance in both lists.
         */
        /* fprintf(stderr, "\t\tadvance both\n"); */
        addClass = mergeList->cl;
        baseListCurrent = baseListCurrent->nextPtr;
        mergeList = mergeList->nextPtr;

      } else if (MustBeBefore(baseListCurrent->cl, mergeList->cl, superClasses)) {
        /*
         * Append the class from mergeList and advance to the next item in that
         * list.
         */
        addClass  = mergeList->cl;
        mergeList = mergeList->nextPtr;
        /* fprintf(stderr, "\t\tadd from mergeList %s\n", ClassName(addClass)); */

      } else {
        /*
         * The two cases above do not apply.  Append the class from baseList
         * and advance to the next item in that list.
         */
        addClass = baseListCurrent->cl;
        baseListCurrent = baseListCurrent->nextPtr;
        /* fprintf(stderr, "\t\tadd from baselist %s\n", ClassName(addClass)); */
      }

      if (addClass != NULL) {
        /*
         * Add the class. If the class is is already in the list, which might
         * happen only in crippled cases, delete it and then add it again.
         */
        NsfClasses *deletedElement = NsfClassListUnlink(&pl, addClass);

        if (deletedElement != NULL) {
#if defined(NSF_LINEARIZER_TRACE)
          fprintf(stderr, "\t\t%s is redundant (in resultList)\n", ClassName(addClass));
#endif
          /*
           * Search the list from the beginning if plNext points to the
           * nextPtr of the deleted element.
           */
          if (plNext == &(deletedElement->nextPtr)) {
            plNext = &pl;
          }
          NsfClassListFree(deletedElement);
        }

        /*
         * Add the class.
         */
        plNext = NsfClassListAdd(plNext, addClass, NULL);
      }

#if defined(NSF_LINEARIZER_TRACE)
      NsfClassListPrint("pl:", pl);
#endif
    }
    /*
     * mergeList is processed and the new list is now complete.  If there are
     * more superClasses, use the new list as the base list and continue with
     * the next mergeList.
     */

#if defined(NSF_LINEARIZER_TRACE)
    NsfClassListPrint("plFinal:", pl);
#endif

    if (sl->nextPtr != NULL) {
      /*
       * Not yet finished. Use the new list as baseList.
       */
      baseList = pl;

#if defined(NSF_LINEARIZER_TRACE)
      fprintf(stderr, "=== setting new baseList\n");
      NsfClassListPrint("new baseList", baseList);
#endif
      /*
       * Schedule the just-created list for deletion since it is not the final
       * list.
       */
      NsfClassListAdd(&deletionList, NULL, pl);

      /*
       * Create a new list to hold the results of the next iteration.
       */
      pl = NULL;
      plNext = NsfClassListAdd(&pl, class, NULL);
    }
    /*
     * Get next set of superClases.
     */
    sl = sl->nextPtr;
  } while (sl != NULL);

  for (sl = deletionList; sl != NULL; sl = sl->nextPtr) {
    /* fprintf(stderr, "delete from deletion list %p client data %p\n", sl, sl->clientData); */
    NsfClassListFree(sl->clientData);
  }

  if (deletionList != NULL) {
    NsfClassListFree(deletionList);
  }
  NsfClassListFree(superClasses);

  return pl;
}

#if defined(NSF_DEVELOPMENT_TEST)
static void AssertOrderIsWhite(NsfClasses *order) {
  register NsfClasses *pc;

  for (pc = order; pc != NULL; pc = pc->nextPtr) {
    assert(pc->cl->color == WHITE);
  }
}
#else
# define AssertOrderIsWhite(arg)
#endif

/*
 *----------------------------------------------------------------------
 * TopoSortSuper --
 *
 *    Computes/continues to compute the precedence order for baseClass based on
 *    the superclasses of class, updating baseClass on success.
 *
 * Results:
 *    NSF_TRUE if the order was computed, and NSF_FALSE otherwise.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static bool TopoSortSuper(NsfClass *class, NsfClass *baseClass)
  nonnull(1) nonnull(2);

static bool
TopoSortSuper(NsfClass *class, NsfClass *baseClass) {
  NsfClasses *pl, *sl;

  nonnull_assert(class != NULL);
  nonnull_assert(baseClass != NULL);

  /*
   * meaning of colors:
   *
   *     WHITE
   *        Not processed.
   *     GRAY
   *        In progress.
   *     BLACK
   *        Done.
   */

  class->color = GRAY;
  for (sl = class->super; likely(sl != NULL); sl = sl->nextPtr) {
    NsfClass *sc = sl->cl;
    /*
     * Reset the color of the unreported class to WHITE before returning.
     */

    if (sc->color == GRAY) {
      class->color = WHITE;
      return NSF_FALSE;
    }
    if (unlikely(sc->color == WHITE && !TopoSortSuper(sc, baseClass))) {
      class->color = WHITE;
      return NSF_FALSE;
    }
  }

  /*
   * Create a new item containing the class.
   */
  pl = NEW(NsfClasses);
  pl->cl = class;
  pl->nextPtr = NULL;

  /*
   * For multiple inheritance merge into the list the class and all its
   * ancestor classes, maintaining order of precedence.
   */
  if (likely(class->super != NULL) && unlikely(class->super->nextPtr != NULL)) {

    pl = MergeInheritanceLists(pl, class);

    if (baseClass->order != NULL) {
      NsfClassListFree(baseClass->order);
      /*
       * reset baseClass->order below.
       */
    }


  } else {
    /*
     * Add baseClass order to the end of the precedence list.
     */

    assert(pl->nextPtr == NULL);
    pl->nextPtr = baseClass->order;
  }

  class->color = BLACK;
  /*
   * Set baseClass order to the newly computed-list.
   */
  baseClass->order = pl;

  return NSF_TRUE;
}


/*
 *----------------------------------------------------------------------
 * PrecedenceOrder --
 *
 *    Returns a list containing the given class and all classes in its
 *    superclass hierarchy, or NULL.  This list is cached in cl->order and must
 *    be invalidated by FlushPrecedences() if the order changes.  Unlike
 *    TransitiveSubClasses, the caller does not have to free the returned list.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    Updates cl->order.
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static NsfClasses *
PrecedenceOrder(NsfClass *class) {
  register const NsfClasses *sl;
  bool                       success, haveMultipleInheritance;

  nonnull_assert(class != NULL);

  /*
   * Is the superclass order already cached?
   */
  if (likely(class->order != NULL)) {
    return class->order;
  }

  /*
   * If there are multiple direct superclasses, compute the precedence orders
   * if they aren't already computed.  Another option might be to compute the
   * precedent order only as needed.  Perform this check before calling
   * MergeInheritanceLists() by way of TopoSortSuper() because there the list
   * is in a state of flux.
   */
  haveMultipleInheritance = NSF_FALSE;
  for (sl = class->super; sl != NULL; sl = sl->cl->super) {
    if (sl != NULL && sl->nextPtr != NULL) {
      haveMultipleInheritance = NSF_TRUE;
      break;
    }
  }

  if (unlikely(haveMultipleInheritance)) {
    /*
     * At least one class has multiple direct superclasses.  Compute the
     * complete precedence order for all superclasses.  so that sublists can be
     * merged.
     */

    for (sl = class->super; sl != NULL; sl = sl->nextPtr) {
      const NsfClasses *pl;

#if defined(NSF_LINEARIZER_TRACE)
      fprintf(stderr, "====== PrecedenceOrder multiple inheritance: check %s %p \n",
              ClassName(sl->cl), sl->cl->order);
#endif
      if (unlikely(sl->cl->order == NULL) && likely(class != sl->cl)) {
#if defined(NSF_LINEARIZER_TRACE)
        fprintf(stderr, "====== PrecedenceOrder multiple inheritance computes required order for %s \n",
                ClassName(sl->cl));
#endif
        PrecedenceOrder(sl->cl);
#if defined(NSF_LINEARIZER_TRACE)
        NsfClassListPrint("====== PrecedenceOrder multiple inheritance:", sl->cl->order);
#endif
      }

      for (pl = sl->cl->order; pl != NULL; pl = pl->nextPtr) {
#if defined(NSF_LINEARIZER_TRACE)
        fprintf(stderr, "====== PrecedenceOrder multiple inheritance: %s %p\n",
                ClassName(pl->cl), pl->cl->order);
#endif
        if (pl->cl->order == NULL) {
#if defined(NSF_LINEARIZER_TRACE)
          fprintf(stderr, "========== recurse\n");
#endif
          PrecedenceOrder(pl->cl);
        }
      }
    }
  }

  success = TopoSortSuper(class, class);

  /*
   * Reset the color of all nodes before exiting.
   */
  for (sl = class->order; sl != NULL; sl = sl->nextPtr) {
    sl->cl->color = WHITE;
  }

  /*
   * If computation is successful, return cl->order.  Otherwise clear
   * cl->order.
   */
  if (likely(success)) {
    AssertOrderIsWhite(class->order);
    /*
     * TopoSortSuper succeeded, the cl-order is already set.
     */
  } else if (class->order != NULL) {
    /*
     * TopoSortSuper failed but there is a computed cl->order. Clear it.
     */
    NsfClassListFree(class->order);
    class->order = NULL;
  } else {
    /*
     * TopoSortSuper failed, but there is no computed cl->order. Nothing to
     * do.
     */
  }

#if defined(NSF_LINEARIZER_TRACE)
  NsfClassListPrint("!!! PrecedenceOrder computed", class->order);
#endif

  return class->order;
}

/*
 *----------------------------------------------------------------------
 * GetSubClasses --
 *
 *    Returns a list, owned by the caller, of the current class, all classes in
 *    its hierarchy, all classes any of the listed classes are mixed into,
 *    recursively.
 *
 * Results:
 *    The list of classes.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

NSF_INLINE static NsfClasses *
GetSubClasses(NsfClass *class, bool withMixinOfs)
  nonnull(1) returns_nonnull;

#define TransitiveSubClasses(class)                         \
  GetSubClasses((class), NSF_FALSE)

#define DependentSubClasses(class)                         \
  GetSubClasses((class), NSF_TRUE)

NSF_INLINE static NsfClasses *
GetSubClasses(NsfClass *class, bool withMixinOfs) {
  NsfClasses *order, *savedOrder;

  nonnull_assert(class != NULL);

  /*
   * TopoSort() places its result in cl->order, so save the existing cl->order,
   * perform the computation, and restore the saved order.
   */
  savedOrder = class->order;
  class->order = NULL;

  (void)TopoSortSub(class, class, withMixinOfs);

  order = class->order;
  assert(order != NULL);

  AssertOrderIsWhite(order);

  class->order = savedOrder;
  return order;
}

/*
 *----------------------------------------------------------------------
 * FlushPrecedences --
 *
 *    Iterates over the given list of classes, freeing each "order" member.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void FlushPrecedences(const NsfClasses *subClasses)
  nonnull(1);

static void
FlushPrecedences(const NsfClasses *subClasses) {

  nonnull_assert(subClasses != NULL);

  do {
    if (subClasses->cl->order != NULL) {
      NsfClassListFree(subClasses->cl->order);
    }
    subClasses->cl->order = NULL;
    subClasses = subClasses->nextPtr;
  } while (subClasses != NULL);
}


/*
 *----------------------------------------------------------------------
 * AddInstance --
 *
 *    Registers the given object as an instance of the given class.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Adds an entry to the "instances" hash table of the class.
 *
 *----------------------------------------------------------------------
 */
static void AddInstance(NsfObject *object, NsfClass *class)
  nonnull(1) nonnull(2);

static void
AddInstance(NsfObject *object, NsfClass *class) {
  int isNewItem;

  nonnull_assert(object != NULL);
  nonnull_assert(class != NULL);

  object->cl = class;
  (void) Tcl_CreateHashEntry(&class->instances, (char *)object, &isNewItem);
  /*if (newItem == 0) {
    fprintf(stderr, "instance %p %s was already an instance of %p %s\n", object, ObjectName(object), cl, ClassName(class));
    }*/
  assert(isNewItem != 0);
}


/*
 *----------------------------------------------------------------------
 * RemoveInstance --
 *
 *    Unregisters the given object as an instance of the given class, verifying
 *    that the entry still represents an existing object before deleting the
 *    entry.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Deletes an entry from the "instances" table of the class.
 *
 *----------------------------------------------------------------------
 */
static void RemoveInstance(const NsfObject *object, NsfClass *class)
  nonnull(1) nonnull(2);

static void
RemoveInstance(const NsfObject *object, NsfClass *class) {

  nonnull_assert(object != NULL);
  nonnull_assert(class != NULL);

  /*
   * During delete, which is not normally the case prevent an abort due to a
   * deleted hash table.
   */
  if (unlikely(class->object.flags & NSF_DURING_DELETE) != 0u) {
    NsfLog(class->object.teardown, NSF_LOG_WARN,
           "The class %s, from which an instance is to be removed, is currently under deletion",
            ObjStr((class)->object.cmdName));
  } else {
    Tcl_HashEntry *hPtr = Tcl_CreateHashEntry(&class->instances, (char *)object, NULL);

    /*if (hPtr == NULL) {
      fprintf(stderr, "instance %s is not an instance of %s\n", ObjectName(object), ClassName(class));
      }*/
    assert(hPtr != NULL);
    Tcl_DeleteHashEntry(hPtr);
  }
}

/*
 * superclass/subclass list maintenance.
 */
static void AddSuper1(NsfClass *class, NsfClasses **sl)
  nonnull(1) nonnull(2);
static void AddSuper(NsfClass *class, NsfClass *superClass)
  nonnull(1);
static bool RemoveSuper1(NsfClass *class, NsfClasses **sl)
  nonnull(1) nonnull(2);
static bool RemoveSuper(NsfClass *class, NsfClass *superClass)
  nonnull(1) nonnull(2);

static void
AddSuper1(NsfClass *class, NsfClasses **sl) {
  NsfClasses *sc = NEW(NsfClasses);

  nonnull_assert(class != NULL);
  nonnull_assert(sl != NULL);

  sc->cl = class;
  sc->nextPtr = *sl;
  *sl = sc;
}

static void
AddSuper(NsfClass *class, NsfClass *superClass) {

  nonnull_assert(class != NULL);

  if (superClass != NULL) {
    /*
     * keep corresponding sub in step with super.
     */
    AddSuper1(superClass, &class->super);
    AddSuper1(class, &superClass->sub);
  }
}

static bool
RemoveSuper1(NsfClass *class, NsfClasses **sl) {
  NsfClasses *l;
  bool        result;

  nonnull_assert(class != NULL);
  nonnull_assert(sl != NULL);

  l = *sl;

  if (l == NULL) {
    result = NSF_FALSE;

  } else if (l->cl == class) {
    *sl = l->nextPtr;
    FREE(NsfClasses, l);
    result = NSF_TRUE;

  } else {
    while ((l->nextPtr != NULL) && (l->nextPtr->cl != class)) {
      l = l->nextPtr;
    }
    if (l->nextPtr != NULL) {
      NsfClasses *n = l->nextPtr->nextPtr;
      FREE(NsfClasses, l->nextPtr);
      l->nextPtr = n;
      result = NSF_TRUE;
    } else {
      result = NSF_FALSE;
    }
  }
  return result;
}

static bool
RemoveSuper(NsfClass *class, NsfClass *superClass) {
  bool sp, sb;

  nonnull_assert(class != NULL);
  nonnull_assert(superClass != NULL);

  /*
   * Keep corresponding sub in step with super.
   */

  sp = RemoveSuper1(superClass, &class->super);
  sb = RemoveSuper1(class, &superClass->sub);

  return sp && sb;
}

/*
 * methods lookup
 */

/*
 *----------------------------------------------------------------------
 * GetEnsembleObjectFromName --
 *
 *    Returns the ensemble object for the given method name if there is one,
 *    and NULL otherwise.  If the method name is fully-qualified, just use a
 *    Tcl lookup. Otherwise, look it up in the given namespace.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static NsfObject *GetEnsembleObjectFromName(
    Tcl_Interp *interp, Tcl_Namespace *nsPtr, Tcl_Obj *nameObj,
    Tcl_Command *cmdPtr, bool *fromClassNS
) nonnull(1) nonnull(3) nonnull(4) nonnull(5);

static NsfObject *
GetEnsembleObjectFromName(Tcl_Interp *interp, Tcl_Namespace *nsPtr, Tcl_Obj *nameObj,
                         Tcl_Command *cmdPtr, bool *fromClassNS) {
  Tcl_Command  cmd;
  const char  *nameString;
  NsfObject   *result;

  nonnull_assert(interp != NULL);
  nonnull_assert(nameObj != NULL);
  nonnull_assert(cmdPtr != NULL);
  nonnull_assert(fromClassNS != NULL);

  nameString = ObjStr(nameObj);
  if (*nameString == ':') {
    cmd = Tcl_GetCommandFromObj(interp, nameObj);
    *fromClassNS = IsClassNsName(nameString, NULL);
  } else {
    cmd = (nsPtr != NULL) ? FindMethod(nsPtr, nameString) : NULL;
  }

  if (cmd != NULL) {
    *cmdPtr = cmd;
    result = NsfGetObjectFromCmdPtr(GetOriginalCommand(cmd));
  } else {
    result = NULL;
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * GetRegObject --
 *
 *    Attempts to get from the given fully-qualified method handle the object
 *    on which the method was registered.
 *
 * Results:
 *    NsfObject * or NULL.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static NsfObject *GetRegObject(Tcl_Interp *interp, Tcl_Command cmd, const char *methodName,
                               const char **methodName1, bool *fromClassNS)
  nonnull(1) nonnull(3) nonnull(5) nonnull(2);

static NsfObject *
GetRegObject(Tcl_Interp *interp, Tcl_Command cmd, const char *methodName,
             const char **methodName1, bool *fromClassNS) {
  NsfObject  *regObject;
  const char *procName;
  size_t      objNameLength;

  nonnull_assert(interp != NULL);
  nonnull_assert(cmd != NULL);
  nonnull_assert(methodName != NULL);
  assert(*methodName == ':');
  nonnull_assert(fromClassNS != NULL);
  nonnull_assert(cmd != NULL);

  procName = Tcl_GetCommandName(interp, cmd);
  objNameLength = strlen(methodName) - strlen(procName) - 2;

  if (objNameLength > 0) {
    Tcl_DString ds, *dsPtr = &ds;

    /*
     * Obtain parent name.
     */
    Tcl_DStringInit(dsPtr);
    Tcl_DStringAppend(dsPtr, methodName, (int)objNameLength);
    regObject = GetObjectFromNsName(interp, Tcl_DStringValue(dsPtr), fromClassNS);
    if (regObject != NULL && methodName1 != NULL) {
      *methodName1 = procName;
    }
    Tcl_DStringFree(dsPtr);
  } else {
    regObject = NULL;
  }

  /*fprintf(stderr, "GetRegObject cmd %p methodName '%s' => %p\n", cmd, methodName, regObject);*/
  return regObject;
}

/*
 *----------------------------------------------------------------------
 * ResolveMethodName --
 *
 *    Finds the command, if any, for the given method name relative to a
 *    provided namespace. The name can be simple, fully-qualified, or a list
 *    that includes subcommands.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static Tcl_Command ResolveMethodName(
    Tcl_Interp *interp,
    Tcl_Namespace *nsPtr,
    Tcl_Obj *methodObj,
    Tcl_DString *methodNameDs,
    NsfObject **regObject,
    NsfObject **defObject,
    const char **methodName1, bool *fromClassNS
) nonnull(1) nonnull(3) nonnull(8);

static Tcl_Command
ResolveMethodName(
    Tcl_Interp *interp,
    Tcl_Namespace *nsPtr,
    Tcl_Obj *methodObj,
    Tcl_DString *methodNameDs,
    NsfObject **regObject,
    NsfObject **defObject,
    const char **methodName1,
    bool *fromClassNS
) {
  const char *methodName;
  NsfObject  *referencedObject;
  bool        containsSpace, tailContainsSpace;
  Tcl_Command cmd;

  nonnull_assert(interp != NULL);
  nonnull_assert(methodObj != NULL);
  nonnull_assert(fromClassNS != NULL);

  methodName = ObjStr(methodObj);

  /*fprintf(stderr, "methodName '%s' comp %d type %s\n",
    methodName, strchr(methodName, ' ')>0, ObjTypeStr(methodObj));*/

  if (methodObj->typePtr == Nsf_OT_listType) {
    int length;

    Tcl_ListObjLength(interp, methodObj, &length);
    containsSpace = (length > 1);

  } else if (methodObj->typePtr == Nsf_OT_tclCmdNameType) {
    containsSpace = NSF_FALSE;
  } else {
    containsSpace = NsfHasTclSpace(methodName);
  }

  if (containsSpace) {
    tailContainsSpace = NsfHasTclSpace(NSTail(methodName));
  } else {
    tailContainsSpace = NSF_FALSE;
  }
  /*fprintf(stderr, "<%s> containsSpace %d tailContainsSpace %d\n", methodName, containsSpace, tailContainsSpace);*/

#if !defined(NDEBUG)
  if (containsSpace) {
    assert(NsfHasTclSpace(methodName));
  } else {
    assert(!tailContainsSpace);
  }
#endif

  if (tailContainsSpace) {
    const char          *firstElementString;
    const Tcl_Namespace *parentNsPtr;
    const NsfObject     *ensembleObject;
    Tcl_Obj             *methodHandleObj, **ov;
    int                  oc, i;

    /*
     * If the name is given, methodNameDS must also be given.
     */
    assert(methodName1 == NULL || methodNameDs != NULL);

    /*fprintf(stderr, "name '%s' contains space \n", methodName);*/

    if (likely(Tcl_ListObjGetElements(interp, methodObj, &oc, &ov) != TCL_OK)
        || ((referencedObject = GetEnsembleObjectFromName(interp, nsPtr, ov[0],
                                                          &cmd, fromClassNS)) == NULL)
        ) {
      if (methodName1 != NULL) {
        *methodName1 = NULL;
      }
      if (regObject != NULL) {
        *regObject = NULL;
      }
      if (defObject != NULL) {
        *defObject = NULL;
      }
      return NULL;
    }

    /*
     * This is an ensemble object. Determine which object the ensemble object
     * belongs to, and set the the regObject either from the first item in the
     * list or from the current object.
     */
    firstElementString = ObjStr(ov[0]);
    if (*firstElementString == ':') {
      NsfObject *registrationObject;

      registrationObject = GetRegObject(interp, cmd, firstElementString, methodName1, fromClassNS);
      if (regObject != NULL) {
        *regObject = registrationObject;
      }
    } else {
      if (regObject != NULL) {
        *regObject = NULL;
      }
    }

    /*fprintf(stderr, "... regObject object '%s' reg %p, fromClassNS %d\n",
      ObjectName(referencedObject), *regObject, *fromClassNS);*/

    /*
     * Create a new methodHandleObj to hold the method name and the names of
     * any subcommands.
     */
    methodHandleObj = Tcl_DuplicateObj(referencedObject->cmdName);
    INCR_REF_COUNT(methodHandleObj);

    if (methodNameDs != NULL) {
      Tcl_DStringAppend(methodNameDs, Tcl_GetCommandName(interp, cmd), -1);
    }
    parentNsPtr = NULL;

    /*
     * Iterate over the objects and append to the methodNameDs and methodHandleObj.
     */
    for (i = 1; i < oc; i++) {
      cmd = Tcl_GetCommandFromObj(interp, methodHandleObj);
      ensembleObject = (cmd != NULL) ? NsfGetObjectFromCmdPtr(cmd) : NULL;

      if (ensembleObject == NULL) {
        DECR_REF_COUNT(methodHandleObj);
        if (methodName1 != NULL) {
          *methodName1 = NULL;
        }
        if (regObject != NULL) {
          *regObject = NULL;
        }
        if (defObject != NULL) {
          *defObject = NULL;
        }
        return NULL;
      }

      if (parentNsPtr != NULL
          && (Tcl_Command_nsPtr(ensembleObject->id) != parentNsPtr)) {
        /* fprintf(stderr, "*** parent change saved parent %p %s computed parent %p %s\n",
                parentNsPtr, parentNsPtr->fullName,
                Tcl_Command_nsPtr(ensembleObject->id),
                Tcl_Command_nsPtr(ensembleObject->id)->fullName);*/
        DECR_REF_COUNT(methodHandleObj);
        methodHandleObj = Tcl_DuplicateObj(ensembleObject->cmdName);
      }
      parentNsPtr = ensembleObject->nsPtr;

      Tcl_AppendLimitedToObj(methodHandleObj, "::", 2, INT_MAX, NULL);
      Tcl_AppendLimitedToObj(methodHandleObj, ObjStr(ov[i]), -1, INT_MAX, NULL);
      if (methodNameDs != NULL) {
        Tcl_DStringAppendElement(methodNameDs, ObjStr(ov[i]));
      }
    }

    /*
     * cmd now contains the object the method is for.
     */
    if (defObject != NULL) {
      *defObject = NsfGetObjectFromCmdPtr(cmd);
    }

    /*fprintf(stderr, "... handle '%s' last cmd %p defObject %p\n",
      ObjStr(methodHandleObj), cmd, *defObject);*/

    /*
     * Obtain the command from the method handle and retrieve the final
     * methodName.
     */
    cmd = Tcl_GetCommandFromObj(interp, methodHandleObj);
    if (methodNameDs != NULL && methodName1 != NULL) {
      *methodName1 = Tcl_DStringValue(methodNameDs);
    }

    /*fprintf(stderr, "... methodname1 '%s' cmd %p\n", Tcl_DStringValue(methodNameDs), cmd);*/
    DECR_REF_COUNT(methodHandleObj);

  } else if (*methodName == ':') {

    cmd = Tcl_GetCommandFromObj(interp, methodObj);
    if (likely(cmd != NULL)) {
      referencedObject = GetRegObject(interp, cmd, methodName, methodName1, fromClassNS);
      if (regObject != NULL) {
        *regObject = referencedObject;
      }
      if (defObject != NULL) {
        *defObject = referencedObject;
      }
      if (methodName1 && *methodName1 == NULL) {
        /*
	 * The method name is required but was not computed by GetRegObject().
         */
        *methodName1 = Tcl_GetCommandName(interp, cmd);
      }
    } else {
      /*
       * The cmd was not registered on an object or class, but it might be
       * e.g. a primitive cmd.  Return it.
       */
      if (regObject != NULL) {
        *regObject = NULL;
      }
      if (defObject != NULL) {
        *defObject = NULL;
      }
    }
  } else {
    if (methodName1 != NULL) {
      *methodName1 = methodName;
    }
    cmd = (nsPtr != NULL) ? FindMethod(nsPtr, methodName) : NULL;
    if (regObject != NULL) {
      *regObject = NULL;
    }
    if (defObject != NULL) {
      *defObject = NULL;
    }
  }

  return cmd;
}

/*
 *----------------------------------------------------------------------
 * CmdIsProc --
 *
 *    True if the given command is interpreted.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static bool CmdIsProc(const Tcl_Command cmd)
  nonnull(1) NSF_pure;

NSF_INLINE static bool
CmdIsProc(const Tcl_Command cmd) {
  /*
   * In 8.6, TclIsProc((Command *)cmd) is not equivalent to this definition
   */
  nonnull_assert(cmd != NULL);
  return (Tcl_Command_objProc(cmd) == TclObjInterpProc);
}

/*
 *----------------------------------------------------------------------
 * CmdIsNsfObject --
 *
 *    True if the given command is for an NsfObject or Class.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static bool CmdIsNsfObject(Tcl_Command cmd)
  nonnull(1) NSF_pure;

NSF_INLINE static bool
CmdIsNsfObject(Tcl_Command cmd) {
  nonnull_assert(cmd != NULL);
  return Tcl_Command_objProc(cmd) == NsfObjDispatch;
}

/*
 *----------------------------------------------------------------------
 * GetTclProcFromCommand --
 *
 *    Returns the procedure for a command if it is a Tcl procedure.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static Proc *GetTclProcFromCommand(const Tcl_Command cmd)
  nonnull(1) NSF_pure;

static Proc *
GetTclProcFromCommand(const Tcl_Command cmd) {
  Tcl_ObjCmdProc *proc;
  Proc           *result;

  nonnull_assert(cmd != NULL);
  proc = Tcl_Command_objProc(cmd);
  if (proc == TclObjInterpProc) {
    result = (Proc *)Tcl_Command_objClientData(cmd);
  } else {
    result = NULL;
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * FindMethod --
 *
 *    Returns the command for the named method in the given namespace, if there
 *    is one.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

NSF_INLINE static Tcl_Command
FindMethod(
    const Tcl_Namespace *nsPtr,
    const char *methodName
) {
  register const Tcl_HashEntry *entryPtr;
  Tcl_Command                   result;

  nonnull_assert(nsPtr != NULL);
  nonnull_assert(methodName != NULL);

  if ((entryPtr = Tcl_CreateHashEntry(Tcl_Namespace_cmdTablePtr(nsPtr), methodName, NULL))) {
    result = (Tcl_Command) Tcl_GetHashValue(entryPtr);
  } else {
    result = NULL;
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * FindProcMethod --
 *
 *    Returns the Proc for methodName in the given namespace, if there is one.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static Proc * FindProcMethod(const Tcl_Namespace *nsPtr, const char *methodName)
  nonnull(1) nonnull(2);

static Proc *
FindProcMethod(const Tcl_Namespace *nsPtr, const char *methodName) {
  Tcl_Command cmd;

  nonnull_assert(nsPtr != NULL);
  nonnull_assert(methodName != NULL);

  cmd = FindMethod(nsPtr, methodName);
  return (cmd != NULL) ? GetTclProcFromCommand(cmd) : NULL;
}

/*
 *----------------------------------------------------------------------
 * SearchPLMethod, SearchPLMethod0 --
 *
 *    Returns the class for the named method if it exists in the given list.
 *    The name must be simple, i.e. it must not contain whitespace.
 *    SearchPLMethod() accepts a flag for filtering the command, and
 *    SearchPLMethod0() is slightly more optimized without the filtering
 *    option.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static NsfClass * SearchPLMethod(
    register const NsfClasses *pl, const char *methodName,
    Tcl_Command *cmdPtr, unsigned int flags
) nonnull(1) nonnull(2) nonnull(3);

static NsfClass * SearchPLMethod0(
    register const NsfClasses *pl, const char *methodName,
    Tcl_Command *cmdPtr
) nonnull(1) nonnull(2) nonnull(3);

static NsfClass *
SearchPLMethod0(
    register const NsfClasses *pl,
    const char *methodName,
    Tcl_Command *cmdPtr
) {
  nonnull_assert(pl != NULL);
  nonnull_assert(methodName != NULL);
  nonnull_assert(cmdPtr != NULL);

  /*
   * Search the precedence list, i.e. the class hierarchy.
   */
  do {
    register const Tcl_HashEntry *entryPtr =
      Tcl_CreateHashEntry(
        Tcl_Namespace_cmdTablePtr(pl->cl->nsPtr), methodName, NULL);

    if (entryPtr != NULL) {
      *cmdPtr = (Tcl_Command) Tcl_GetHashValue(entryPtr);
      return pl->cl;
    }
    pl = pl->nextPtr;
  } while (pl != NULL);

  return NULL;
}

static NsfClass *
SearchPLMethod(
    register const NsfClasses *pl, const char *methodName,
    Tcl_Command *cmdPtr, unsigned int flags
) {

  nonnull_assert(pl != NULL);
  nonnull_assert(methodName != NULL);
  nonnull_assert(cmdPtr != NULL);

  /*
   * Search the precedence list, i.e. the class hierarchy.
   */
  do {
    register const Tcl_HashEntry *entryPtr =
      Tcl_CreateHashEntry(Tcl_Namespace_cmdTablePtr(pl->cl->nsPtr), methodName, NULL);

    if (entryPtr != NULL) {
      Tcl_Command cmd = (Tcl_Command) Tcl_GetHashValue(entryPtr);

      if (likely(((unsigned int)Tcl_Command_flags(cmd) & flags) == 0u)) {
        *cmdPtr = cmd;
        return pl->cl;
      }
    }
    pl = pl->nextPtr;
  } while (pl != NULL);

  return NULL;
}

/*
 *----------------------------------------------------------------------
 * SearchCMethod --
 *
 *    Locates the named method along the superclass hierarchy of the given
 *    class and returns that class, if any.  methodName must not contain
 *    whitespace.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static NsfClass * SearchCMethod(NsfClass *class, const char *methodName, Tcl_Command *cmdPtr)
  nonnull(1) nonnull(2) nonnull(3);

static NsfClass *
SearchCMethod(NsfClass *class, const char *methodName, Tcl_Command *cmdPtr) {

  nonnull_assert(methodName != NULL);
  nonnull_assert(cmdPtr != NULL);
  nonnull_assert(class != NULL);

  return SearchPLMethod0(PrecedenceOrder(class), methodName, cmdPtr);
}

/*
 *----------------------------------------------------------------------
 * SearchSimpleCMethod --
 *
 *    Like SearchCMethod, but the name is a Tcl_Obj.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static NsfClass * SearchSimpleCMethod(Tcl_Interp *UNUSED(interp),
                                      NsfClass *class, Tcl_Obj *methodObj,
                                      Tcl_Command *cmdPtr)
  nonnull(2) nonnull(3) nonnull(4);

static NsfClass *
SearchSimpleCMethod(
    Tcl_Interp *UNUSED(interp), NsfClass *class,
    Tcl_Obj *methodObj, Tcl_Command *cmdPtr
) {

  nonnull_assert(class != NULL);
  nonnull_assert(methodObj != NULL);
  nonnull_assert(cmdPtr != NULL);

  return SearchPLMethod0(PrecedenceOrder(class), ObjStr(methodObj), cmdPtr);
}

/*
 *----------------------------------------------------------------------
 * SearchComplexCMethod --
 *
 *    Like SearchSimpleCMethod but the method name may refer to an ensemble
 *    object, i.e. it can contain whitespace characters.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static NsfClass * SearchComplexCMethod(Tcl_Interp *interp, NsfClass *class,
                     Tcl_Obj *methodObj, Tcl_Command *cmdPtr)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static NsfClass *
SearchComplexCMethod(Tcl_Interp *interp, NsfClass *class,
                     Tcl_Obj *methodObj, Tcl_Command *cmdPtr) {
  NsfClasses *pl;
  bool        fromClassNS = NSF_TRUE;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(methodObj != NULL);
  nonnull_assert(cmdPtr != NULL);

  for (pl = PrecedenceOrder(class); pl != NULL;  pl = pl->nextPtr) {
    Tcl_Command cmd = ResolveMethodName(interp, pl->cl->nsPtr, methodObj,
                                        NULL, NULL, NULL, NULL, &fromClassNS);
    if (cmd != NULL) {
      *cmdPtr = cmd;
      return pl->cl;
    }
  }

  return NULL;
}

/*
 *----------------------------------------------------------------------
 * ObjectFindMethod --
 *
 *    Finds a method in the precedence path for the given name, which may be an
 *    ensemble name, attempting to optimize by differentiating simple names
 *    from ensemble names.
 *
 * Results:
 *    A Tcl command.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static Tcl_Command ObjectFindMethod(Tcl_Interp *interp, NsfObject *object, Tcl_Obj *methodObj, NsfClass **classPtr)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static Tcl_Command
ObjectFindMethod(Tcl_Interp *interp, NsfObject *object, Tcl_Obj *methodObj, NsfClass **classPtr) {
  Tcl_Command cmd = NULL;
  NsfClass *(*lookupFunction)(Tcl_Interp *interp, NsfClass *class,
                              Tcl_Obj *methodObj, Tcl_Command *cmdPtr);

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodObj != NULL);
  nonnull_assert(classPtr != NULL);

  if (NsfHasTclSpace(ObjStr(methodObj))) {
    lookupFunction = SearchComplexCMethod;
  } else {
    lookupFunction = SearchSimpleCMethod;
  }

  if (unlikely(object->flags & NSF_MIXIN_ORDER_VALID) == 0u) {
    MixinComputeDefined(interp, object);
  }

  if ((object->flags & NSF_MIXIN_ORDER_DEFINED_AND_VALID) != 0u) {
    NsfCmdList *mixinList;

    for (mixinList = object->mixinOrder; mixinList; mixinList = mixinList->nextPtr) {
      NsfClass *mixin = NsfGetClassFromCmdPtr(mixinList->cmdPtr);

      if ((mixin != NULL)
          && (*classPtr = (*lookupFunction)(interp, mixin, methodObj, &cmd))) {
        if (((unsigned int)Tcl_Command_flags(cmd) & NSF_CMD_CLASS_ONLY_METHOD) != 0u
            && !NsfObjectIsClass(object)
           ) {
          cmd = NULL;
          continue;
        }
        break;
      }
    }
  }

  if ((cmd == NULL) && (object->nsPtr != NULL)) {
    bool fromClassNS = NSF_FALSE;

    cmd = ResolveMethodName(interp, object->nsPtr, methodObj,
                            NULL, NULL, NULL, NULL, &fromClassNS);
  }

  if (cmd == NULL && object->cl != NULL) {
    *classPtr = (*lookupFunction)(interp, object->cl, methodObj, &cmd);
  }

  return cmd;
}

/*
 *----------------------------------------------------------------------
 * GetObjectSystem --
 *
 *    Returns a pointer to the object system the given object belongs to.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static NsfObjectSystem * GetObjectSystem(const NsfObject *object)
  nonnull(1) NSF_pure;

static NsfObjectSystem *
GetObjectSystem(const NsfObject *object) {

  nonnull_assert(object != NULL);

  if (NsfObjectIsClass(object)) {
    return ((NsfClass *)object)->osPtr;
  }
  assert(object->cl != NULL);
  return object->cl->osPtr;
}

/*
 *----------------------------------------------------------------------
 * ObjectSystemFree --
 *
 *    Frees a single object system structure, including its root classes.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static void ObjectSystemFree(Tcl_Interp *interp, NsfObjectSystem *osPtr)
  nonnull(1) nonnull(2);

static void
ObjectSystemFree(Tcl_Interp *interp, NsfObjectSystem *osPtr) {
  int idx;

  nonnull_assert(interp != NULL);
  nonnull_assert(osPtr != NULL);

  for (idx = 0; idx <= NSF_s_set_idx; idx++) {
    if (osPtr->methods[idx]) {
      DECR_REF_COUNT(osPtr->methods[idx]);
      osPtr->methodNames[idx] = NULL;
    }
    if (osPtr->handles[idx]) {
      DECR_REF_COUNT(osPtr->handles[idx]);
    }
  }

  if (osPtr->rootMetaClass != NULL && osPtr->rootClass != NULL) {
    RemoveSuper(osPtr->rootMetaClass, osPtr->rootClass);
    RemoveInstance((NsfObject *)osPtr->rootMetaClass, osPtr->rootMetaClass);
    RemoveInstance((NsfObject *)osPtr->rootClass, osPtr->rootMetaClass);

    FinalObjectDeletion(interp, &osPtr->rootClass->object);
    FinalObjectDeletion(interp, &osPtr->rootMetaClass->object);
  }

  FREE(NsfObjectSystem, osPtr);
}

/*
 *----------------------------------------------------------------------
 * ObjectSystemAdd --
 *
 *    Adds an object system to the list of object systems for the interpreter.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void ObjectSystemAdd(Tcl_Interp *interp, NsfObjectSystem *osPtr)
  nonnull(1) nonnull(2);

static void
ObjectSystemAdd(Tcl_Interp *interp, NsfObjectSystem *osPtr) {

  nonnull_assert(interp != NULL);
  nonnull_assert(osPtr != NULL);

  osPtr->nextPtr = RUNTIME_STATE(interp)->objectSystems;
  RUNTIME_STATE(interp)->objectSystems = osPtr;
}



/*
 *----------------------------------------------------------------------
 * ObjectSystemsCleanup --
 *
 *    Deletes all objects from all defined object systems.  Called when a Next
 *    Scripting process or thread exists.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static int ObjectSystemsCleanup(Tcl_Interp *interp, bool withKeepvars)
  nonnull(1);

static int
ObjectSystemsCleanup(Tcl_Interp *interp, bool withKeepvars) {
  NsfCmdList      *instances = NULL, *entryPtr;
  NsfObjectSystem *osPtr;

  nonnull_assert(interp != NULL);

  /*
   * Perform deletion in two rounds to retain classes until after execution of any methods
   * invoked during destruction.
   *  round 1:  soft destory
   *      Invoke all user-defined destruction methods but don't delete objects.
   *  round 2:  physical destroy:
   *      Delete the objects and classes without calling any destroy methods.
   *
   * Iterate over all object systems simultaneously since there might be
   * dependencies between objects of different systems.
   *
   */

  /*
   * Collect all instances from all object systems.
   */

  for (osPtr = RUNTIME_STATE(interp)->objectSystems; osPtr != NULL; osPtr = osPtr->nextPtr) {
    GetAllInstances(interp, &instances, osPtr->rootClass);
  }

  /***** SOFT DESTROY *****/
  RUNTIME_STATE(interp)->exitHandlerDestroyRound = NSF_EXITHANDLER_ON_SOFT_DESTROY;

  /*fprintf(stderr, "===CALL destroy on OBJECTS\n");*/

  for (entryPtr = instances; entryPtr != NULL; entryPtr = entryPtr->nextPtr) {
    NsfObject *object = (NsfObject *)entryPtr->clorobj;

    /*fprintf(stderr, "key = %s %p %d flags %.6x\n",
      ObjectName(object), object, object && !NsfObjectIsClass(object), object->flags);*/

    if (object != NULL
        && !NsfObjectIsClass(object)
        && ((object->flags & NSF_DESTROY_CALLED) == 0u)
       ) {
      DispatchDestroyMethod(interp, object, 0u);
    }
  }

  /*fprintf(stderr, "===CALL destroy on CLASSES\n");*/

  for (entryPtr = instances; entryPtr != NULL; entryPtr = entryPtr->nextPtr) {
    const NsfClass *class = entryPtr->clorobj;

    if (class != NULL
        && ((class->object.flags & NSF_DESTROY_CALLED) == 0u)
       ) {
      DispatchDestroyMethod(interp, (NsfObject *)class, 0u);
    }
  }

  /*
   * All destruction callbacks are done. Turn off filters.
   */
  RUNTIME_STATE(interp)->doFilters = 0;
  (void)Tcl_RemoveInterpResolvers(interp, "nsf");

#ifdef DO_CLEANUP
  FreeAllNsfObjectsAndClasses(interp, &instances);
# ifdef DO_FULL_CLEANUP
  DeleteProcsAndVars(interp, Tcl_GetGlobalNamespace(interp), withKeepvars);
# endif
#endif
  (void)withKeepvars; /* make sure the variable is not reported as unused */

#ifdef DO_CLEANUP
  {
    NsfObjectSystem *nPtr;
    /*
     * Free all objects systems and their root classes.
     */
    for (osPtr = RUNTIME_STATE(interp)->objectSystems; osPtr != NULL; osPtr = nPtr) {
      nPtr = osPtr->nextPtr;
      ObjectSystemFree(interp, osPtr);
    }
  }

  /*
   * Finally, free all nsfprocs.
   */
  DeleteNsfProcs(interp, NULL);
#endif

  CmdListFree(&instances, NULL);

  return TCL_OK;
}


/*
 *----------------------------------------------------------------------
 * CallDirectly --
 *
 *    Returns true if a method should be called directly rather than dispatched
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    Stores the name of the method in methodObjPtr.
 *
 *----------------------------------------------------------------------
 */
static bool CallDirectly(Tcl_Interp *interp, NsfObject *object, int methodIdx, Tcl_Obj **methodObjPtr)
  nonnull(1) nonnull(2) nonnull(4);

static bool
CallDirectly(Tcl_Interp *interp, NsfObject *object, int methodIdx, Tcl_Obj **methodObjPtr) {
  /*
   * In the following cases, call a C-implemented method directly:
   *
   *        There is no matching method in the object system.
   *
   *        The script does not contain a method with the appropriate name.
   *
   *        Filters are not active on the object.
   */
  NsfObjectSystem *osPtr = GetObjectSystem(object);
  bool             callDirectly = NSF_TRUE;
  Tcl_Obj         *methodObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodObjPtr != NULL);

  methodObj = osPtr->methods[methodIdx];
  /*fprintf(stderr, "OS of %s is %s, method %s methodObj %p osPtr %p defined %.8x %.8x overloaded %.8x %.8x flags %.8x\n",
          ObjectName(object), ObjectName(&osPtr->rootClass->object),
          Nsf_SystemMethodOpts[methodIdx]+1, methodObj,
          osPtr,
          osPtr->definedMethods, osPtr->definedMethods & (1 << methodIdx),
          osPtr->overloadedMethods, osPtr->overloadedMethods & (1 << methodIdx),
          1 << methodIdx );*/

  if (methodObj != NULL) {
    unsigned int flag = 1u << methodIdx;

    if ((osPtr->overloadedMethods & flag) != 0u) {
      /*
       * The method is overloaded.  It must be dispatched.
       */
      /*fprintf(stderr, "overloaded\n");*/
      callDirectly = NSF_FALSE;
    } else if ((osPtr->definedMethods & flag) == 0u) {
      /*
       * The method is not defined. It must be called directly.
       */
      /*fprintf(stderr, "Warning: CallDirectly object %s idx %s not defined\n",
        ObjectName(object), Nsf_SystemMethodOpts[methodIdx]+1);*/
    } else {
#if defined(DISPATCH_ALWAYS_DEFINED_METHODS)
      callDirectly = NSF_FALSE;
#else
      if ((object->flags & NSF_FILTER_ORDER_VALID) == 0u) {
        FilterComputeDefined(interp, object);
      }
      /*fprintf(stderr, "CallDirectly object %s idx %s object flags %.6x %.6x \n",
              ObjectName(object), Nsf_SystemMethodOpts[methodIdx]+1,
              (object->flags & NSF_FILTER_ORDER_DEFINED_AND_VALID),
              NSF_FILTER_ORDER_DEFINED_AND_VALID);*/
      if ((object->flags & NSF_FILTER_ORDER_DEFINED_AND_VALID) == NSF_FILTER_ORDER_DEFINED_AND_VALID) {
        /*fprintf(stderr, "CallDirectly object %s idx %s has filter \n",
          ObjectName(object), Nsf_SystemMethodOpts[methodIdx]+1);*/
        callDirectly = NSF_FALSE;
      }
#endif
    }
  }

  /*fprintf(stderr, "CallDirectly object %s idx %d returns %s => %d\n",
          ObjectName(object), methodIdx, (methodObj != NULL) ? ObjStr(methodObj) : "(null)", callDirectly);*/

  *methodObjPtr = methodObj;
  return callDirectly;
}

/*
 *----------------------------------------------------------------------
 * NsfMethodObj --
 *
 *    Returns the method of the given object corresponding to the given index.
 *
 * Results:
 *    A Tcl_Obj* or NULL.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
Tcl_Obj *
NsfMethodObj(const NsfObject *object, int methodIdx) {
  NsfObjectSystem *osPtr = GetObjectSystem(object);

  nonnull_assert(object != NULL);
  /*
  fprintf(stderr, "NsfMethodObj object %s os %p idx %d %s methodObj %p\n",
          ObjectName(object), osPtr, methodIdx,
          Nsf_SystemMethodOpts[methodIdx]+1,
          osPtr->methods[methodIdx]);
  */
  return osPtr->methods[methodIdx];
}


/*
 * Conditional memory allocations of optional storage.
 */


static NsfObjectOpt *
NsfRequireObjectOpt(NsfObject *object) {

  nonnull_assert(object != NULL);

  if (object->opt == NULL) {
    object->opt = NEW(NsfObjectOpt);
    memset(object->opt, 0, sizeof(NsfObjectOpt));
  }
  return object->opt;
}


NsfClassOpt *
NsfRequireClassOpt(NsfClass *class) {

  nonnull_assert(class != NULL);

  if (class->opt == NULL) {
    class->opt = NEW(NsfClassOpt);
    memset(class->opt, 0, sizeof(NsfClassOpt));
    if ((class->object.flags & NSF_IS_CLASS) != 0u) {
      class->opt->id = class->object.id;  /* probably a temporary solution */
    }
  }
  return class->opt;
}


static void MakeObjNamespace(Tcl_Interp *interp, NsfObject *object)
  nonnull(1) nonnull(2);

static void
MakeObjNamespace(Tcl_Interp *interp, NsfObject *object) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

#ifdef NAMESPACE_TRACE
  fprintf(stderr, "+++ MakeObjNamespace for %s\n", ObjectName(object));
#endif
  if (object->nsPtr == NULL) {
    Tcl_Namespace *nsPtr;

    nsPtr = object->nsPtr = NSGetFreshNamespace(interp, object,
                                                ObjStr(object->cmdName));
    assert(nsPtr != NULL);

    /*
     * Copy all obj variables to the new namespace.
     */
    if (object->varTablePtr != NULL) {
      Tcl_HashSearch  search;
      Tcl_HashEntry   *hPtr;
      TclVarHashTable *varTablePtr = Tcl_Namespace_varTablePtr(nsPtr);
      Tcl_HashTable   *varHashTablePtr = TclVarHashTablePtr(varTablePtr);
      Tcl_HashTable   *objHashTablePtr = TclVarHashTablePtr(object->varTablePtr);

      *varHashTablePtr = *objHashTablePtr; /* copy the table */

      if (objHashTablePtr->buckets == objHashTablePtr->staticBuckets) {
        varHashTablePtr->buckets = varHashTablePtr->staticBuckets;
      }
      for (hPtr = Tcl_FirstHashEntry(varHashTablePtr, &search);
           hPtr != NULL;
           hPtr = Tcl_NextHashEntry(&search)) {
        hPtr->tablePtr = varHashTablePtr;
      }
      CallStackReplaceVarTableReferences(interp, object->varTablePtr,
                                         (TclVarHashTable *)varHashTablePtr);

      ckfree((char *) object->varTablePtr);
      object->varTablePtr = NULL;
    }
  }
}

/*
 *----------------------------------------------------------------------
 * CompiledLocalsLookup --
 *
 *    Looks up a variable in the compiled locals, performing a linear search of
 *    an unsorted list maintained by Tcl. Used instead of the rather deprecated
 *    "instvar".
 *
 * Results:
 *    Returns a Tcl_Var or NULL.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static Tcl_Var CompiledLocalsLookup(CallFrame *varFramePtr, const char *varName)
  nonnull(1) nonnull(2);

static Tcl_Var
CompiledLocalsLookup(CallFrame *varFramePtr, const char *varName) {
  int localCt;

  nonnull_assert(varFramePtr != NULL);
  nonnull_assert(varName != NULL);

  localCt = varFramePtr->numCompiledLocals;
  if (localCt > 0) {
    Tcl_Obj  **varNameObjPtr;
    int        i, nameLength;

    varNameObjPtr = &varFramePtr->localCachePtr->varName0;
    nameLength = (int)strlen(varName);

    /* fprintf(stderr, "=== compiled local search #local vars %d for <%s> flags %.8x\n",
       localCt, varName, varFramePtr->isProcCallFrame);
    */

    for (i = 0 ; i < localCt ; i++, varNameObjPtr++) {
      Tcl_Obj *varNameObj = *varNameObjPtr;
      int      len;

      if (likely(varNameObj != NULL)) {
        const char *localName = TclGetStringFromObj(varNameObj, &len);

        /* fprintf(stderr, ".. [%d] varNameObj %p %p <%s>\n",
           i, (void *)varNameObj, (void *)varNameObj->typePtr, localName);
        */

        if (unlikely(varName[0] == localName[0]
                     && varName[1] == localName[1]
                     && len == nameLength
                     && memcmp(varName, localName, (size_t)len) == 0)) {
          return (Tcl_Var) &varFramePtr->compiledLocals[i];
        }
      }
    }
  }
  return NULL;
}


/*
 *----------------------------------------------------------------------
 * CompiledColonLocalsLookupBuildCache --
 *
 *    Looks up the named variable using a sorted cache consisting only of
 *    colon-prefixed variables so that, e.g. non-successful lookup can be
 *    performed in O(n/2), which is is about 4 times faster than
 *    CompiledLocalsLookup().
 *
 * Results:
 *    Tcl_Var or NULL.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static Tcl_Var CompiledColonLocalsLookupBuildCache(CallFrame     *varFramePtr,
                                                   const char    *varName,
                                                   int             nameLength,
                                                   Tcl_Obj       **localNames,
                                                   NsfProcContext *ctxPtr)
  nonnull(1) nonnull(2) nonnull(4) nonnull(5);

static Tcl_Var
CompiledColonLocalsLookupBuildCache(CallFrame *varFramePtr, const char *varName,
                                    int nameLength, Tcl_Obj **localNames,
                                    NsfProcContext *ctxPtr) {
  int       nrColonVars = 0, localCt, i, j;
  Tcl_Var   result;
  Tcl_Obj **varNameObjPtr;

  nonnull_assert(varFramePtr != NULL);
  nonnull_assert(varName != NULL);
  nonnull_assert(localNames != NULL);
  nonnull_assert(ctxPtr != NULL);

  assert(ctxPtr->colonLocalVarCache == NULL);
  assert(varFramePtr->localCachePtr != NULL);

  localCt = varFramePtr->numCompiledLocals;
  varNameObjPtr = &varFramePtr->localCachePtr->varName0;

  /*
   * Count colonVars.
   */
  for (i = 0; i < localCt; i++, varNameObjPtr++) {
    Tcl_Obj *varNameObj = *varNameObjPtr;

    if (varNameObj != NULL) {
      const char *localName = TclGetString(varNameObj);

      if (localName[0] == ':') {
        nrColonVars ++;
      }
    }
  }

  /*fprintf(stderr, ".. build cache #local vars %d for <%s> flags %.8x ctxPtr %p colonvars %d\n",
          localCt, varName, varFramePtr->isProcCallFrame,
          (void *)ctxPtr, nrColonVars
          );*/

  /*
   * Allocate colonLocalVarCache with the proper size, i.e. keeping space for a
   * terminating element.
   */
  ctxPtr->colonLocalVarCache = NEW_ARRAY(int, nrColonVars+1);
  varNameObjPtr = &varFramePtr->localCachePtr->varName0;

  /*
   * Fill colonLocalVarCache, perhaps finding the variable while iterating
   * through the entire list.
   */
  j = 0;
  result = NULL;

  for (i = 0; i < localCt ; i++, varNameObjPtr++) {
    Tcl_Obj *varNameObj = *varNameObjPtr;

    if (varNameObj != NULL) {
      int         len;
      const char *localName = TclGetStringFromObj(varNameObj, &len);

      if (localName[0] == ':') {
        int     k;
        Tcl_Var var = (Tcl_Var) &varFramePtr->compiledLocals[i];

        if (varName[1] == localName[1]
            && len == nameLength
            && memcmp(varName, localName, (size_t)len) == 0) {
          result = var;
        }

        /* fprintf(stderr, ".. insert %s (%d) on pos %d; check j %d entries \n", localName, i, j, j); */
        for (k = 0; k < j; k++) {
          int         idx, cmp;
          const char *cachedName;

          idx = ctxPtr->colonLocalVarCache[k];
          cachedName = TclGetStringFromObj(localNames[idx], &len);
          cmp = strcmp(localName, cachedName);

          /* fprintf(stderr, "... [%d] cmp newVarName <%s> (%d) with cachendName <%s> (%d) => %d\n",
                k, localName, i, cachedName, idx, cmp);
          */
          if (cmp < 0) {
            int ii;

            /*
             * Make space at position k for inserting the new element. Maybe
             * use memmove() instead.
             */
            for (ii = j; ii > k; ii--) {
              ctxPtr->colonLocalVarCache[ii] = ctxPtr->colonLocalVarCache[ii - 1];
            }
            break;
          }
        }
        ctxPtr->colonLocalVarCache[k] = i;

        j++;
        if (j == nrColonVars) {
          break;
        }
      }
    }
  }
  /*
   * -1 terminates the list.
   */
  ctxPtr->colonLocalVarCache[j] = -1;

  /* fprintf(stderr, ".. search #local vars %d varName <%s> colonvars %d found %p\n",
     localCt, varName, nrColonVars, (void*)result);
  */

  return result;
}

/*
 *----------------------------------------------------------------------
 * CompiledColonLocalsLookup --
 *
 *    Looks up a colon-prefixed variable in the compiled locals, using a cache
 *    of colon-prefixed variables to speed up access.
 *
 * Results:
 *    A Tcl_Var or NULL.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static Tcl_Var CompiledColonLocalsLookup(CallFrame *varFramePtr, const char *varName)
  nonnull(1) nonnull(2);

static Tcl_Var
CompiledColonLocalsLookup(CallFrame *varFramePtr, const char *varName) {
  Tcl_Var result;

  nonnull_assert(varFramePtr != NULL);
  nonnull_assert(varName != NULL);

  if (varFramePtr->numCompiledLocals == 0) {
    result = NULL;
  } else {
    Tcl_Obj       **localNames;
    int             nameLength;
    Tcl_Command     cmd;
    NsfProcContext *ctxPtr;

    /*
     * For faster access to local variables, get the string table of the
     * compiled locals and the length of the variable to search for.
     */
    localNames = &varFramePtr->localCachePtr->varName0;
    nameLength = (int)strlen(varName);

    cmd = (Tcl_Command )varFramePtr->procPtr->cmdPtr;
    ctxPtr = ProcContextRequire(cmd);

    /*
     * Build the sorted cache, i.e. colonLocalVarCache if it doesn't already
     * exist, checking at the same time for the named variable.
     */
    if (unlikely(ctxPtr->colonLocalVarCache == NULL)) {
      result = CompiledColonLocalsLookupBuildCache(varFramePtr, varName, nameLength, localNames, ctxPtr);

    } else {
      int i, j;

      /*
       * Search the sorted colonVarCache which, e.g. terminates in O(n/2) time
       * on failures.
       */
      result = NULL;
      for (i = 0, j = ctxPtr->colonLocalVarCache[0]; j > -1; ++i, j = ctxPtr->colonLocalVarCache[i]) {
        int         len;
        const char *localName;

        localName = TclGetStringFromObj(localNames[j], &len);

        /* fprintf(stderr, ".. [%d] varNameObj %p <%s> vs <%s>\n",
           j, (void *)varNameObj, localName, varName); */

        /*
         * Skip the colon.
         */
        if (varName[1] < localName[1]) {
          break;

        } else if (varName[1] == localName[1]) {
          int cmp;
          /*
	   * If the first character matches, compare lengths before calling
	   * compare().
           */
          if (len != nameLength) {
            continue;
          }

          cmp = strcmp(varName, localName);
          if (cmp == 0) {
            result = (Tcl_Var) &varFramePtr->compiledLocals[j];
            break;

          } else if (cmp < 0) {
            /*
             * Variable should have been found by now. Give up.
             */
            break;
          }
        }
      }

#if 0
      if (result != NULL) {
        fprintf(stderr, "... <%s> found -> [%d] %p\n", varName, j, (void *)result);
      }
#endif
    }
  }
  return result;
}


/*
 *----------------------------------------------------------------------
 * GetVarAndNameFromHash --
 *
 *    Use hPtr to retrieve obtain a variable and its name.
 *
 * Results:
 *    Stores a pointer to the variable in **val and a pointer to the name in
 *    **varNameObj.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static void GetVarAndNameFromHash(const Tcl_HashEntry *hPtr, Var **val, Tcl_Obj **varNameObj)
  nonnull(1) nonnull(2) nonnull(3);

static void
GetVarAndNameFromHash(const Tcl_HashEntry *hPtr, Var **val, Tcl_Obj **varNameObj) {

  nonnull_assert(hPtr != NULL);
  nonnull_assert(val != NULL);
  nonnull_assert(varNameObj != NULL);

  *val = TclVarHashGetValue(hPtr);
  *varNameObj = TclVarHashGetKey(*val);
}


/*********************************************************
 *
 * Variable resolvers
 *
 *********************************************************/
#define FOR_COLON_RESOLVER(ptr) (*(ptr) == ':' && *((ptr)+1) != ':')

/*
 *----------------------------------------------------------------------
 * MethodName --
 *
 *    Returns the name the given name, stripping it of the colon prefix if it
 *    has one.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static const char *MethodName(Tcl_Obj *methodObj)
  nonnull(1) returns_nonnull;

static const char *
MethodName(Tcl_Obj *methodObj) {
  const char *methodName;

  nonnull_assert(methodObj != NULL);

  methodName = ObjStr(methodObj);
  if (FOR_COLON_RESOLVER(methodName)) {
    methodName ++;
  }
  return methodName;
}

const char *
NsfMethodName(Tcl_Obj *methodObj) {

  nonnull_assert(methodObj != NULL);

  return MethodName(methodObj);
}

/*
 *----------------------------------------------------------------------
 * NsfMethodNamePath --
 *
 *    Returns the full name of the method from the ensemble root. Useful for
 *    creating error messages.
 *
 * Results:
 *    Tcl_Obj with reference count 0.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
NsfMethodNamePath(Tcl_Interp *interp,
                  Tcl_CallFrame *framePtr,
                  const char *methodName) {

  Tcl_Obj *resultObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(methodName != NULL);

  if (framePtr != NULL) {
    resultObj = CallStackMethodPath(interp, framePtr);
  } else {
    resultObj = Tcl_NewListObj(0, NULL);
  }

  Tcl_ListObjAppendElement(interp, resultObj,
                           Tcl_NewStringObj(methodName, -1));
  return resultObj;
}


/*
 *----------------------------------------------------------------------
 * NsColonVarResolver --
 *
 *    Stores the variable for the given name in *varPtr, correctly handling
 *    colon-prefixed variables.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int NsColonVarResolver(Tcl_Interp *interp, const char *varName, Tcl_Namespace *UNUSED(nsPtr),
                              int flags, Tcl_Var *varPtr)
  nonnull(1) nonnull(2) nonnull(5);

static int
NsColonVarResolver(Tcl_Interp *interp, const char *varName, Tcl_Namespace *UNUSED(nsPtr),
                   int flags, Tcl_Var *varPtr) {
  Tcl_CallFrame *varFramePtr;
  TclVarHashTable *varTablePtr;
  NsfObject *object;
  int new;
  unsigned int frameFlags;
  Tcl_Obj *key;

  nonnull_assert(interp != NULL);
  nonnull_assert(varName != NULL);
  nonnull_assert(varPtr != NULL);

#if defined(VAR_RESOLVER_TRACE)
  fprintf(stderr, "NsColonVarResolver '%s' flags %.6x\n", varName, flags);
#endif

  /*
   * Case 1: The variable is to be resolved in global scope. Pass.
   */
  if (unlikely((flags & TCL_GLOBAL_ONLY) != 0u)) {
    /*fprintf(stderr, "global-scoped lookup for var '%s' in NS '%s'\n", varName,
      nsPtr->fullName);*/
    return TCL_CONTINUE;
  }

  /*
   * Case 2: The variable is to be resolved a proc frame, i.e. compiled locals
   * and the variable hash table.  Pass.
   */
  varFramePtr = (Tcl_CallFrame *)Tcl_Interp_varFramePtr(interp);
  assert(varFramePtr != NULL);

  frameFlags = (unsigned int)Tcl_CallFrame_isProcCallFrame(varFramePtr);
#if defined(VAR_RESOLVER_TRACE)
  fprintf(stderr, "NsColonVarResolver '%s' frame flags %.6x\n", varName,
          Tcl_CallFrame_isProcCallFrame(varFramePtr));
#endif

  if ((frameFlags & FRAME_IS_PROC) != 0u) {
#if defined(VAR_RESOLVER_TRACE)
    fprintf(stderr, "...... forwarding to next resolver\n");
#endif
    /*fprintf(stderr, "proc-scoped var '%s' assumed, frame %p flags %.6x\n",
      name, varFramePtr, Tcl_CallFrame_isProcCallFrame(varFramePtr));*/
    return TCL_CONTINUE;
  }

  /*
   * If FRAME_IS_NSF_CMETHOD then FRAME_IS_PROC also set, which is already
   * handled above.
   */
  assert((frameFlags & FRAME_IS_NSF_CMETHOD) == 0u);

  if ((frameFlags & FRAME_IS_NSF_OBJECT) == 0u) {
    /*
     * Case 3: This is not a Next Scripting frame.  Pass.
     */
    return TCL_CONTINUE;

  } else {
    /*
     *  Case 4: This is a Next Scripting object frame.
     */

    if (*varName == ':') {
      if (*(varName+1) != ':') {
        /*
         * Case 4a: Skip the initial colon.
         */
        varName ++;
      } else {
        /*
         * Case 4b: Name starts with "::". Pass.
         */
        return TCL_CONTINUE;
      }
    } else if (NSTail(varName) != varName) {
      /*
       * Case 4c: Name contains "::".  Pass.
       */
      return TCL_CONTINUE;
    }

    /*
     * This is an object frame.  Get the object from the client data.
     */
    object = (NsfObject *)Tcl_CallFrame_clientData(varFramePtr);
  }

  assert(object != NULL);

  /*
   * Get the corresponding variable table.
   */
  varTablePtr = (object->nsPtr != NULL) ? Tcl_Namespace_varTablePtr(object->nsPtr) : object->varTablePtr;
  assert(varTablePtr != NULL);

  /*
   * Does the variable exist in the namespace of the object?
   */
  key = Tcl_NewStringObj(varName, -1);
  INCR_REF_COUNT(key);

  *varPtr = (Tcl_Var)VarHashCreateVar(varTablePtr, key, NULL);

#if defined(VAR_RESOLVER_TRACE)
  fprintf(stderr, "...... lookup of '%s' for object '%s' returns %p\n",
          varName, ObjectName(object), *varPtr);
#endif
  if (*varPtr == NULL) {
    /*
     * No variable found so far. Create it since the cases above didn't.
     */

    const Var *newVar = VarHashCreateVar(varTablePtr, key, &new);
    *varPtr = (Tcl_Var)newVar;
  }
  DECR_REF_COUNT(key);

  return likely(*varPtr != NULL) ? TCL_OK : TCL_ERROR;
}

/*********************************************************
 *
 * The beginning of the compiled var resolver
 *
 *********************************************************/

typedef struct NsfResolvedVarInfo {
  Tcl_ResolvedVarInfo vInfo;        /* Must be the first member. */
  NsfObject          *lastObject;
  Tcl_Var             var;
  Tcl_Obj            *nameObj;
} NsfResolvedVarInfo;

/*
 *----------------------------------------------------------------------
 * HashVarFree --
 *
 *    Decrements the refCount of the variable, freeing it if it is no longer
 *    referenced.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static void
HashVarFree(Tcl_Var var) {
  if (unlikely(VarHashRefCount(var) < 2)) {
    /*fprintf(stderr, "#### free %p\n", var);*/
    ckfree((char *) var);
  } else {
    VarHashRefCount(var)--;
  }
}

/*
 *----------------------------------------------------------------------
 * CompiledColonVarFetch --
 *
 *    Returns the Var for the given colon-prefixed name, e.g. ":/varName/",
 *    found in a compiled script registered by the compiling variable resolver.
 *    See InterpCompiledColonVarResolver().  iterates through the variable
 *    table of the object during initialization of the call frame, creating the
 *    variable if needed.  Creates a link variable ":/varName/" pointing to
 *    this object variable, i.e., "varName" and stores it in the compiled
 *    locals array of the call frame. These link variables interact with the
 *    family of link-creating commands ([variable], [global], [upvar]) by being
 *    subject to "retargeting" upon name conflicts.  See
 *    tests/varresolutiontest.tcl for some examples.
 *
 * Results:
 *    A Tcl_Var or NULL.
 *
 * Side effects:
 *    Updates the Variable structure cache if necessary.
 *
 *----------------------------------------------------------------------
 */

static Tcl_Var CompiledColonVarFetch(Tcl_Interp *interp, Tcl_ResolvedVarInfo *vinfoPtr)
  nonnull(1) nonnull(2);

static Tcl_Var
CompiledColonVarFetch(Tcl_Interp *interp, Tcl_ResolvedVarInfo *vinfoPtr) {
  NsfResolvedVarInfo  *resVarInfo;
  NsfCallStackContent *cscPtr;
  NsfObject           *object;
  Tcl_Var              var;

  nonnull_assert(interp != NULL);
  nonnull_assert(vinfoPtr != NULL);

  resVarInfo = (NsfResolvedVarInfo *)vinfoPtr;
  var = resVarInfo->var;

#if defined(VAR_RESOLVER_TRACE)
  {
    unsigned int flags = (var != NULL) ? ((Var *)var)->flags : 0u;
    fprintf(stderr, "CompiledColonVarFetch var '%s' var %p flags = %.4x dead? %.4x\n",
            ObjStr(resVarInfo->nameObj), var, flags, flags & VAR_DEAD_HASH);
  }
#endif

  cscPtr = CallStackGetTopFrame0(interp);
  if (likely(cscPtr != NULL)) {
    object = cscPtr->self;
  } else {
    object = NULL;
  }

  /*
   * Cache the resolved variable if it is not in a delete state.
   */
  if ((var != NULL)
      && ((object == resVarInfo->lastObject))
      && (((((Var *)var)->flags) & VAR_DEAD_HASH) == 0u)) {
    /*
     * The variable is valid.
     */
#if defined(VAR_RESOLVER_TRACE)
    fprintf(stderr, ".... cached var '%s' var %p flags = %.4x\n",
            ObjStr(resVarInfo->nameObj), var, ((Var *)var)->flags);
#endif
  } else if (unlikely(object == NULL)) {
    var = NULL;
  } else {
    TclVarHashTable  *varTablePtr;
    int               new;

    if (var != NULL) {
      /*
       * The variable is no-longer valid. Clean it up.
       */
      HashVarFree(var);
    }

    if (object->nsPtr != NULL) {
      varTablePtr = Tcl_Namespace_varTablePtr(object->nsPtr);
    } else if (object->varTablePtr != NULL) {
      varTablePtr = object->varTablePtr;
    } else {
      /*
       * Usually a varTablePtr has now been found, but if, e.g. the "configure"
       * or "objectparameter" methods are redefined, the object might still not
       * have a varTable, which is only created when needed.
       */
      varTablePtr = object->varTablePtr = VarHashTableCreate();
    }
    assert(varTablePtr != NULL);

    resVarInfo->lastObject = object;
#if defined(VAR_RESOLVER_TRACE)
    fprintf(stderr, "Fetch var %s in object %s\n", TclGetString(resVarInfo->nameObj), ObjectName(object));
#endif
    resVarInfo->var = var = (Tcl_Var) VarHashCreateVar(varTablePtr, resVarInfo->nameObj, &new);
    /*
     * Preserve the variable until HashVarFree() is called.
     */
    VarHashRefCount(var)++;
#if defined(VAR_RESOLVER_TRACE)
    {
      const Var *v = (Var *)(resVarInfo->var);
      fprintf(stderr, ".... looked up existing var %s var %p flags = %.6x undefined %d\n",
              ObjStr(resVarInfo->nameObj),
              v, v->flags,
              TclIsVarUndefined(v));
    }
#endif
  }

  return var;
}

/*
 *----------------------------------------------------------------------
 * CompiledColonVarFree --
 *
 *    DeleteProc for the compiled variable handler.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *   Frees the compiled variable structure and decrements the variable name.
 *
 *----------------------------------------------------------------------
 */
static void CompiledColonVarFree(Tcl_ResolvedVarInfo *vInfoPtr)
  nonnull(1);

static void
CompiledColonVarFree(Tcl_ResolvedVarInfo *vInfoPtr) {
  NsfResolvedVarInfo *resVarInfo;

  nonnull_assert(vInfoPtr != NULL);

  resVarInfo = (NsfResolvedVarInfo *)vInfoPtr;
#if defined(VAR_RESOLVER_TRACE)
  fprintf(stderr, "CompiledColonVarFree %p for variable '%s'\n",
          resVarInfo, ObjStr(resVarInfo->nameObj));
#endif

  DECR_REF_COUNT(resVarInfo->nameObj);
  if (resVarInfo->var != NULL) {
    HashVarFree(resVarInfo->var);
  }
  FREE(NsfResolvedVarInfo, vInfoPtr);
}

/*
 *----------------------------------------------------------------------
 * InterpCompiledColonVarResolver --
 *
 *    A custom resolver for colon-prefixed (":/varName/"), for compiling scripts
 *    and for the evalution of the compiled scripts, e.g. proc bodies.  Called
 *    by tclProc.c:InitResolvedLocals() during compilation or recompilation.
 *    Sets a fetch handler and a cleanup handler for each variable in the
 *    script.  The fetch handler called when a Tcl call frame is initialized
 *    and the array of compiled locals is constructed.  See also
 *    InitResolvedLocals()).
 *
 *    According to the Tcl variable resolution protocol, a compiling resolver
 *    for a namespace takes precedence over this compiling resolver for the
 *    interp:  Per-namespace resolvers are processed first and override the
 *    resolver for the interp by returning TCL_OK or TCL_BREAK.
 *
 * Results:
 *    TCL_OK or TCL_CONTINUE, as per Tcl's var resolution protocol.
 *
 * Side effects:
 *    Sets per-variable resolution and cleanup handlers.
 *
 *----------------------------------------------------------------------
 */
static int InterpCompiledColonVarResolver(Tcl_Interp *interp, const char *name, int length,
                                          Tcl_Namespace *UNUSED(context), Tcl_ResolvedVarInfo **rPtr)
  nonnull(1) nonnull(2) nonnull(5);

static int
InterpCompiledColonVarResolver(Tcl_Interp *interp,
                               const char *name, int length, Tcl_Namespace *UNUSED(context),
                               Tcl_ResolvedVarInfo **rPtr) {
  /*
   *  Set the variable if there is a an active Next Scripting object and the
   *  variable starts with the appropriate prefix. Getting the "self" object
   *  provides some protection against handling of wrong vars.
   */
  NsfObject *object;

  nonnull_assert(interp != NULL);
  nonnull_assert(name != NULL);
  nonnull_assert(rPtr != NULL);

  object = GetSelfObj(interp);
#if defined(VAR_RESOLVER_TRACE)
  fprintf(stderr, "compiled var resolver for %s, obj %p\n", name, object);
#endif

  if (likely(object != NULL) && FOR_COLON_RESOLVER(name)) {
    NsfResolvedVarInfo *resVarInfo = NEW(NsfResolvedVarInfo);

    resVarInfo->vInfo.fetchProc = CompiledColonVarFetch;
    resVarInfo->vInfo.deleteProc = CompiledColonVarFree; /* if NULL, Tcl does a ckfree on proc cleanup */
    resVarInfo->lastObject = NULL;
    resVarInfo->var = NULL;
    resVarInfo->nameObj = Tcl_NewStringObj(name+1, length-1);
    INCR_REF_COUNT(resVarInfo->nameObj);

#if defined(VAR_RESOLVER_TRACE)
    fprintf(stderr, "... resVarInfo %p nameObj %p '%s' obj %p %s\n",
            resVarInfo, resVarInfo->nameObj, ObjStr(resVarInfo->nameObj),
            object, ObjectName(object));
#endif

    *rPtr = (Tcl_ResolvedVarInfo *)resVarInfo;

    return TCL_OK;
  }
  return TCL_CONTINUE;
}

/*
 *----------------------------------------------------------------------
 * InterpGetFrameAndFlags --
 *
 *    Returns the flags for the current call frame and stores a pointer to that
 *    frame in framePtr, skipping the op level if it is a lambda frame.
 *
 * Results:
 *    Frame flags.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

NSF_INLINE static int InterpGetFrameAndFlags(Tcl_Interp *interp, CallFrame **framePtr)
  nonnull(1) nonnull(2);

NSF_INLINE static int
InterpGetFrameAndFlags(Tcl_Interp *interp, CallFrame **framePtr) {
  int frameFlags;

  nonnull_assert(interp != NULL);
  nonnull_assert(framePtr != NULL);

  *framePtr = Tcl_Interp_varFramePtr(interp);
  frameFlags = Tcl_CallFrame_isProcCallFrame(*framePtr);
  /*
   * If the resolver is called from a lambda frame, use always the parent frame
   */
  if ((frameFlags & FRAME_IS_LAMBDA) != 0u) {
    *framePtr = (CallFrame *)Tcl_CallFrame_callerPtr(*framePtr);
    frameFlags = Tcl_CallFrame_isProcCallFrame(*framePtr);
#if defined(VAR_RESOLVER_TRACE)
    fprintf(stderr, "InterpColonVarResolver skip lambda frame flags %.6x\n",
            Tcl_CallFrame_isProcCallFrame(*framePtr));
#endif
  }
#if defined(VAR_RESOLVER_TRACE)
  fprintf(stderr, "... final frame flags %.6x\n", frameFlags);
#endif
  return frameFlags;
}

/*
 *----------------------------------------------------------------------
 * InterpColonVarResolver --
 *
 *    The non-compiling companion to InterpCompiledColonVarResolver().
 *    Resolves a variable name prefixed by a colon, e.g ":/varName/".  Used
 *    when evaluating non-compiled statements and when a byte-coded procedure
 *    does not make use of the compiled locals array, instead reverting, e.g.
 *    to TclObjLookupVar*().
 *
 *    According to the Tcl variable resolution protocol namespace variable
 *    resolvers take precedence over this interp variable resolver:
 *    Per-namespace resolvers are processed first and can override the interp
 *    resolver by returning TCL_OK or TCL_BREAK. See e.g.
 *    TclLookupSimpleVar().
 *
 * Results:
 *    TCL_OK or TCL_CONTINUE, in accordance with the Tcl variable resolution
 *    protocol.
 *
 * Side effects:
 *    Stores a pointer in varPtr on success.
 *
 *----------------------------------------------------------------------
 */

static int InterpColonVarResolver(Tcl_Interp *interp, const char *varName, Tcl_Namespace *UNUSED(nsPtr),
                                  int flags, Tcl_Var *varPtr)
  nonnull(1) nonnull(2) nonnull(5);

static int
InterpColonVarResolver(Tcl_Interp *interp, const char *varName, Tcl_Namespace *UNUSED(nsPtr),
                       int flags, Tcl_Var *varPtr) {
  int              new;
  unsigned int     frameFlags;
  CallFrame       *varFramePtr;
  TclVarHashTable *varTablePtr;
  NsfObject       *object;
  Tcl_Obj         *keyObj;
  Tcl_Var          var;

  nonnull_assert(interp != NULL);
  nonnull_assert(varName != NULL);
  nonnull_assert(varPtr != NULL);

  if (!FOR_COLON_RESOLVER(varName) || (flags & (TCL_NAMESPACE_ONLY)) != 0u) {
    /*
     * Skip names not starting with the special prefix, and also namespace-only
     * lookups.  Don't skip TCL_GLOBAL_ONLY lookups so that "vwait :varName"
     * works.
     */
#if defined(VAR_RESOLVER_TRACE)
    fprintf(stderr, "InterpColonVarResolver '%s' flags %.6x not for us\n",
            varName, flags);
#endif
    return TCL_CONTINUE;
  }

  frameFlags = (unsigned int)InterpGetFrameAndFlags(interp, &varFramePtr);

  if (likely((frameFlags & FRAME_IS_NSF_METHOD) != 0u)) {
    /* varPtr = CompiledLocalsLookup(varFramePtr, varName);
       fprintf(stderr, "CompiledLocalsLookup for %p %s returned %p\n", varFramePtr, varName, *varPtr);
    */
    if ((*varPtr = CompiledColonLocalsLookup(varFramePtr, varName))) {
      /*
       * Looking up the compiled-local directly and returning TCL_OK is an
       * optimisation which avoids further lookup by Tcl.  Returning
       * TCL_CONTINUE would work too, but it would involve extra resolution
       * overhead.

       * This point of interaction between the custom resolvers for the
       * non-compiled InterpColonVarResolver() and the compiled
       * InterpCompiledColonVarResolver() script execution is reached iff:
       *
       * 1. The Tcl bytecode interpreter executes, i.e. TclObjLookupVarEx(),
       * leading to a call to  InterpCompiledColonVarResolver().
       *
       * 2. The variable resolution is not restricted by TCL_NAMESPACE_ONLY.
       *
       * 3. During bytecode interpretation when tclProc.c:InitResolvedLocals()
       * initializes the call frame CompiledColonVarFetch() stores into the
       * call frame's array of compiled locals a link variable, which points
       * actual/real object variable, whether defined or not.
       */
#if defined(VAR_RESOLVER_TRACE)
      fprintf(stderr, ".... found local %s varPtr %p flags %.6x\n",
              varName, *varPtr, flags);
#endif
      return TCL_OK;
    }

    object = ((NsfCallStackContent *)varFramePtr->clientData)->self;

  } else if ((frameFlags & FRAME_IS_NSF_CMETHOD) != 0u) {
    object = ((NsfCallStackContent *)varFramePtr->clientData)->self;

  } else if ((frameFlags & FRAME_IS_NSF_OBJECT) != 0u) {
    object = (NsfObject *)(varFramePtr->clientData);

  } else {
#if defined(VAR_RESOLVER_TRACE)
    fprintf(stderr, ".... not found %s\n", varName);
#endif
    return TCL_CONTINUE;
  }

  /*
   * Trim the colon prefix (":") from varName.
   */
  varName ++;

  assert(object != NULL);

  if (unlikely(object->nsPtr != NULL)) {
    varTablePtr = Tcl_Namespace_varTablePtr(object->nsPtr);
  } else if (likely(object->varTablePtr != NULL)) {
    varTablePtr = object->varTablePtr;
  } else {
    /*
     * In most cases a varTablePtr has already been obtained above, but if
     * "configure" or "objectparameter" are redefined there might not yet be a
     * varTable since it is only created when needed.
     */
    varTablePtr = object->varTablePtr = VarHashTableCreate();
  }
  assert(varTablePtr != NULL);

  /*fprintf(stderr, "Object Var Resolver, name=%s, obj %p, nsPtr %p, varTablePtr %p\n",
    varName, object, object->nsPtr, varTablePtr);*/

  keyObj = Tcl_NewStringObj(varName, -1);
  INCR_REF_COUNT(keyObj);

  var = (Tcl_Var)VarHashCreateVar(varTablePtr, keyObj, NULL);
  if (likely(var != NULL)) {
#if defined(VAR_RESOLVER_TRACE)
    fprintf(stderr, ".... found in hash-table %s %p flags %.6x ns %p\n",
            varName, var, ((Var *)var)->flags,  object->nsPtr);
#endif
    /*
     * Facilitate coverage analysis.
     */
    assert(1);
  } else {
    /*
     * No variable found. Create it.
     */
    var = (Tcl_Var)VarHashCreateVar(varTablePtr, keyObj, &new);
#if defined(VAR_RESOLVER_TRACE)
    fprintf(stderr, ".... var %p %s created in hash-table %p\n", var, varName, varTablePtr);
#endif
  }

  *varPtr = var;
  DECR_REF_COUNT(keyObj);

  return TCL_OK;
}

/*********************************************************
 *
 * End of var resolvers
 *
 *********************************************************/

/*********************************************************
 *
 * Beginning of cmd resolver
 *
 *********************************************************/
/*
 *----------------------------------------------------------------------
 * InterpColonCmdResolver --
 *
 *    Stores in cmdPtr the command corresponding to the given name, treating
 *    the name as a method if it starts with the Next-Scripting-specific prefix
 *    and this is a Next Scripting call frame.
 *
 * Results:
 *    TCL_OK or TCL_CONTINUE.
 *
 * Side effects:
 *   See description.
 *
 *----------------------------------------------------------------------
 */
static int InterpColonCmdResolver(Tcl_Interp *interp, const char *cmdName, Tcl_Namespace *UNUSED(nsPtr),
                                  unsigned int flags, Tcl_Command *cmdPtr)
  nonnull(1) nonnull(2) nonnull(5);

static int
InterpColonCmdResolver(Tcl_Interp *interp, const char *cmdName, Tcl_Namespace *UNUSED(nsPtr),
                       unsigned int flags, Tcl_Command *cmdPtr) {
  CallFrame   *varFramePtr;
  unsigned int frameFlags;

  nonnull_assert(interp != NULL);
  nonnull_assert(cmdName != NULL);
  nonnull_assert(cmdPtr != NULL);

  /* fprintf(stderr, "InterpColonCmdResolver %s flags %.6x\n", cmdName, flags); */

  if (likely((*cmdName == ':' && *(cmdName + 1) == ':') || (flags & TCL_GLOBAL_ONLY) != 0u)) {
    /* fully-qualified names and global lookups are not for us */
    /*fprintf(stderr, "... not for us %s flags %.6x\n", cmdName, flags);*/
    return TCL_CONTINUE;
  }
  frameFlags = (unsigned int)InterpGetFrameAndFlags(interp, &varFramePtr);

  /*
   * This routine is also called when the body of a method is compiled.  In
   * these situations, skip the non-proc frame that Tcl has pushed.  Set the
   * NSF_CSC_CALL_IS_COMPILE flag in the call frame to identify this condition.
   */
  if ((frameFlags == 0u) && (Tcl_CallFrame_callerPtr(varFramePtr) != NULL)) {
    ClientData clientData;

    varFramePtr = (CallFrame *)Tcl_CallFrame_callerPtr(varFramePtr);
    frameFlags = (unsigned int)Tcl_CallFrame_isProcCallFrame(varFramePtr);
    clientData = varFramePtr->clientData;

    if ( (frameFlags != 0u)
         && (clientData != NULL)
         && ((((NsfCallStackContent *)clientData)->flags & NSF_CSC_CALL_IS_COMPILE) == 0u)
         ) {
      frameFlags = 0u;
    } else {
#if defined(CMD_RESOLVER_TRACE)
      fprintf(stderr, "InterpColonCmdResolver got parent frame cmdName %s flags %.6x, frame flags %.6x\n",
              cmdName, flags, Tcl_CallFrame_isProcCallFrame(varFramePtr));
#endif
    }
 }

#if defined(CMD_RESOLVER_TRACE)
  fprintf(stderr, "InterpColonCmdResolver cmdName %s flags %.6x, frame flags %.6x\n",
          cmdName, flags, frameFlags);
#endif

  if ((frameFlags & (FRAME_IS_NSF_METHOD|FRAME_IS_NSF_OBJECT|FRAME_IS_NSF_CMETHOD)) != 0u) {
    if (*cmdName == ':') {
#if defined(CMD_RESOLVER_TRACE)
      fprintf(stderr, "    ... call colonCmd for %s\n", cmdName);
#endif
      /*
       * This is an Nsf frame. Forward this colon-prefixed command to colonCmd.
       */
      *cmdPtr = RUNTIME_STATE(interp)->colonCmd;

      return TCL_OK;
    } else {

#if defined(NSF_WITH_OS_RESOLVER)
      /*
       * Experimental Object-System-specific resolver: If a method name with no
       * prefix is found in the body of a method, try to resolve it in the
       * namespace of the object system for the current object. If not
       * successful, perform the standard lookups. This makes it possible to
       * use the "right" (un-prefixed) "self" or "next" calls without namespace
       * imports.
       */
      NsfObject *object;
      NsfObjectSystem *osPtr;

      if ((frameFlags & (FRAME_IS_NSF_METHOD|FRAME_IS_NSF_CMETHOD)) != 0u) {
        const NsfCallStackContent *cscPtr = (NsfCallStackContent *)varFramePtr->clientData;
        assert(cscPtr != NULL);
        object = cscPtr->self;
      } else if ((frameFlags & (FRAME_IS_NSF_OBJECT)) != 0u) {
        object = (NsfObject *)(varFramePtr->clientData);
      } else {
        object = NULL;
      }

      if (object != NULL) {
        Tcl_HashEntry *entryPtr;
        Tcl_HashTable *cmdTablePtr;
        Tcl_Command cmd;

        osPtr = GetObjectSystem(object);
        cmd = osPtr->rootClass->object.id;
        cmdTablePtr = Tcl_Namespace_cmdTablePtr(((Command *)cmd)->nsPtr);
        entryPtr = Tcl_CreateHashEntry(cmdTablePtr, cmdName, NULL);
        /*fprintf(stderr, "InterpColonCmdResolver OS specific resolver tried to lookup %s for os %s in ns %s\n",
          cmdName, ClassName(osPtr->rootClass), ((Command *)cmd)->nsPtr->fullName);*/

        if (entryPtr != NULL) {
          /*fprintf(stderr, "InterpColonCmdResolver OS specific resolver found %s::%s frameFlags %.6x\n",
            ((Command *)cmd)->nsPtr->fullName, cmdName, frameFlags);*/
          *cmdPtr = Tcl_GetHashValue(entryPtr);

          return TCL_OK;
        }
      }
#endif
    }
  }

#if defined(CMD_RESOLVER_TRACE)
  fprintf(stderr, "    ... not found %s\n", cmdName);
  NsfShowStack(interp);
#endif

  return TCL_CONTINUE;
}
/*********************************************************
 *
 * End of cmd resolver
 *
 *********************************************************/


/*
 *----------------------------------------------------------------------
 * NsfNamespaceInit --
 *
 *    Initializes the given namespace by setting its resolvers and path.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static void NsfNamespaceInit(Tcl_Namespace *nsPtr)
  nonnull(1);

static void
NsfNamespaceInit(Tcl_Namespace *nsPtr) {

  nonnull_assert(nsPtr != NULL);

  /*
   * Set the resolver for objects on acquiring the namespace. Works for
   * object-scoped commands/procs and object-only ones, e.g. set, unset, etc.
   */
  Tcl_SetNamespaceResolvers(nsPtr,
                            (Tcl_ResolveCmdProc *)NULL,
                            NsColonVarResolver,
                            (Tcl_ResolveCompiledVarProc *)NULL);

#if defined(NSF_WITH_INHERIT_NAMESPACES)
  /*
   * If there is a namespace path set for the parent namespace,
   * apply it to the object namespace as well to avoid surprises
   * with "namespace path nx".
   */
  { Namespace *parentNsPtr = Tcl_Namespace_parentPtr(nsPtr);
    int pathLength = Tcl_Namespace_commandPathLength(parentNsPtr);

    if (pathLength > 0) {
      Namespace **pathArray = (Namespace **)ckalloc((int)sizeof(Namespace *) * pathLength);
      NamespacePathEntry *tmpPathArray = Tcl_Namespace_commandPathArray(parentNsPtr);
      int i;

      for (i = 0; i < pathLength; i++) {
        pathArray[i] = tmpPathArray[i].nsPtr;
      }
      TclSetNsPath((Namespace *)nsPtr, pathLength, (Tcl_Namespace **)pathArray);
      ckfree((char *)pathArray);
    }
  }
#endif
}

static NsfObject *NSNamespaceClientDataObject(ClientData clientData) nonnull(1) NSF_pure;

static NsfObject *
NSNamespaceClientDataObject(ClientData clientData) {
#ifdef NSF_MEM_COUNT
  NsfNamespaceClientData *nsClientData = (NsfNamespaceClientData *)clientData;

  nonnull_assert(clientData != NULL);

  /*fprintf(stderr, "NSNamespaceDeleteProc cd %p\n", clientData);
    fprintf(stderr, "... nsPtr %p name '%s'\n", nsClientData->nsPtr, nsClientData->nsPtr->fullName);*/

  return nsClientData->object;
#else
  nonnull_assert(clientData != NULL);
  return (NsfObject *) clientData;
#endif
}


/*
 *----------------------------------------------------------------------
 * SlotContainerCmdResolver --
 *
 *    A specialized command resolver for a slot container.  Avoids the lookup
 *    of childobjs for unqualified calls, and should be registered for a
 *    namespace. This way it is possible, e.g. to call a method [list] from a
 *    slot-obj, even when a property named "list" is defined.
 *
 * Results:
 *    Either TCL_CONTINUE or TCL_OK.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static int SlotContainerCmdResolver(Tcl_Interp *interp, const char *cmdName,
                         Tcl_Namespace *nsPtr, unsigned int flags, Tcl_Command *cmdPtr)
  nonnull(1) nonnull(2) nonnull(3) nonnull(5);

static int
SlotContainerCmdResolver(Tcl_Interp *interp, const char *cmdName,
                         Tcl_Namespace *nsPtr, unsigned int flags, Tcl_Command *cmdPtr) {

  nonnull_assert(cmdName != NULL);
  nonnull_assert(nsPtr != NULL);
  nonnull_assert(cmdPtr != NULL);

  if (*cmdName == ':' || ((flags & TCL_GLOBAL_ONLY) != 0u)) {
    /*
     * Skip global lookups and names beginning with a colon (InterpColonCmdResolver).
     */
    return TCL_CONTINUE;
  }

  /*fprintf(stderr, "SlotContainerCmdResolver called with %s ns %s ourNs %d clientData %p\n",
          cmdName, nsPtr->fullName, nsPtr->deleteProc == NSNamespaceDeleteProc,
          nsPtr->clientData);*/

  /*
   * Is this already a namespace handled by Nsf?
   */
  if (nsPtr->deleteProc == NSNamespaceDeleteProc && nsPtr->clientData) {
    NsfObject *parentObject = NSNamespaceClientDataObject(nsPtr->clientData);

    /*fprintf(stderr, "SlotContainerCmdResolver parentObject %p %s\n",
      parentObject, ObjectName(parentObject));*/
    /*
     * Perform a global lookup if the parent is a slot container.
     */
    /* parentObject = (NsfObject *) GetObjectFromString(interp, nsPtr->fullName);*/
    if ((parentObject->flags & NSF_IS_SLOT_CONTAINER) != 0u) {
      Tcl_Command cmd = Tcl_FindCommand(interp, cmdName, NULL, TCL_GLOBAL_ONLY);

      if (likely(cmd != NULL)) {
        *cmdPtr = cmd;
        return TCL_OK;
      }
    }
  }

  return TCL_CONTINUE;
 }

/*
 *----------------------------------------------------------------------
 * RequireObjNamespace --
 *
 *    Returns the namespace for the given object, creating and initializing the
 *    namespace if necessary and copying any existing variables of the object
 *    into it.
 *
 * Results:
 *    A pointer to a Tcl_Namespace.
 *
 * Side effects:
 *    May allocate a Tcl_Namespace.
 *
 *----------------------------------------------------------------------
 */

static Tcl_Namespace *
RequireObjNamespace(Tcl_Interp *interp, NsfObject *object) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  if (object->nsPtr == NULL) {
    MakeObjNamespace(interp, object);
    NsfNamespaceInit(object->nsPtr);
  }
  assert(object->nsPtr != NULL);

  return object->nsPtr;
}

/*
 * Namespace related commands
 */
/*
 *----------------------------------------------------------------------
 * NSNamespacePreserve --
 *
 *    Increments the refCount of the given namespace.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static void
NSNamespacePreserve(Tcl_Namespace *nsPtr) {

  nonnull_assert(nsPtr != NULL);

  MEM_COUNT_ALLOC("NSNamespace", nsPtr);
  Tcl_Namespace_refCount(nsPtr)++;
}
/*
 *----------------------------------------------------------------------
 * NSNamespaceRelease --
 *
 *    Decrements the refCount of the namespace, freeing it if possible.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    May free memory.
 *
 *----------------------------------------------------------------------
 */
static void
NSNamespaceRelease(Tcl_Namespace *nsPtr) {

  nonnull_assert(nsPtr != NULL);

  MEM_COUNT_FREE("NSNamespace", nsPtr);
  Tcl_Namespace_refCount(nsPtr)--;
  if (unlikely(Tcl_Namespace_refCount(nsPtr) == 0 && (Tcl_Namespace_flags(nsPtr) & NS_DEAD))) {
    /*
     * The namespace "refCount" has reached 0 and must be freed.
     * Unfortunately, NamespaceFree() is not exported.
     */
    /*fprintf(stderr, "HAVE TO FREE namespace %p\n", nsPtr); */

    /*NamespaceFree(nsPtr);*/
    ckfree(nsPtr->fullName);
    ckfree(nsPtr->name);
    ckfree((char *)nsPtr);
  }
}

/*
 *----------------------------------------------------------------------
 * NSDeleteCmd --
 *
 *    Deletes the Tcl command in the given namespace for the named method.
 *
 * Results:
 *    A Tcl return code or -1 if there is no such method.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static int
NSDeleteCmd(Tcl_Interp *interp, Tcl_Namespace *nsPtr, const char *methodName) {
  Tcl_Command token;

  nonnull_assert(interp != NULL);
  nonnull_assert(nsPtr != NULL);
  nonnull_assert(methodName != NULL);

  if ((token = FindMethod(nsPtr, methodName))) {
    return Tcl_DeleteCommandFromToken(interp, token);
  }
  return -1;
}


/*
 *----------------------------------------------------------------------
 * NSDeleteChild --
 *
 *    Deletes a child of an object if the object is deleted.  Designed to
 *    delete either objects or classes and to be a more graceful with
 *    destructors. Not perfect yet.
 *
 * Results:
 *    True on success.
 *
 * Side effects:
 *    Might destroy an object.
 *
 *----------------------------------------------------------------------
 */
static bool NSDeleteChild(Tcl_Interp *interp, Tcl_Command cmd, bool deleteObjectsOnly)
  nonnull(1) nonnull(2);

static bool
NSDeleteChild(Tcl_Interp *interp, Tcl_Command cmd, bool deleteObjectsOnly) {
  bool deleted;

  nonnull_assert(cmd != NULL);
  nonnull_assert(interp != NULL);

  /*fprintf(stderr, "NSDeleteChildren child %p flags %.6x epoch %d\n",
    (void *)cmd, Tcl_Command_flags(cmd), Tcl_Command_cmdEpoch(cmd));*/

  /*
   * In some situations, e.g. small buckets, i.e. less than 12 entries, there
   * may be deleted commands in the cmd table.  There was previously an
   * assert(Tcl_Command_cmdEpoch(cmd) == 0); which fails in such cases.
   */

  if (Tcl_Command_cmdEpoch(cmd) != 0) {
    deleted = NSF_FALSE;

  } else {
    NsfObject *object = NsfGetObjectFromCmdPtr(cmd);

    /*fprintf(stderr, "NSDeleteChildren child %p (%s) epoch %d\n",
      (void *)cmd, Tcl_GetCommandName(interp, cmd), Tcl_Command_cmdEpoch(cmd));*/

    if (object == NULL) {
      /*
       * This is a plain Tcl command. Let Tcl delete it.
       */
      deleted = NSF_FALSE;

    } else if (object->id == cmd) {
      /*
       * This is the correct object.
       */

      if (deleteObjectsOnly && NsfObjectIsClass(object)) {
        deleted = NSF_FALSE;

      } else if (RUNTIME_STATE(interp)->exitHandlerDestroyRound
          == NSF_EXITHANDLER_ON_PHYSICAL_DESTROY) {
        /*
         * Call destroy directly since the interpreter is exiting.
         */
        PrimitiveDestroy(object);
        deleted = NSF_TRUE;

      } else {
        if (object->teardown && ((object->flags & NSF_DESTROY_CALLED) == 0u)) {
          int result;

          NsfObjectRefCountIncr(object);

          result = DispatchDestroyMethod(interp, object, 0u);
          if (unlikely(result != TCL_OK) && object->teardown != NULL) {
            /*
             * The destroy method failed but remove the command anyway since
             * its parent is being deleted.
             */
            /*fprintf(stderr, "==== NSDeleteChild DispatchDestroyMethod FAILED object %p (cmd %p) id %p teardown %p flags %.6x\n",
              (void *)object, (void *)cmd, (void *)object->id, (void *)object->teardown, object->flags);*/

            NsfLog(interp, NSF_LOG_NOTICE, "Destroy failed for object %s %p %.6x, perform low-level deletion",
                   (object->flags & NSF_DURING_DELETE) == NSF_DURING_DELETE ? "deleted-object" : ObjectName_(object),
                   (void*)object, object->flags);
            CallStackDestroyObject(interp, object);
          }
          NsfCleanupObject(object, "NSDeleteChild");

          deleted = NSF_TRUE;
        } else {
          deleted = NSF_FALSE;
        }
      }
    } else {
      /*fprintf(stderr, "NSDeleteChild remove alias %p %s\n", (void*)object, Tcl_GetCommandName(interp, cmd));*/
      deleted = AliasDeleteObjectReference(interp, cmd);
    }
  }
  return deleted;
}

/*
 *----------------------------------------------------------------------
 * NSDeleteChildren --
 *
 *    Delete the child objects of a namespace.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Might destroy child objects.
 *
 *----------------------------------------------------------------------
 */

static void NSDeleteChildren(Tcl_Interp *interp, const Tcl_Namespace *nsPtr)
  nonnull(1) nonnull(2);

static void
NSDeleteChildren(Tcl_Interp *interp, const Tcl_Namespace *nsPtr) {
  Tcl_HashTable       *cmdTablePtr = Tcl_Namespace_cmdTablePtr(nsPtr);
  Tcl_HashSearch       hSrch;
  const Tcl_HashEntry *hPtr;
  int                  expected;

  nonnull_assert(interp != NULL);
  nonnull_assert(nsPtr != NULL);

#ifdef OBJDELETION_TRACE
  fprintf(stderr, "NSDeleteChildren %p %s activationCount %d\n",
          nsPtr, nsPtr->fullName, Tcl_Namespace_activationCount(nsPtr));
#endif

  /*
   * First, get rid of namespace imported objects; don't delete the
   * object, but the reference.
   */
  Tcl_ForgetImport(interp, (Tcl_Namespace*)nsPtr, "*"); /* don't destroy namespace imported objects */


#if defined(OBJDELETION_TRACE)
  /*
   * Deletion is always tricky. Report the commands that willshould be deleted
   * in this loop.  Fewer elements might actually be deleted if a deletion of
   * one item triggers the deletion of another item.
   */
  for (hPtr = Tcl_FirstHashEntry(cmdTablePtr, &hSrch);
       hPtr != NULL;
       hPtr = Tcl_NextHashEntry(&hSrch)) {
    Tcl_Command cmd = (Tcl_Command)Tcl_GetHashValue(hPtr);
    fprintf(stderr, "will destroy %p %s\n", cmd, Tcl_GetCommandName(interp, cmd));
  }
#endif

  /*
   * Second, delete the objects.
   */

  /*
   * Destruction of one element of the hash table can trigger the destruction
   * of another item of the same table. Therefore, use Nsf_NextHashEntry().
   */
  for (hPtr = Tcl_FirstHashEntry(cmdTablePtr, &hSrch);
       hPtr != NULL;
       hPtr = Nsf_NextHashEntry(cmdTablePtr, expected, &hSrch)) {
    /*Tcl_Command cmd = (Tcl_Command)Tcl_GetHashValue(hPtr);
    fprintf(stderr, "NSDeleteChild %p table %p numEntries before %d\n",
    cmd, hPtr->tablePtr, cmdTablePtr->numEntries );*/
    expected = (NSDeleteChild(interp, (Tcl_Command)Tcl_GetHashValue(hPtr), NSF_TRUE)
                ? cmdTablePtr->numEntries - 1
                : cmdTablePtr->numEntries);
  }
 /*
  * Delete the classes.
   */
  for (hPtr = Tcl_FirstHashEntry(cmdTablePtr, &hSrch);
       hPtr != NULL;
       hPtr = Nsf_NextHashEntry(cmdTablePtr, expected, &hSrch)) {
    expected = (NSDeleteChild(interp, (Tcl_Command)Tcl_GetHashValue(hPtr), NSF_FALSE)
                ? cmdTablePtr->numEntries - 1
                : cmdTablePtr->numEntries);
  }
}


/*
 *----------------------------------------------------------------------
 * UnsetTracedVars --
 *
 *   Because an unset trace might bring back the variable currently being
 *   deleted, attempts to unset each traced variable of the given object before
 *   TclDeleteVars() performs a second pass.  A single pass risks leaving such
 *   a resurrected var in place.  TclDeleteVars() requires a variable being
 *   deleted to be untraced.
 *
 *   Since Tcl does not provide access to the necessary lower-level Var API to
 *   extensions, i.e. TclDeleteNamespaceVars or TclPtrUnsetVar, resort to a mix
 *   of navigating the variable table and calling higher-level unset
 *   operations, e.g.  UnsetInstVar.
 *
 *   With the fix for the https://core.tcl-lang.org/tcl/info/4dbdd9af1439d874,
 *   Tcl itself provides for two deletion passes for namespace variables.  See
 *   TclDeleteNamespaceVars.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Triggers unset traces, if any.
 *
 *----------------------------------------------------------------------
 */

static void UnsetTracedVars(Tcl_Interp *interp, NsfObject *object)
  nonnull(1) nonnull(2);

static void
UnsetTracedVars(
    Tcl_Interp *interp,  /* Interpreter to which object belongs. */
    NsfObject *object)   /* Object to which variables belong. */
{
    Tcl_HashSearch search;
    TclVarHashTable *varTablePtr;
    Interp *iPtr = (Interp *)interp;

    varTablePtr = (object->nsPtr != NULL) ?
      Tcl_Namespace_varTablePtr(object->nsPtr) :
      object->varTablePtr;

    if (varTablePtr != NULL) {
      Tcl_HashEntry *entryPtr;

      for (entryPtr = Tcl_FirstHashEntry((Tcl_HashTable *)varTablePtr, &search);
           entryPtr != NULL;
           entryPtr = Tcl_NextHashEntry(&search)) {
        Tcl_Obj *nameObj;
        Var     *varPtr;

        GetVarAndNameFromHash(entryPtr, &varPtr, &nameObj);
        if ((varPtr->flags & VAR_TRACED_UNSET) != 0u /* TclIsVarTraced(varPtr) */) {

          VarHashRefCount(varPtr)++;
          (void)UnsetInstVar(interp, 1 /* no error msg */, object, ObjStr(nameObj));

          /*
           * The variable might have been resurrected an unset trace, and there
           * may be newly-created unset traces.  Deactivate all traces on the
           * variable.
           */
          if (TclIsVarTraced(varPtr)) {
            Tcl_HashEntry *tPtr = Tcl_FindHashEntry(&iPtr->varTraces, (const char *)varPtr);
            VarTrace *tracePtr = Tcl_GetHashValue(tPtr);
            ActiveVarTrace *activePtr;

            while (tracePtr != NULL) {
              VarTrace *prevPtr = tracePtr;

              tracePtr = tracePtr->nextPtr;
              prevPtr->nextPtr = NULL;
              Tcl_EventuallyFree(prevPtr, TCL_DYNAMIC);
            }
            Tcl_DeleteHashEntry(tPtr);
            varPtr->flags &= ~VAR_ALL_TRACES;
            for (activePtr = iPtr->activeVarTracePtr; activePtr != NULL;
                 activePtr = activePtr->nextPtr) {
              if (activePtr->varPtr == varPtr) {
                activePtr->nextTracePtr = NULL;
              }
            }
          }
          VarHashRefCount(varPtr)--;
        }
      }
    }
}

/*
 *----------------------------------------------------------------------
 * NSCleanupNamespace --
 *
 *   Cleans up an object/class namespace by its variables, resetting the
 *   variable table and deleting user-defined namespace procs.
 *
 *   For a namespace holding variables with possible unset traces, call
 *   UnsetTracedVars just before NSCleanupNamespace().
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Reinitializes the variable table of the cleaned-up namespace, i.e.
 *    TclInitVarHashTable().
 *
 *----------------------------------------------------------------------
 */

static void NSCleanupNamespace(Tcl_Interp *interp, Tcl_Namespace *nsPtr)
  nonnull(1) nonnull(2);

static void
NSCleanupNamespace(Tcl_Interp *interp, Tcl_Namespace *nsPtr) {
  TclVarHashTable *varTablePtr;
  Tcl_HashTable *cmdTablePtr;
  Tcl_HashSearch hSrch;
  const Tcl_HashEntry *hPtr;

  nonnull_assert(interp != NULL);
  nonnull_assert(nsPtr != NULL);

  varTablePtr = Tcl_Namespace_varTablePtr(nsPtr);
  cmdTablePtr = Tcl_Namespace_cmdTablePtr(nsPtr);

#ifdef OBJDELETION_TRACE
  fprintf(stderr, "NSCleanupNamespace %p flags %.6x\n", nsPtr, Tcl_Namespace_flags(nsPtr));
  fprintf(stderr, "NSCleanupNamespace %p %.6x varTablePtr %p\n", nsPtr, ((Namespace *)nsPtr)->flags, varTablePtr);
#endif
  /*
   * Delete all variables and initialize the variable table again since
   * TclDeleteVars frees the table.  Any unset variable that is traced has
   * already been deleted by UnsetTracedVars.
   */
  TclDeleteVars((Interp *)interp, varTablePtr);
  TclInitVarHashTable(varTablePtr, (Namespace *)nsPtr);

  /*
   * Delete all user-defined procs in the namespace.
   */
  for (hPtr = Tcl_FirstHashEntry(cmdTablePtr, &hSrch);
       hPtr != NULL;
       hPtr = Tcl_NextHashEntry(&hSrch)) {
      Tcl_Command cmd = (Tcl_Command) Tcl_GetHashValue(hPtr);

      if (CmdIsNsfObject(cmd)) {
        /*
         * To preserve child deletion order, sub-objects should not be deleted
         * here. Just delete aliases.
         */
        AliasDeleteObjectReference(interp, cmd);
        continue;
      }
      /*fprintf(stderr, "NSCleanupNamespace calls DeleteCommandFromToken for %p flags %.6x\n",
                cmd, ((Command *)cmd)->flags);
      fprintf(stderr, "    cmd = %s\n", Tcl_GetCommandName(interp, cmd));
      fprintf(stderr, "    nsPtr = %p\n", ((Command *)cmd)->nsPtr);
      fprintf(stderr, "    epoch = %d\n", Tcl_Command_cmdEpoch(cmd));
      fprintf(stderr, "    refCount = %d\n", Tcl_Command_refCount(cmd));
      fprintf(stderr, "    flags %.6x\n", ((Namespace *)((Command *)cmd)->nsPtr)->flags);*/

      Tcl_DeleteCommandFromToken(interp, cmd);
  }
}


static void
NSNamespaceDeleteProc(ClientData clientData) {
  NsfObject *object;

  nonnull_assert(clientData != NULL);

  object = NSNamespaceClientDataObject(clientData);
  assert(object != NULL);

#ifdef NSF_MEM_COUNT
  ckfree((char *)clientData);
#endif

  /*fprintf(stderr, "namespace delete-proc obj=%p ns=%p\n",
    clientData, (object != NULL) ? object->nsPtr : NULL);*/

  MEM_COUNT_FREE("NSNamespace", object->nsPtr);
  object->nsPtr = NULL;
}

void Nsf_DeleteNamespace(Tcl_Interp *interp, Tcl_Namespace *nsPtr)
  nonnull(1) nonnull(2);

void
Nsf_DeleteNamespace(Tcl_Interp *interp, Tcl_Namespace *nsPtr) {

#if defined(NSF_DEVELOPMENT_TEST)
  int activationCount = 0;
  Tcl_CallFrame *f = (Tcl_CallFrame *)Tcl_Interp_framePtr(interp);

  nonnull_assert(interp != NULL);
  nonnull_assert(nsPtr != NULL);

  /*fprintf(stderr, "Nsf_DeleteNamespace %p ", nsPtr);*/

  while (f != NULL) {
    if (f->nsPtr == nsPtr) {
      activationCount++;
    }
    f = Tcl_CallFrame_callerPtr(f);
  }


  if (Tcl_Namespace_activationCount(nsPtr) != activationCount) {
    fprintf(stderr, "WE HAVE TO FIX ACTIVATIONCOUNT\n");
    Tcl_Namespace_activationCount(nsPtr) = activationCount;
  }
  assert(Tcl_Namespace_activationCount(nsPtr) == activationCount);
  /*fprintf(stderr, "to %d. \n", ((Namespace *)nsPtr)->activationCount);*/
#else
  (void)interp;
#endif

  if (Tcl_Namespace_deleteProc(nsPtr)) {
    /*fprintf(stderr, "calling deteteNamespace %s\n", nsPtr->fullName);*/
    Tcl_DeleteNamespace(nsPtr);
  }
}

/*
 *----------------------------------------------------------------------
 * NSValidObjectName --
 *
 *    Returns NSF_TRUE if the given name is a valid object name.
 *
 * Results:
 *    True on success.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static bool NSValidObjectName(const char *name, size_t l)
  nonnull(1) NSF_pure;

NSF_INLINE static bool
NSValidObjectName(const char *name, size_t l) {
  register const char *n;
  bool           result = NSF_TRUE;

  nonnull_assert(name != NULL);

  n = name;
  if (*n == '\0') {
    result = NSF_FALSE; /* empty name */
  } else {
    /*
     * Compute size if not given.
     */
    if (l == 0) {
      l = strlen(n);
    }
    /*
     * Check string.
     */
    if (*(n+l-1) == ':') {
      result = NSF_FALSE; /* name ends with : */

    } else if (*n == ':' && *(n+1) != ':') {
      result = NSF_FALSE; /* name begins with single : */

    } else {
      for (; *n != '\0'; n++) {
        if (*n == ':' && *(n+1) == ':' && *(n+2) == ':') {
          result = NSF_FALSE;  /* more than 2 colons in series in a name */
          break;
        }
      }
    }
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * NSGetFreshNamespace --
 *
 *    Creates a namespace, sets a deleteProc to avoid interference between
 *    object and namespace deletion order, and stores a pointer to the object
 *    in the clientData for the namespace.
 *
 * Results:
 *    A Tcl_Namespace*.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static Tcl_Namespace*
NSGetFreshNamespace(Tcl_Interp *interp, NsfObject *object, const char *name) {
  Namespace *dummy1Ptr, *dummy2Ptr, *nsPtr;
  const char *dummy;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(name != NULL);

  TclGetNamespaceForQualName(interp, name, NULL, TCL_FIND_ONLY_NS|TCL_CREATE_NS_IF_UNKNOWN,
                             &nsPtr, &dummy1Ptr, &dummy2Ptr, &dummy);

  if (nsPtr->deleteProc != NSNamespaceDeleteProc) {
    /*
     * Avoid hijacking a namespace with different client data.
     */
    if (nsPtr->deleteProc || nsPtr->clientData) {
      Tcl_Panic("Namespace '%s' exists already with delProc 0x%" PRIxPTR " and clientData %p; "
                "Can only convert a plain Tcl namespace into an Nsf namespace, my delete proc 0x%" PRIxPTR,
                name, (unsigned long)PTR2UINT(nsPtr->deleteProc),
                nsPtr->clientData, (unsigned long)PTR2UINT(NSNamespaceDeleteProc));
    }

    {
#ifdef NSF_MEM_COUNT
      NsfNamespaceClientData *nsClientData = (NsfNamespaceClientData *)ckalloc((int)sizeof(NsfNamespaceClientData));

      nsClientData->object = object;
      nsClientData->nsPtr = (Tcl_Namespace *)nsPtr;
      nsPtr->clientData = nsClientData;

      /*fprintf(stderr, "Adding NsfNamespaceClientData nsPtr %p cd %p name '%s'\n",
        nsPtr, nsClientData, nsPtr->fullName);*/
#else
      nsPtr->clientData = object;
#endif
      nsPtr->deleteProc = (Tcl_NamespaceDeleteProc *)NSNamespaceDeleteProc;
    }
    MEM_COUNT_ALLOC("NSNamespace", nsPtr);
  } else {
    fprintf(stderr, "NSGetFreshNamespace: reusing namespace %p %s\n", (void *)nsPtr, nsPtr->fullName);
  }

  return (Tcl_Namespace *)nsPtr;
}

/*
 *----------------------------------------------------------------------
 * NSRequireParentObject --
 *
 *    Attempts to require a parent object, e.g. during ttrace, loading the
 *    parent object via ::nsf::object::unknown if necessary.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static int NSRequireParentObject(Tcl_Interp *interp, const char *parentName)
  nonnull(1) nonnull(2);

static int
NSRequireParentObject(Tcl_Interp *interp, const char *parentName) {
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(parentName != NULL);

  result = NsfCallObjectUnknownHandler(interp, Tcl_NewStringObj(parentName, -1));
  if (likely(result == TCL_OK)) {
    NsfObject *parentObj = (NsfObject *)GetObjectFromString(interp, parentName);

    if (parentObj != NULL) {
      RequireObjNamespace(interp, parentObj);
    }
    result = (Tcl_FindNamespace(interp, parentName,
                                (Tcl_Namespace *) NULL, TCL_GLOBAL_ONLY) != NULL
              ? TCL_OK: TCL_ERROR);
  }
  return result;

}

/*
 *----------------------------------------------------------------------
 * NSCheckNamespace --
 *
 *    Returns the named namespace if it exists, and if not, ensures that a
 *    potential parent object has a namespace. If there is no parent namespace
 *    yet, attempts to create a parent object via __unknown.
 *
 *    If the provided parentNsPtr is not NULL, then (a) the provided name was
 *    relative and simple, i.e. contains no ":" characters, and (b) this
 *    namespace was used to build a fully- qualified name. In these cases, the
 *    parentNsPtr already points to the parentName, which may contain the
 *    parent Object. In all other cases, the parent name is either obtained
 *    from the full namespace or derived from the given name.
 *
 * Results:
 *    A Tcl_Namespace for the given name.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static Tcl_Namespace *NSCheckNamespace(
    Tcl_Interp *interp, const char *nameString, Tcl_Namespace *parentNsPtr1
)  nonnull(1) nonnull(2);

NSF_INLINE static Tcl_Namespace *
NSCheckNamespace(
    Tcl_Interp *interp, const char *nameString, Tcl_Namespace *parentNsPtr1
) {
  Namespace   *nsPtr, *dummy1Ptr, *dummy2Ptr, *parentNsPtr = (Namespace *)parentNsPtr1;
  const char  *parentName, *dummy;
  Tcl_DString ds, *dsPtr = &ds;

  nonnull_assert(interp != NULL);
  nonnull_assert(nameString != NULL);

  /*fprintf(stderr, "NSCheckNamespace %s parentNsPtr %p\n", nameString, parentNsPtr);*/

  /*
   * There won't usually be a namespace, but if there is, use it to determine
   * the parent name.
   */
  TclGetNamespaceForQualName(interp, nameString, NULL,
                             TCL_GLOBAL_ONLY|TCL_FIND_ONLY_NS,
                             &nsPtr, &dummy1Ptr, &dummy2Ptr, &dummy);
  /*fprintf(stderr,
          "before create calls TclGetNamespaceForQualName with %s => %p (%s) %p %s %p %s %p %s\n",
          nameString, nsPtr, (nsPtr != NULL) ? nsPtr->fullName : "",
          dummy1Ptr, (dummy1Ptr != NULL) ? dummy1Ptr->fullName : "",
          parentNsPtr, (parentNsPtr != NULL) ? parentNsPtr->fullName : "",
          dummy, (dummy != NULL) ? dummy : "");*/

  /*
   * Determine the parent namespace from the full namespace if possible.
   */

  if (parentNsPtr == NULL && nsPtr != NULL) {
    parentNsPtr = Tcl_Namespace_parentPtr(nsPtr);
  }

  if (parentNsPtr != NULL) {
    parentName = parentNsPtr->fullName;
    if (*(parentName + 2) == '\0') {
      parentName = NULL;
    }
    /*fprintf(stderr, "NSCheckNamespace parentNs %s parentName of '%s' => '%s'\n",
      parentNsPtr->fullName, nameString, parentName);*/
  } else {
    /*
     * The parent namespace must be extracted from the string value.
     */
    int         parentNameLength;
    const char *n = nameString + strlen(nameString);
    /*
     * search for last '::'.
     */
    while ((*n != ':' || *(n-1) != ':') && n-1 > nameString) {
      n--;
    }
    if (*n == ':' && n > nameString && *(n-1) == ':') {
      n--;
    }
    parentNameLength = (int)(n - nameString);
    if (parentNameLength > 0) {
      DSTRING_INIT(dsPtr);
      Tcl_DStringAppend(dsPtr, nameString, parentNameLength);
      parentName = Tcl_DStringValue(dsPtr);
      DSTRING_FREE(dsPtr);
    } else {
      parentName = NULL;
    }
  }

  if (parentName != NULL) {
    NsfObject *parentObj;

    parentObj = (NsfObject *) GetObjectFromString(interp, parentName);
    /*fprintf(stderr, "parentName %s parentObj %p\n", parentName, parentObj);*/

    if (parentObj != NULL) {
      RequireObjNamespace(interp, parentObj);
    } else if (nsPtr == NULL && parentNsPtr == NULL) {
      TclGetNamespaceForQualName(interp, parentName, NULL,
                                 TCL_GLOBAL_ONLY|TCL_FIND_ONLY_NS,
                                 &parentNsPtr, &dummy1Ptr,
                                 &dummy2Ptr, &dummy);
      if (parentNsPtr == NULL) {
        /*fprintf(stderr, "===== calling NSRequireParentObject %s", parentName);*/
        NSRequireParentObject(interp, parentName);
      }
    }
  }

  return (Tcl_Namespace *)nsPtr;
}


/*
 *----------------------------------------------------------------------
 * NSFindCommand --
 *
 *    Returns the command, if any, corresponding to the given fully-qualified
 *    name, following any imported commands until the origin command is found.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

NSF_INLINE static Tcl_Command NSFindCommand(Tcl_Interp *interp, const char *name)
  nonnull(1) nonnull(2);

NSF_INLINE static Tcl_Command
NSFindCommand(Tcl_Interp *interp, const char *name) {
  Tcl_Command cmd;

  nonnull_assert(interp != NULL);
  nonnull_assert(name != NULL);
  assert(*name == ':' && *(name + 1) == ':');

  cmd = Tcl_FindCommand(interp, name, NULL, TCL_GLOBAL_ONLY);
  if (likely(cmd != NULL)) {
    Tcl_Command importedCmd = TclGetOriginalCommand(cmd);
    if (unlikely(importedCmd != NULL)) {
      cmd = importedCmd;
    }
  }
  return cmd;
}

#if defined(NSF_DEVELOPMENT_TEST)
/*
 *----------------------------------------------------------------------
 * ReverseLookupCmdFromCmdTable --
 *
 *    Returns true if the given command exists in the given table. Useful to
 *    determine that a command exists even when it might be hidden.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static bool ReverseLookupCmdFromCmdTable(
    const Tcl_Command searchCmdPtr,
    Tcl_HashTable *cmdTablePtr
) nonnull(1) nonnull(2);

static bool
ReverseLookupCmdFromCmdTable(
    const Tcl_Command searchCmdPtr,
    Tcl_HashTable *cmdTablePtr
) {
  Tcl_HashSearch       search;
  const Tcl_HashEntry *hPtr;
  bool                 result = NSF_FALSE;

  nonnull_assert(searchCmdPtr != NULL);
  nonnull_assert(cmdTablePtr != NULL);

  for (hPtr = Tcl_FirstHashEntry(cmdTablePtr, &search);
       hPtr != NULL;
       hPtr = Tcl_NextHashEntry(&search)) {
    Tcl_Command needleCmdPtr = (Tcl_Command)Tcl_GetHashValue(hPtr);

    if (needleCmdPtr == searchCmdPtr) {
      result = NSF_TRUE;
      break;
    }
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * GetHiddenObjectFromCmd --
 *
 *    Returns the object for the given cmd even if the command is hidden. Uses
 *    a reverse lookup of *hidden* object structures based on their commands.
 *    Needed for handling hidden and re-exposed objects during the shutdown and
 *    the cleanup of object systems.
 *
 * Results:
 *    An NsfObject* or NULL.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static NsfObject *GetHiddenObjectFromCmd(
    Tcl_Interp *interp, const Tcl_Command cmdPtr
) nonnull(1);

static NsfObject *
GetHiddenObjectFromCmd(
    Tcl_Interp *interp, const Tcl_Command cmdPtr
) {
  Interp    *iPtr = (Interp *) interp;
  NsfObject *screenedObject;

  nonnull_assert(cmdPtr != NULL);

  /*
   * Shortcut if exposed cmds have an epoch counter > 0 or the originating
   * namespace of the command is the global one.
   *
   *    See also Tcl_HideCommand() and Tcl_ExposeCommand().
   */
  if (Tcl_Command_cmdEpoch(cmdPtr) == 0 ||
      ((Command *)cmdPtr)->nsPtr != iPtr->globalNsPtr) {
    screenedObject = NULL;

  } else {
    bool found;

    /*
     * Search for the object by command structure in the table of hidden
     * commands in the interpreter. Start with hidden commands since their
     * number is probably smaller than the re-exposed commands in the global
     * namespace
     */
    found = ReverseLookupCmdFromCmdTable(cmdPtr, iPtr->hiddenCmdTablePtr);
    if (!found) {
      /*
       * Search for the object by command structure in the global command table
       * of the interpreter. Most likely needed due to hiding + exposing as a
       * different name.
       */
      found = ReverseLookupCmdFromCmdTable(cmdPtr, &iPtr->globalNsPtr->cmdTable);
    }
    screenedObject = found ? NsfGetObjectFromCmdPtr(cmdPtr) : NULL;

#if !defined(NDEBUG)
    if (screenedObject != NULL) {
      NsfLog(interp, NSF_LOG_NOTICE, "screened object %s found: object %p (%s) cmd %p",
             Tcl_GetCommandName(interp, cmdPtr), (void *)screenedObject,
             ObjectName(screenedObject), (void *)cmdPtr);
    }
#endif
  }
  return screenedObject;
}
#endif

/*
 *----------------------------------------------------------------------
 * GetObjectFromString --
 *
 *    Finds the Nsf object corresponding to the given fully-qualified name.
 *
 * Results:
 *    An NsfObject* or NULL.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static NsfObject *
GetObjectFromString(Tcl_Interp *interp, const char *name) {
  register Tcl_Command cmd;

  nonnull_assert(interp != NULL);
  nonnull_assert(name != NULL);

  /*fprintf(stderr, "GetObjectFromString name = '%s'\n", name);*/
  cmd = NSFindCommand(interp, name);

  if (likely(cmd != NULL && CmdIsNsfObject(cmd))) {
    /*fprintf(stderr, "GetObjectFromString %s => %p\n", name, Tcl_Command_objClientData(cmd));*/
    return (NsfObject *)Tcl_Command_objClientData(cmd);
  }
  /*fprintf(stderr, "GetObjectFromString %s => NULL\n", name);*/
  return NULL;
}

/*
 *----------------------------------------------------------------------
 * GetClassFromString --
 *
 *    Returns the class, if any, having the given fully-qualified name. 
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static NsfClass *
GetClassFromString(Tcl_Interp *interp, const char *name) {
  NsfObject *object = GetObjectFromString(interp, name);

  nonnull_assert(interp != NULL);
  nonnull_assert(name != NULL);
  return (object != NULL && NsfObjectIsClass(object)) ? (NsfClass *)object : NULL;
}

/*
 *----------------------------------------------------------------------
 * CanRedefineCmd --
 *
 *    Returns TCL_OK if the named method can be redefined in the given
 *    namespace.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int CanRedefineCmd(
    Tcl_Interp *interp,
    const Tcl_Namespace *nsPtr,
    const NsfObject *object,
    const char *methodName,
    unsigned int flags
) nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static int
CanRedefineCmd(
    Tcl_Interp *interp,
    const Tcl_Namespace *nsPtr,
    const NsfObject *object,
    const char *methodName,
    unsigned int flags
) {
  int         result;
  bool        ok;
  Tcl_Command cmd;

  nonnull_assert(interp != NULL);
  nonnull_assert(nsPtr != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodName != NULL);

  cmd = FindMethod(nsPtr, methodName);

  if (cmd != NULL) {
    if ( NsfGetObjectFromCmdPtr(cmd) != NULL) {
      /*
       * Do not overwrite an object with a method.
       */
      return NsfPrintError(interp,
                           "refuse to overwrite child object with method %s; delete/rename it before overwriting",
                           methodName);
    }
    ok = (((unsigned int)Tcl_Command_flags(cmd) & NSF_CMD_REDEFINE_PROTECTED_METHOD) == 0u);
  } else {
    ok = NSF_TRUE;
  }

  if (likely(ok)) {
    result = TCL_OK;

  } else {
    /*
     * It could be verified that the "right" object system is being
     * bootstrapped, and only overwrites could be allowed for the current
     * bootstrap object system, but this seems unnecessary at this point.
     */
    Tcl_Obj *bootstrapObj = Tcl_GetVar2Ex(interp, "::nsf::bootstrap", NULL, TCL_GLOBAL_ONLY);

    if (bootstrapObj == NULL) {
      result = NsfPrintError(interp, "refuse to overwrite protected method '%s'; "
                             "derive e.g. a subclass!", methodName, ObjectName_(object));
    } else {
      result = TCL_OK;
    }
  }

  if (likely(result == TCL_OK)) {
    result = ObjectSystemsCheckSystemMethod(interp, methodName, object, flags);
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * NsfAddObjectMethod --
 *
 *    Externally-callable function to register an object-level method
 *    for the given object.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Creates a command.
 *
 *----------------------------------------------------------------------
 */
int NsfAddObjectMethod(
    Tcl_Interp *interp, Nsf_Object *object, const char *methodName,
    Tcl_ObjCmdProc *proc, ClientData clientData, Tcl_CmdDeleteProc *dp,
    unsigned int flags
) nonnull(1) nonnull(2) nonnull(3) nonnull(4);

int
NsfAddObjectMethod(
    Tcl_Interp *interp, Nsf_Object *object, const char *methodName,
    Tcl_ObjCmdProc *proc, ClientData clientData, Tcl_CmdDeleteProc *dp,
    unsigned int flags
) {
  NsfObject           *currentObject;
  Tcl_DString          newCmdName, *dsPtr = &newCmdName;
  const Tcl_Namespace *ns;
  Tcl_Command          newCmd;
  int                  result;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodName != NULL);
  nonnull_assert(proc != NULL);

  currentObject = (NsfObject *)object;
  ns = RequireObjNamespace(interp, currentObject);

  /*
   * Can the method be redefined?
   */
  result = CanRedefineCmd(interp, currentObject->nsPtr, currentObject, (char *)methodName, flags);
  if (unlikely(result != TCL_OK)) {
    return result;
  }
  NsfObjectMethodEpochIncr("NsfAddObjectMethod");

  /*
   * Delete an alias definition if it exists.
   */
  AliasDelete(interp, currentObject->cmdName, methodName, NSF_TRUE);

  Tcl_DStringInit(dsPtr);
  DStringAppendQualName(dsPtr, ns, methodName);

  newCmd = Tcl_CreateObjCommand(interp, Tcl_DStringValue(dsPtr), proc, clientData, dp);

  if (flags != 0u) {
    ((Command *) newCmd)->flags |= (int)flags;
  }
  Tcl_DStringFree(dsPtr);
  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 * NsfAddClassMethod --
 *
 *    Externally callable function to register a class-level method
 *    for the given class.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Creates a command.
 *
 *----------------------------------------------------------------------
 */
int NsfAddClassMethod(
    Tcl_Interp *interp, Nsf_Class *class, const char *methodName,
    Tcl_ObjCmdProc *proc, ClientData clientData, Tcl_CmdDeleteProc *dp,
    unsigned int flags
) nonnull(1) nonnull(2) nonnull(3) nonnull(4);

int
NsfAddClassMethod(
    Tcl_Interp *interp, Nsf_Class *class, const char *methodName,
    Tcl_ObjCmdProc *proc, ClientData clientData, Tcl_CmdDeleteProc *dp,
    unsigned int flags
) {
  Tcl_DString  newCmdName, *dsPtr = &newCmdName;
  Tcl_Command  newCmd;
  NsfClass    *c;
  int          result;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(methodName != NULL);
  nonnull_assert(proc != NULL);

  c = (NsfClass *)class;
  assert(c->nsPtr != NULL);

  /*
   * Can the method be redefined?
   */
  result = CanRedefineCmd(interp, c->nsPtr, &c->object, (char *)methodName, flags);
  if (unlikely(result != TCL_OK)) {
    return result;
  }

  NsfInstanceMethodEpochIncr("NsfAddClassMethod");

  /*
   * Delete the alias if it exists already.
   */
  AliasDelete(interp, class->object.cmdName, methodName, NSF_FALSE);

  Tcl_DStringInit(dsPtr);
  DStringAppendQualName(dsPtr, c->nsPtr, methodName);

  newCmd = Tcl_CreateObjCommand(interp, Tcl_DStringValue(dsPtr), proc, clientData, dp);

  if (flags != 0) {
    ((Command *) newCmd)->flags |= (int)flags;
  }
  Tcl_DStringFree(dsPtr);
  return TCL_OK;
}

/*
 * Auto-naming
 */

static Tcl_Obj * AutonameIncr(Tcl_Interp *interp, Tcl_Obj *nameObj, NsfObject *object,
             int isInstanceOpt, int doResetOpt)
  nonnull(1) nonnull(2) nonnull(3);

static Tcl_Obj *
AutonameIncr(Tcl_Interp *interp, Tcl_Obj *nameObj, NsfObject *object,
             int isInstanceOpt, int doResetOpt) {
  Tcl_Obj *valueObj, *resultObj;
  CallFrame frame, *framePtr = &frame;
  int flogs = TCL_LEAVE_ERR_MSG;

  nonnull_assert(interp != NULL);
  nonnull_assert(nameObj != NULL);
  nonnull_assert(object != NULL);

  Nsf_PushFrameObj(interp, object, framePtr);
  if (object->nsPtr != NULL) {
    flogs |= TCL_NAMESPACE_ONLY;
  }
  valueObj = Tcl_ObjGetVar2(interp, NsfGlobalObjs[NSF_AUTONAMES], nameObj, flogs);
  if (valueObj != NULL) {
    long autoname_counter;

    /*
     * It's not a problem if the autoname counter overflows.
     */
    Tcl_GetLongFromObj(interp, valueObj, &autoname_counter);
    autoname_counter++;
    if (Tcl_IsShared(valueObj)) {
      valueObj = Tcl_DuplicateObj(valueObj);
    }
    Tcl_SetLongObj(valueObj, autoname_counter);
    resultObj = Tcl_ObjSetVar2(interp, NsfGlobalObjs[NSF_AUTONAMES], nameObj,
                               valueObj, flogs);
    if (unlikely(resultObj == NULL)) {
      return NULL;
    }
  } else {
    resultObj = NsfGlobalObjs[NSF_EMPTY];
  }

  if (doResetOpt == 1) {
    if (valueObj != NULL) {
      /*
       * The variable exists. Unset it.
       */
      Tcl_UnsetVar2(interp, NsfGlobalStrings[NSF_AUTONAMES], ObjStr(nameObj), flogs);
    }
    resultObj = NsfGlobalObjs[NSF_EMPTY];
    INCR_REF_COUNT2("autoname", resultObj);
  } else {
    bool        mustCopy = NSF_TRUE, format = NSF_FALSE;
    const char *c;

    if (valueObj == NULL) {
      valueObj = Tcl_ObjSetVar2(interp, NsfGlobalObjs[NSF_AUTONAMES],
                                   nameObj, NsfGlobalObjs[NSF_ONE], flogs);
    }
    if (isInstanceOpt == 1) {
      char        firstChar;
      const char *nextChars = ObjStr(nameObj);

      firstChar = *(nextChars ++);
      if (isupper((int)firstChar)) {
        char buffer[1];

        buffer[0] = (char)tolower((int)firstChar);
        resultObj = Tcl_NewStringObj(buffer, 1);
        INCR_REF_COUNT2("autoname", resultObj);
        Tcl_AppendLimitedToObj(resultObj, nextChars, -1, INT_MAX, NULL);
        mustCopy = NSF_FALSE;
      }
    }
    if (mustCopy) {
      resultObj = Tcl_DuplicateObj(nameObj);
      INCR_REF_COUNT2("autoname", resultObj);
      /*
        fprintf(stderr, "*** copy %p %s = %p\n", name, ObjStr(name), resultObj);
      */
    }

    /*
     * If there is a "%" in the autoname, format the name using
     * Tcl_FormatObjCmd(), like Tcl "format" command, e.g.
     *    autoname a%06d --> * a000000, a000001, a000002, ...
     */
    for (c = ObjStr(resultObj); *c != '\0'; c++) {
      if (*c == '%') {
        if (*(c+1) != '%') {
          format = NSF_TRUE;
          break;
        } else {
          /*
           * If name contains "%%", append autoname, e.g.
           *     autoname a%% --> a%1, a%2, ...
           */
          c++;
        }
      }
    }
    if (format) {
      Tcl_Obj *savedResultObj, *ov[3];

      savedResultObj = Tcl_GetObjResult(interp);
      INCR_REF_COUNT(savedResultObj);
      ov[0] = NULL;
      ov[1] = resultObj;
      ov[2] = valueObj;
      if (NsfCallCommand(interp, NSF_FORMAT, 3, ov) != TCL_OK) {
        Nsf_PopFrameObj(interp, framePtr);
        DECR_REF_COUNT(savedResultObj);
        return NULL;
      }
      DECR_REF_COUNT(resultObj);
      resultObj = Tcl_DuplicateObj(Tcl_GetObjResult(interp));
      INCR_REF_COUNT2("autoname", resultObj);
      Tcl_SetObjResult(interp, savedResultObj);
      DECR_REF_COUNT(savedResultObj);

    } else {
      const char *valueString = Tcl_GetString(valueObj);

      Tcl_AppendLimitedToObj(resultObj, valueString, valueObj->length, INT_MAX, NULL);
    }
  }

  Nsf_PopFrameObj(interp, framePtr);
  assert((doResetOpt == 1 && resultObj->refCount>=1) || (resultObj->refCount == 1));
  return resultObj;
}

/*
 * Next Scripting CallStack functions.
 */

NSF_INLINE static void CallStackDoDestroy(Tcl_Interp *interp, NsfObject *object)
  nonnull(1) nonnull(2);

NSF_INLINE static void
CallStackDoDestroy(Tcl_Interp *interp, NsfObject *object) {
  Tcl_Command oid;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  /*fprintf(stderr, "CallStackDoDestroy %p flags %.6x\n", object, object->flags);*/
  PRINTOBJ("CallStackDoDestroy", object);

  /*
   * Don't do anything if for some reason DURING_DELETE is active. 
   */
  if (unlikely((object->flags & NSF_DURING_DELETE) != 0u)) {
    return;
  }
  /*fprintf(stderr, "CallStackDoDestroy %p flags %.6x activation %d object->refCount %d cmd %p \n",
    object, object->flags, object->activationCount, object->refCount, object->id);*/

  object->flags |= NSF_DURING_DELETE;
  oid = object->id;

  /*
   * if oid as already freed, flags aren't available.
   * (((Command *)oid)->flags & CMD_IS_DELETED)
   */
  if (object->teardown != NULL && oid != NULL) {
    /*
     * So that, e.g. unset traces on this object can be executed, call
     * PrimitiveDestroy() before calling DeleteCommandFromToken(). Bump the
     * refCount to preserve the object until DeleteCommandFromToken()
     * completes.
     */
    NsfObjectRefCountIncr(object);

    PrimitiveDestroy(object);

    if /*(object->teardown == NULL)*/ ((object->flags & NSF_TCL_DELETE) == 0u) {
      Tcl_Obj *savedResultObj = Tcl_GetObjResult(interp);
      INCR_REF_COUNT(savedResultObj);

      assert(object->teardown == NULL);

      /*fprintf(stderr, "    before DeleteCommandFromToken %p object flags %.6x\n", (void *)oid, object->flags);*/
      /*fprintf(stderr, "cmd dealloc %p refCount %d dodestroy \n", (void *)oid, Tcl_Command_refCount(oid));*/
      Tcl_DeleteCommandFromToken(interp, oid); /* this can change the result */
      /*fprintf(stderr, "    after DeleteCommandFromToken %p %.6x\n", (void *)oid, ((Command *)oid)->flags);*/
      Tcl_SetObjResult(interp, savedResultObj);
      DECR_REF_COUNT(savedResultObj);
    }

    NsfCleanupObject(object, "CallStackDoDestroy");
  }
}

static void
CallStackDestroyObject(Tcl_Interp *interp, NsfObject *object) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

#ifdef OBJDELETION_TRACE
  fprintf(stderr, "CallStackDestroyObject %p %s activationcount %d flags %.6x\n",
          object, ObjectName(object), object->activationCount, object->flags);
#endif

  if ((object->flags & NSF_DESTROY_CALLED) == 0u) {
    int activationCount = object->activationCount;

    /*
     * Call the destructor if it hasn't already been called.
     */
#ifdef OBJDELETION_TRACE
    fprintf(stderr, "  CallStackDestroyObject has to DispatchDestroyMethod %p activationCount %d\n",
            object, activationCount);
#endif
    DispatchDestroyMethod(interp, object, 0u);

    if (activationCount == 0) {
      /*
       * Assume the object is now freed:  Do attempt to access
       * object->activation count and do not call CallStackDoDestroy.
       */
      /*fprintf(stderr, "  CallStackDestroyObject %p done\n",  obj);*/
      return;
    }
  }

  /*
   * If the object isn't referenced on the call stack anymore, destroy it so
   * that CscFinish doesn't find it.
   */
  if (object->activationCount == 0) {
    CallStackDoDestroy(interp, object);
  } else {
    /*
     * Delete children now to preserve the deletion order, such that child
     * destructors are called before parent destructors.
     */
    if ((object->teardown != NULL) && (object->nsPtr != NULL)) {
      /*fprintf(stderr, "  CallStackDestroyObject calls NSDeleteChildren\n");*/
      NSDeleteChildren(interp, object->nsPtr);
    }
  }
  /*fprintf(stderr, "  CallStackDestroyObject %p DONE\n",  object);*/
}

/*
 * cmd list handling.
 */

/*
 *----------------------------------------------------------------------
 * CmdListAdd --
 *
 *    Appends a command to the given list if "atEnd" is true, and prepends it
 *    otherwise.  If noDuplicates is true, adds the command only if it isn't
 *    already in the list.
 *
 * Results:
 *    Either the item that was just inserted or the item that already existed.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static NsfCmdList *CmdListAdd(
    NsfCmdList **cList, const Tcl_Command cmd, NsfClass *clorobj,
    bool noDuplicates, bool atEnd
) nonnull(1) nonnull(2) returns_nonnull;

static NsfCmdList *
CmdListAdd(
    NsfCmdList **cList, const Tcl_Command cmd, NsfClass *clorobj,
    bool noDuplicates, bool atEnd
) {
  NsfCmdList *l, *nextPtr, *new;

  nonnull_assert(cmd != NULL);
  nonnull_assert(cList != NULL);

  if (unlikely(atEnd)) {
    l = *cList;
    nextPtr = NULL;
  } else {
    l = NULL;
    nextPtr = *cList;
  }


  if (unlikely(noDuplicates)) {
    NsfCmdList *h = l, **end = NULL;

    while (h != NULL) {
      if (h->cmdPtr == cmd) {
        return h;
      }
      end = &(h->nextPtr);
      h = h->nextPtr;
    }
    if (end != NULL) {
      /*
       * The command is not in the list. "end" points to the last item.
       */
      cList = end;
      l = NULL;
    }
  }

  /*
   * Add a new item to the list.
   */
  new = NEW(NsfCmdList);
  new->cmdPtr = cmd;
  NsfCommandPreserve(new->cmdPtr);
  new->clientData = NULL;
  new->clorobj = clorobj;
  new->nextPtr = nextPtr;

  if (unlikely(l != NULL)) {
    /*
     * Append the new item.
     */
    while (l->nextPtr != NULL) {
      l = l->nextPtr;
    }
    l->nextPtr = new;
  } else {
    /*
     * Prepend the new item.
     */
    *cList = new;
  }

  return new;
}

/*
 *----------------------------------------------------------------------
 * CmdListAddSorted --
 *
 *    Adds the given command to the given list, keeping the list sorted to
 *    reduce lookup cost to n/2.  Can be improved with better data structures
 *    if needed.
 *
 * Results:
 *    Either the item that was inserted or the item that already existed.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static NsfCmdList *CmdListAddSorted(NsfCmdList **cList, Tcl_Command cmd, NsfClass *clorobj)
  nonnull(1) nonnull(2) returns_nonnull;

static NsfCmdList *
CmdListAddSorted(NsfCmdList **cList, Tcl_Command cmd, NsfClass *clorobj) {
  NsfCmdList *prev, *new, *h;

  nonnull_assert(cmd != NULL);
  nonnull_assert(cList != NULL);

  for (h = *cList, prev = NULL; h != NULL; prev = h, h = h->nextPtr) {
    if (h->cmdPtr == cmd) {
      return h;
    } else if (h->cmdPtr > cmd) {
      break;
    }
  }

  new = NEW(NsfCmdList);
  new->cmdPtr = cmd;
  NsfCommandPreserve(new->cmdPtr);
  new->clientData = NULL;
  new->clorobj = clorobj;
  new->nextPtr = h;

  if (prev != NULL) {
    prev->nextPtr = new;
  } else {
    *cList = new;
  }

  return new;
}

static void CmdListReplaceCmd(NsfCmdList *replace, Tcl_Command cmd, NsfClass *clorobj)
  nonnull(1) nonnull(3);

static void
CmdListReplaceCmd(NsfCmdList *replace, Tcl_Command cmd, NsfClass *clorobj) {
  Tcl_Command del;

  nonnull_assert(replace != NULL);
  nonnull_assert(clorobj != NULL);

  del = replace->cmdPtr;
  replace->cmdPtr = cmd;
  replace->clorobj = clorobj;
  NsfCommandPreserve(cmd);
  NsfCommandRelease(del);
}

#if defined(NSF_DEBUGGING)
/** for debuggin purposes only */
static void CmdListPrint(Tcl_Interp *interp, const char *title, NsfCmdList *cmdList)
  nonnull(1) nonnull(3);

static void
CmdListPrint(Tcl_Interp *interp, const char *title, NsfCmdList *cmdList) {

  nonnull_assert(interp != NULL);
  nonnull_assert(cmdList != NULL);

  if (title != NULL) {
    fprintf(stderr, "%s %p:\n", title, cmdList);
  }
  while (cmdList != NULL) {
    fprintf(stderr, "   CL=%p, cmdPtr=%p %s, clorobj %p, clientData=%p\n",
            cmdList,
            cmdList->cmdPtr, (interp != NULL) ? Tcl_GetCommandName(interp, cmdList->cmdPtr) : "",
            cmdList->clorobj,
            cmdList->clientData);
    cmdList = cmdList->nextPtr;
  }
}
#endif

/*
 * Frees the given list.
 */
static void CmdListDeleteCmdListEntry(NsfCmdList *del, NsfFreeCmdListClientData *freeFct)
  nonnull(1);

static void
CmdListDeleteCmdListEntry(NsfCmdList *del, NsfFreeCmdListClientData *freeFct) {

  nonnull_assert(del != NULL);

  if (unlikely(freeFct != NULL)) {
    (*freeFct)(del);
  }
  NsfCommandRelease(del->cmdPtr);
  FREE(NsfCmdList, del);
}

/*
 * Removes the given item from the given list and returns that item.
 */
static NsfCmdList *CmdListRemoveFromList(NsfCmdList **cmdList, NsfCmdList *delCL)
  nonnull(1) nonnull(2);

static NsfCmdList *
CmdListRemoveFromList(NsfCmdList **cmdList, NsfCmdList *delCL) {
  register NsfCmdList *c;
  NsfCmdList          *del = NULL;

  nonnull_assert(cmdList != NULL);
  nonnull_assert(delCL != NULL);

  c = *cmdList;
  if (likely(c != NULL)) {
    if (c == delCL) {
      *cmdList = c->nextPtr;
      del = c;
    } else {
      while ((c->nextPtr != NULL) && (c->nextPtr != delCL)) {
        c = c->nextPtr;
      }
      if (c->nextPtr == delCL) {
        del = delCL;
        c->nextPtr = delCL->nextPtr;
      }
    }
  }
  return del;
}

/*
 *----------------------------------------------------------------------
 * CmdListRemoveDeleted --
 *
 *    Removes from the given list each item flagged with CMD_IS_DELETED, which
 *    Tcl_DeleteCommandFromToken() sets.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void CmdListRemoveDeleted(NsfCmdList **cmdList, NsfFreeCmdListClientData *freeFct)
  nonnull(1) nonnull(2);

static void
CmdListRemoveDeleted(NsfCmdList **cmdList, NsfFreeCmdListClientData *freeFct) {
  NsfCmdList *f, *del;

  nonnull_assert(cmdList != NULL);
  nonnull_assert(freeFct != NULL);

  f = *cmdList;
  while (f != NULL) {
    /*
     * cmdEpoch is bumped when a command is mixed in but it remains valid, so
     * use instead the flag CMD_IS_DELETED, which Tcl_DeleteCommandFromToken()
     * sets.
     */
    if (((unsigned int)Tcl_Command_flags(f->cmdPtr) & CMD_IS_DELETED) != 0u)  {
      del = f;
      f = f->nextPtr;
      del = CmdListRemoveFromList(cmdList, del);
      CmdListDeleteCmdListEntry(del, freeFct);
    } else
      f = f->nextPtr;
  }
}


/*
 * Deletes from the given list all cmds for the given object.
 */
static void CmdListRemoveContextClassFromList(
    NsfCmdList **cmdList, const NsfClass *clorobj,
    NsfFreeCmdListClientData *freeFct
) nonnull(1) nonnull(2) nonnull(3);

static void
CmdListRemoveContextClassFromList(
    NsfCmdList **cmdList, const NsfClass *clorobj,
    NsfFreeCmdListClientData *freeFct
) {
  NsfCmdList *c, *del = NULL;

  nonnull_assert(cmdList != NULL);
  nonnull_assert(clorobj != NULL);
  nonnull_assert(freeFct != NULL);

  /*
    CmdListRemoveDeleted(cmdList, freeFct);
  */
  c = *cmdList;
  while (c != NULL && c->clorobj == clorobj) {
    del = c;
    *cmdList = c->nextPtr;
    CmdListDeleteCmdListEntry(del, freeFct);
    c = *cmdList;
  }

  while (c != NULL) {
    if (c->clorobj == clorobj) {
      del = c;
      c = *cmdList;
      while ((c->nextPtr != NULL) && (c->nextPtr != del)) {
        c = c->nextPtr;
      }
      if (c->nextPtr == del) {
        c->nextPtr = del->nextPtr;
      }
      CmdListDeleteCmdListEntry(del, freeFct);
    }
    c = c->nextPtr;
  }
}

/*
 * free the memory of a whole NsfCmdList.
 */
static void
CmdListFree(NsfCmdList **cmdList, NsfFreeCmdListClientData *freeFct) {

  nonnull_assert(cmdList != NULL);

  while (*cmdList != NULL) {
    NsfCmdList *del = *cmdList;
    *cmdList = (*cmdList)->nextPtr;
    CmdListDeleteCmdListEntry(del, freeFct);
  }
}

/*
 * Finds the given command in the given list.
 */
static NsfCmdList * CmdListFindCmdInList(const Tcl_Command cmd, NsfCmdList *l)
  nonnull(2) nonnull(1) NSF_pure;

static NsfCmdList *
CmdListFindCmdInList(const Tcl_Command cmd, NsfCmdList *l) {
  register NsfCmdList *h;

  nonnull_assert(cmd != NULL);
  nonnull_assert(l != NULL);

  for (h = l; h != NULL; h = h->nextPtr) {
    if (h->cmdPtr == cmd) {
      return h;
    }
  }
  return NULL;
}

/*
 * Finds the named command in the given list.
 */
static NsfCmdList * CmdListFindNameInList(Tcl_Interp *interp, const char *name, NsfCmdList *cmdList)
  nonnull(1) nonnull(2) nonnull(3);

static NsfCmdList *
CmdListFindNameInList(Tcl_Interp *interp, const char *name, NsfCmdList *cmdList) {

  nonnull_assert(interp != NULL);
  nonnull_assert(name != NULL);
  nonnull_assert(cmdList != NULL);

  do {
    const char *cmdName = Tcl_GetCommandName(interp, cmdList->cmdPtr);
    if (cmdName[0] == name[0] && strcmp(cmdName, name) == 0) {
      return cmdList;
    }
    cmdList = cmdList->nextPtr;
  } while (cmdList != NULL);

  return NULL;
}

/*
 *----------------------------------------------------------------------
 * CheckConditionInScope --
 *
 *    Returns NSF_CHECK_FAILED if the given condition was successfully
 *    evaluated and isn't true in the environment of the current call frame,
 *    and the result of the evaluation otherwise.  It is up to the caller to
 *    decide what the current call frame is.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int CheckConditionInScope(Tcl_Interp *interp, Tcl_Obj *condition)
  nonnull(1) nonnull(2);

static int
CheckConditionInScope(Tcl_Interp *interp, Tcl_Obj *condition) {
  int      result, success;
  Tcl_Obj *ov[2] = {NULL, condition};

  nonnull_assert(interp != NULL);
  nonnull_assert(condition != NULL);

  INCR_REF_COUNT(condition);
  result = Nsf_ExprObjCmd(NULL, interp, 2, ov);
  DECR_REF_COUNT(condition);

  if (likely(result == TCL_OK)) {
    result = Tcl_GetBooleanFromObj(interp, Tcl_GetObjResult(interp), &success);
    if (result == TCL_OK && success == 0) {
      result = NSF_CHECK_FAILED;
    }
  }
  return result;
}

/*
 * Generic List object handling functions.
 */

/*
 *----------------------------------------------------------------------
 * TclObjListFreeList --
 *
 *    Frees the elements of the list.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void TclObjListFreeList(NsfTclObjList *list)
  nonnull(1);

static void
TclObjListFreeList(NsfTclObjList *list) {

  nonnull_assert(list != NULL);

  do {
    NsfTclObjList *del = list;

    list = list->nextPtr;
    DECR_REF_COUNT2("listContent", del->content);
    if (del->payload != NULL) {
      DECR_REF_COUNT2("listPayload", del->payload);
    }
    FREE(NsfTclObjList, del);
  } while (list != NULL);
}

/*
 *----------------------------------------------------------------------
 * TclObjListNewElement --
 *
 *    Adds the given value to the given list, optionally storing another value
 *    in payload.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Allocates memory.
 *
 *----------------------------------------------------------------------
 */
static Tcl_Obj * TclObjListNewElement(NsfTclObjList **list, Tcl_Obj *obj, Tcl_Obj *valueObj)
  nonnull(1) nonnull(2) returns_nonnull;

static Tcl_Obj *
TclObjListNewElement(NsfTclObjList **list, Tcl_Obj *obj, Tcl_Obj *valueObj) {
  NsfTclObjList *elt = NEW(NsfTclObjList);

  nonnull_assert(list != NULL);
  nonnull_assert(obj != NULL);

  INCR_REF_COUNT2("listContent", obj);
  elt->content = obj;
  elt->payload = valueObj;
  if (valueObj != NULL) {
    INCR_REF_COUNT2("listPayload", valueObj);
  }
  elt->nextPtr = *list;
  *list = elt;

  return obj;
}

/*
 *----------------------------------------------------------------------
 * TclObjListAdd --
 *
 *    Adds the given value to the payload list at the given key.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void TclObjListAdd(Tcl_Interp *interp, NsfTclObjList **list, Tcl_Obj *key, Tcl_Obj *value)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static void
TclObjListAdd(Tcl_Interp *interp, NsfTclObjList **list, Tcl_Obj *key, Tcl_Obj *value) {
  NsfTclObjList *elt, **prevPtr;
  const char    *keyString;

  nonnull_assert(interp != NULL);
  nonnull_assert(list != NULL);
  nonnull_assert(key != NULL);
  nonnull_assert(value != NULL);

  keyString = ObjStr(key);
  for (elt = *list, prevPtr = list; elt != NULL; prevPtr = &elt->nextPtr, elt = elt->nextPtr) {
    const char *eltString = ObjStr(elt->content);

    if (key == elt->content || strcmp(keyString, eltString) == 0) {
      /* fprintf(stderr, "TclObjListAdd: insert %s/%s equal, append to %s\n",
         keyString, ObjStr(value), ObjStr(elt->payload));*/
      Tcl_ListObjAppendElement(interp, elt->payload, value);
      return;
    }
    if (strcmp(keyString, eltString) < 0) {
      /*
       * Insert a new key at the right place and then append the value to its
       * payload.
       */
      /*fprintf(stderr, "TclObjListAdd: insert %s/%s before %s isshared %d\n",
        keyString, ObjStr(value), eltString, Tcl_IsShared(key));*/
      TclObjListNewElement(prevPtr, key, Tcl_IsShared(value) ? Tcl_DuplicateObj(value) : value);
      return;
    }
  }
  /*
   * Append a key and then append the value to its payload.
   */
  /* fprintf(stderr, "TclObjListAdd: insert last %s value %s\n", keyString, ObjStr(value)); */
  TclObjListNewElement(prevPtr, key, Tcl_NewListObj(1, &value));

  return;
}

/*
 *----------------------------------------------------------------------
 * AddObjToTclList --
 *
 *    Adds the given value to the given list, creating a new list if the list
 *    is NULL.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void
AddObjToTclList(
    Tcl_Interp  *interp,
    Tcl_Obj    **listObjPtr,
    Tcl_Obj     *obj
) nonnull(2) nonnull(3);

static void
AddObjToTclList(
    Tcl_Interp  *interp,
    Tcl_Obj    **listObjPtr,
    Tcl_Obj     *obj
) {
  nonnull_assert(listObjPtr != NULL);
  nonnull_assert(obj != NULL);

  if (*listObjPtr == NULL) {
    *listObjPtr = Tcl_NewListObj(1, &obj);
    INCR_REF_COUNT2("AddObjToTclList", *listObjPtr);
  } else {
    Tcl_ListObjAppendElement(interp, *listObjPtr, obj);
  }
}


#if defined(NSF_WITH_ASSERTIONS)
/*********************************************************************
 * Assertions
 **********************************************************************/

static NsfTclObjList * AssertionNewList(Tcl_Interp *interp, Tcl_Obj *aObj)
  nonnull(1);

static NsfTclObjList *
AssertionNewList(Tcl_Interp *interp, Tcl_Obj *aObj) {
  Tcl_Obj **ov; int oc;
  NsfTclObjList *last = NULL;

  nonnull_assert(interp != NULL);

  if (aObj && Tcl_ListObjGetElements(interp, aObj, &oc, &ov) == TCL_OK) {
    if (oc > 0) {
      int i;
      for (i = oc - 1; i >= 0; i--) {
        TclObjListNewElement(&last, ov[i], NULL);
      }
    }
  }
  return last;
}

static Tcl_Obj *AssertionList(Tcl_Interp *interp, NsfTclObjList *alist)
  nonnull(1);

static Tcl_Obj *
AssertionList(Tcl_Interp *interp, NsfTclObjList *alist) {
  Tcl_Obj *listObj = Tcl_NewListObj(0, NULL);

  nonnull_assert(interp != NULL);

  for (; alist != NULL; alist = alist->nextPtr) {
    Tcl_ListObjAppendElement(interp, listObj, alist->content);
  }
  return listObj;
}

static int AssertionListCheckOption(Tcl_Interp *interp, NsfObject *object)
  nonnull(1) nonnull(2);

static int
AssertionListCheckOption(Tcl_Interp *interp, NsfObject *object) {
  NsfObjectOpt *opt;
  Tcl_Obj      *resultObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  opt = object->opt;
  if (opt == NULL) {
    return TCL_OK;
  }

  resultObj = Tcl_GetObjResult(interp);

  if (opt->checkoptions & CHECK_OBJINVAR) {
    Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj("object-invar", -1));
  }
  if (opt->checkoptions & CHECK_CLINVAR) {
    Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj("class-invar", -1));
  }
  if (opt->checkoptions & CHECK_PRE) {
    Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj("pre", -1));
  }
  if (opt->checkoptions & CHECK_POST) {
    Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj("post", -1));
  }

  return TCL_OK;
}

static NsfProcAssertion *AssertionFindProcs(NsfAssertionStore *aStore, const char *name)
  nonnull(1) nonnull(2);

static NsfProcAssertion *
AssertionFindProcs(NsfAssertionStore *aStore, const char *name) {
  const Tcl_HashEntry *hPtr;

  nonnull_assert(aStore != NULL);
  nonnull_assert(name != NULL);

  hPtr = Tcl_CreateHashEntry(&aStore->procs, name, NULL);
  if (hPtr == NULL) {
    return NULL;
  }
  return (NsfProcAssertion *) Tcl_GetHashValue(hPtr);
}

static void AssertionRemoveProc(NsfAssertionStore *aStore, const char *name)
  nonnull(1) nonnull(2);

static void
AssertionRemoveProc(NsfAssertionStore *aStore, const char *name) {
  Tcl_HashEntry *hPtr;

  nonnull_assert(aStore != NULL);
  nonnull_assert(name != NULL);

  hPtr = Tcl_CreateHashEntry(&aStore->procs, name, NULL);
  if (hPtr != NULL) {
    NsfProcAssertion *procAss = (NsfProcAssertion *) Tcl_GetHashValue(hPtr);

    if (procAss->pre != NULL) {
      TclObjListFreeList(procAss->pre);
    }
    if (procAss->post != NULL) {
      TclObjListFreeList(procAss->post);
    }
    FREE(NsfProcAssertion, procAss);
    Tcl_DeleteHashEntry(hPtr);
  }
}

static void AssertionAddProc(Tcl_Interp *interp, const char *name, NsfAssertionStore *aStore,
                 Tcl_Obj *pre, Tcl_Obj *post)
  nonnull(1) nonnull(2) nonnull(3);

static void
AssertionAddProc(Tcl_Interp *interp, const char *name, NsfAssertionStore *aStore,
                 Tcl_Obj *pre, Tcl_Obj *post) {
  int isNew = 0;
  Tcl_HashEntry *hPtr;
  NsfProcAssertion *procs = NEW(NsfProcAssertion);

  nonnull_assert(interp != NULL);
  nonnull_assert(name != NULL);
  nonnull_assert(aStore != NULL);

  AssertionRemoveProc(aStore, name);
  procs->pre = AssertionNewList(interp, pre);
  procs->post = AssertionNewList(interp, post);
  hPtr = Tcl_CreateHashEntry(&aStore->procs, name, &isNew);
  if (isNew != 0) {
    Tcl_SetHashValue(hPtr, procs);
  }
}

static NsfAssertionStore *AssertionCreateStore(void) returns_nonnull;

static NsfAssertionStore *
AssertionCreateStore(void) {
  NsfAssertionStore *aStore = NEW(NsfAssertionStore);

  aStore->invariants = NULL;
  Tcl_InitHashTable(&aStore->procs, TCL_STRING_KEYS);
  MEM_COUNT_ALLOC("Tcl_InitHashTable", &aStore->procs);
  return aStore;
}

static void AssertionRemoveStore(NsfAssertionStore *aStore)
  nonnull(1);

static void
AssertionRemoveStore(NsfAssertionStore *aStore) {
  Tcl_HashSearch hSrch;
  const Tcl_HashEntry *hPtr;

  nonnull_assert(aStore != NULL);

  for (hPtr = Tcl_FirstHashEntry(&aStore->procs, &hSrch);
       hPtr != NULL;
       hPtr = Tcl_FirstHashEntry(&aStore->procs, &hSrch)) {
    /*
     * AssertionRemoveProc calls Tcl_DeleteHashEntry(hPtr), returning the
     * FirstHashEntry to proceed with.
     */
    AssertionRemoveProc(aStore, Tcl_GetHashKey(&aStore->procs, hPtr));
  }
  Tcl_DeleteHashTable(&aStore->procs);
  MEM_COUNT_FREE("Tcl_InitHashTable", &aStore->procs);
  if (aStore->invariants != NULL) {
    TclObjListFreeList(aStore->invariants);
  }
  FREE(NsfAssertionStore, aStore);
}

static int AssertionCheckList(Tcl_Interp *interp, NsfObject *object,
                              NsfTclObjList *alist, const char *methodName)
  nonnull(1) nonnull(2) nonnull(4);

static int
AssertionCheckList(Tcl_Interp *interp, NsfObject *object,
                   NsfTclObjList *alist, const char *methodName) {
  NsfTclObjList *checkFailed = NULL;
  Tcl_Obj       *savedResultObj;
  CheckOptions   savedCheckoptions;
  int            acResult = TCL_OK;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodName != NULL);

  /*
   * No obj->opt: Interpret as CHECK_NONE.
   */
  if (object->opt == NULL) {
    return TCL_OK;
  }

  /*
   * Do not check assertion-modifying methods. Otherwise there is no way to
   * react in a catch on a runtime assertion check failure.
   */

#if 1
  /*
   * TODO: the following check operation is legacy XOTcl1 and is not generic.
   * It should be replaced by another method property.  Most of the is*String()
   * definitions will then then be obsolete and should be deleted from
   * nsfInt.h.
   */

  if (isCheckString(methodName)) {
    return TCL_OK;
  }
#endif

  savedResultObj = Tcl_GetObjResult(interp);
  INCR_REF_COUNT(savedResultObj);

  Tcl_ResetResult(interp);

  while (alist != NULL) {
    /*
     * Use Eval instead of IfObjCmd so that Tcl performs substitutions in the
     * conditions.
     */
    const char *assStr = ObjStr(alist->content), *c = assStr;
    int         comment = 0;

    for (; c && *c != '\0'; c++) {
      if (*c == '#') {
        comment = 1; break;
      }
    }

    if (comment == 0) {
      CallFrame frame, *framePtr = &frame;
      Nsf_PushFrameObj(interp, object, framePtr);

      /*
       * Don't check assertions during the condition check.
       */
      savedCheckoptions = object->opt->checkoptions;
      object->opt->checkoptions = CHECK_NONE;

      /* fprintf(stderr, "Checking Assertion %s ", assStr); */

      /*
       * Check the condition in the scope of the pushed call frame.
       */
      acResult = CheckConditionInScope(interp, alist->content);
      if (acResult != TCL_OK) {
        checkFailed = alist;
      }
      object->opt->checkoptions = savedCheckoptions;
      /* fprintf(stderr, "...%s\n", (checkFailed != 0) ? "failed" : "ok"); */
      Nsf_PopFrameObj(interp, framePtr);
    }
    if (checkFailed != 0) {
      break;
    }
    alist = alist->nextPtr;
  }

  if (unlikely(checkFailed != 0)) {
    DECR_REF_COUNT(savedResultObj);
    if (acResult == TCL_ERROR) {
      Tcl_Obj *sr = Tcl_GetObjResult(interp);
      INCR_REF_COUNT(sr);
      NsfPrintError(interp, "error in Assertion: {%s} in proc '%s'\n%s",
                    ObjStr(checkFailed->content), methodName, ObjStr(sr));
      DECR_REF_COUNT(sr);
      return TCL_ERROR;
    }
    return NsfPrintError(interp, "assertion failed check: {%s} in proc '%s'",
                         ObjStr(checkFailed->content), methodName);
  }

  Tcl_SetObjResult(interp, savedResultObj);
  DECR_REF_COUNT(savedResultObj);

  return TCL_OK;
}

static int AssertionCheckInvars(Tcl_Interp *interp, NsfObject *object,
                     const char *methodName,
                     CheckOptions checkoptions)
  nonnull(1) nonnull(2) nonnull(3);

static int
AssertionCheckInvars(Tcl_Interp *interp, NsfObject *object,
                     const char *methodName,
                     CheckOptions checkoptions) {
  int result = TCL_OK;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodName != NULL);

  if (checkoptions & CHECK_OBJINVAR && object->opt->assertions) {
    result = AssertionCheckList(interp, object, object->opt->assertions->invariants,
                                methodName);
  }

  if (result != TCL_ERROR && checkoptions & CHECK_CLINVAR) {
    NsfClasses *clPtr;

    clPtr = PrecedenceOrder(object->cl);
    while ((clPtr != NULL) && (result != TCL_ERROR)) {
      NsfAssertionStore *aStore = (clPtr->cl->opt != NULL) ? clPtr->cl->opt->assertions : NULL;

      if (aStore != NULL) {
        result = AssertionCheckList(interp, object, aStore->invariants, methodName);
      }
      clPtr = clPtr->nextPtr;
    }
  }
  return result;
}

static int AssertionCheck(Tcl_Interp *interp, NsfObject *object, NsfClass *class,
                          const char *method, CheckOptions checkOption)
  nonnull(1) nonnull(2) nonnull(4);

static int
AssertionCheck(Tcl_Interp *interp, NsfObject *object, NsfClass *class,
               const char *method, CheckOptions checkOption) {
  int                result = TCL_OK;
  NsfAssertionStore *aStore;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(method != NULL);
  assert(object->opt != NULL);

  if (class != NULL) {
    aStore = (class->opt != NULL) ? class->opt->assertions : NULL;
  } else {
    aStore = (object->opt != NULL) ? object->opt->assertions : NULL;
  }

  if ((aStore != NULL)
      && (checkOption & object->opt->checkoptions)
      ) {
    NsfProcAssertion *procs = AssertionFindProcs(aStore, method);

    if (procs != NULL) {
      switch (checkOption) {
      case CHECK_PRE:
        result = AssertionCheckList(interp, object, procs->pre, method);
        break;
      case CHECK_POST:
        result = AssertionCheckList(interp, object, procs->post, method);
        break;
      case CHECK_ALL:      NSF_FALL_THROUGH; /* fall through */
      case CHECK_NONE:     NSF_FALL_THROUGH; /* fall through */
      case CHECK_CLINVAR:  NSF_FALL_THROUGH; /* fall through */
      case CHECK_OBJINVAR: NSF_FALL_THROUGH; /* fall through */
      case CHECK_INVAR:
        break;
      }
    }
    if (likely(result != TCL_ERROR)) {
      result = AssertionCheckInvars(interp, object, method, object->opt->checkoptions);
    }
  }
  return result;
}

static int AssertionSetCheckOptions(Tcl_Interp *interp, NsfObject *object, Tcl_Obj *arg)
  nonnull(1) nonnull(2) nonnull(3);

static int
AssertionSetCheckOptions(Tcl_Interp *interp, NsfObject *object, Tcl_Obj *arg) {
  NsfObjectOpt *opt;
  int ocArgs;
  Tcl_Obj **ovArgs;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(arg != NULL);

  opt = NsfRequireObjectOpt(object);
  opt->checkoptions = CHECK_NONE;

  if (Tcl_ListObjGetElements(interp, arg, &ocArgs, &ovArgs) == TCL_OK
      && ocArgs > 0) {
    int i;
    for (i = 0; i < ocArgs; i++) {
      const char *option = ObjStr(ovArgs[i]);
      if (option != NULL) {
        switch (*option) {
        case 'c':
          if (strcmp(option, "class-invar") == 0) {
            opt->checkoptions |= CHECK_CLINVAR;
          }
          break;
        case 'o':
          if (strcmp(option, "object-invar") == 0) {
            opt->checkoptions |= CHECK_OBJINVAR;
          }
          break;
        case 'p':
          if (strcmp(option, "pre") == 0) {
            opt->checkoptions |= CHECK_PRE;
          } else if (strcmp(option, "post") == 0) {
            opt->checkoptions  |= CHECK_POST;
          }
          break;
        case 'a':
          if (strcmp(option, "all") == 0) {
            opt->checkoptions |= CHECK_ALL;
          }
          break;
        }
      }
    }
  }
  if (opt->checkoptions == CHECK_NONE && ocArgs > 0) {
    return NsfPrintError(interp, "unknown check option in command '%s' check %s, ",
                         "valid: all pre post object-invar class-invar",
                         ObjectName_(object), ObjStr(arg));
  }
  return TCL_OK;
}

static void AssertionSetInvariants(Tcl_Interp *interp, NsfAssertionStore **assertions, Tcl_Obj *arg)
  nonnull(1) nonnull(2) nonnull(3);

static void
AssertionSetInvariants(Tcl_Interp *interp, NsfAssertionStore **assertions, Tcl_Obj *arg) {

  nonnull_assert(interp != NULL);
  nonnull_assert(assertions != NULL);
  nonnull_assert(arg != NULL);

  if (*assertions != NULL) {
    TclObjListFreeList((*assertions)->invariants);
  } else {
    *assertions = AssertionCreateStore();
  }
  (*assertions)->invariants = AssertionNewList(interp, arg);
}
#endif /* NSF_WITH_ASSERTIONS */




/***********************************************************************
 * Mixin support
 ***********************************************************************/

/*
 * Pushes a mixin stack onto the given object.
 */
static void MixinStackPush(NsfObject *object)
  nonnull(1);

static void
MixinStackPush(NsfObject *object) {
  register NsfMixinStack *h = NEW(NsfMixinStack);

  nonnull_assert(object != NULL);

  h->currentCmdPtr = NULL;
  h->nextPtr = object->mixinStack;
  object->mixinStack = h;
  /*fprintf(stderr, "MixinStackPush %p %s\n", object, ObjectName(object));*/
}

/*
 * Pops a mixin stack from the given object.
 */
static void MixinStackPop(NsfObject *object)
  nonnull(1);

static void
MixinStackPop(NsfObject *object) {
  register const NsfMixinStack *h;

  nonnull_assert(object != NULL);

  /*fprintf(stderr, "MixinStackPop %p %s\n", object, ObjectName(object));*/
  h = object->mixinStack;
  object->mixinStack = h->nextPtr;
  FREE(NsfMixinStack, h);
}

/*
 * Appends to the given list each class in mixinList and the classes in
 * its superclass hierarchy of that class.
 */
static void MixinComputeOrderFullList(
    Tcl_Interp *interp, NsfCmdList **mixinList,
    NsfClasses **mixinClasses,
    NsfClasses **checkList, int level
) nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static void
MixinComputeOrderFullList(
    Tcl_Interp *interp, NsfCmdList **mixinList,
    NsfClasses **mixinClasses,
    NsfClasses **checkList, int level
) {
  NsfCmdList *m;
  NsfClasses *pl, **clPtr = mixinClasses;

  nonnull_assert(interp != NULL);
  nonnull_assert(mixinList != NULL);
  nonnull_assert(mixinClasses != NULL);
  nonnull_assert(checkList != NULL);

  CmdListRemoveDeleted(mixinList, GuardDel);

  for (m = *mixinList; m != NULL; m = m->nextPtr) {
    NsfClass *mixinClass = NsfGetClassFromCmdPtr(m->cmdPtr);

    if (mixinClass != NULL) {
      for (pl = PrecedenceOrder(mixinClass); pl != NULL; pl = pl->nextPtr) {
        if (!IsRootClass(pl->cl)) {
          NsfClassOpt *opt = pl->cl->opt;

          /* fprintf(stderr, "find %p %s in checklist 1 %p\n",
             pl->cl, ClassName(pl->cl), *checkList);*/
          if (*checkList != NULL && (NsfClassListFind(*checkList, pl->cl) != NULL)) {
            /*fprintf(stderr, "+++ never add %s\n", ClassName(pl->cl));*/
          } else {
            if (opt != NULL && opt->classMixins != NULL) {
              /*
               * Compute the hierarchy of mixin-classes of this added class.
               */
              NsfClassListAdd(checkList, pl->cl, NULL);
              /*fprintf(stderr, "+++ transitive %s\n", ClassName(pl->cl));*/
              MixinComputeOrderFullList(interp, &opt->classMixins, mixinClasses,
                                        checkList, level+1);
            }
            /*fprintf(stderr, "+++ add to mixinClasses %p path: %s clPtr %p\n",
              mixinClasses, ClassName(pl->cl), clPtr);*/
            clPtr = NsfClassListAddNoDup(clPtr, pl->cl, m->clientData);
          }
        }
      }
    }
  }

  if (level == 0 && *checkList) {
    NsfClassListFree(*checkList);
    *checkList = NULL;
  }
}

/*
 *----------------------------------------------------------------------
 * MixinResetOrder --
 *
 *    Frees any existing mixin order for the given object.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void MixinResetOrder(NsfObject *object)
  nonnull(1);

static void
MixinResetOrder(NsfObject *object) {

  nonnull_assert(object != NULL);

  CmdListFree(&object->mixinOrder, NULL /*GuardDel*/);
  object->mixinOrder = NULL;
}

/*
 *----------------------------------------------------------------------
 * NsfClassListAddPerClassMixins --
 *
 *    Appends to the given list the classes mixed into the given class and and
 *    any class in its superClass hierarchy.  CheckList is used internally to
 *    eliminate duplicates.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void NsfClassListAddPerClassMixins(Tcl_Interp *interp, NsfClass *class,
                              NsfClasses **classListPtr, NsfClasses **checkList)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static void
NsfClassListAddPerClassMixins(Tcl_Interp *interp, NsfClass *class,
                              NsfClasses **classListPtr, NsfClasses **checkList) {
  NsfClasses *pl;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(classListPtr != NULL);
  nonnull_assert(checkList != NULL);

  for (pl = PrecedenceOrder(class); pl != NULL; pl = pl->nextPtr) {
    NsfClassOpt *clopt = pl->cl->opt;
    if (clopt != NULL && clopt->classMixins) {
      MixinComputeOrderFullList(interp, &clopt->classMixins,
                                classListPtr, checkList, 1);
    }
  }
}

/*
 *----------------------------------------------------------------------
 * MixinComputeOrder --
 *
 *    Computes a duplicate-free linearized order of mixins to the object or its
 *    class superclass hierarchy. The precedence rule is that the last
 *    occurrence makes it into the final list.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Updates object->mixinOrder.
 *
 *----------------------------------------------------------------------
 */
static void MixinComputeOrder(Tcl_Interp *interp, NsfObject *object)
  nonnull(1) nonnull(2);

static void
MixinComputeOrder(Tcl_Interp *interp, NsfObject *object) {
  NsfClasses *fullList, *checkList = NULL, *mixinClasses = NULL, *clPtr;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  if (object->mixinOrder != NULL) {
    MixinResetOrder(object);
  }

  /*
   * Append classes mixed into the object.
   */
  if (object->opt != NULL) {
    NsfCmdList *m;

    MixinComputeOrderFullList(interp, &object->opt->objMixins, &mixinClasses,
                              &checkList, 1);
    /*
     * Add ot checkList classes mixed into the object so that they are not
     * added later when they are encountered as mixins to the class of the
     * object.
     *
     * TODO: This could be done in MixinComputeOrderFullList() if an additional
     * flag were provided.
     */
    for (m = object->opt->objMixins; m != NULL; m = m->nextPtr) {
      NsfClass *mixinClass = NsfGetClassFromCmdPtr(m->cmdPtr);
      if (mixinClass != NULL) {
        NsfClassListAddNoDup(&checkList, mixinClass, NULL);
      }
    }
  }
  /*fprintf(stderr, "%s ", ObjectName(object));
  NsfClassListPrint("MixinComputeOrder poms", mixinClasses);
  NsfClassListPrint("MixinComputeOrder poms checkList", checkList);*/

  /*
   * Append classes mixed into the class hierarchy.
   */
  NsfClassListAddPerClassMixins(interp, object->cl, &mixinClasses, &checkList);

  /*fprintf(stderr, "%s ", ObjectName(object));
  NsfClassListPrint("MixinComputeOrder poms+pcms", mixinClasses);
  CmdListPrint(interp, "mixinOrder", object->mixinOrder);*/

  if (checkList != NULL) {
    NsfClassListFree(checkList);
  }

  fullList = mixinClasses;

  /*
   * Don't add duplicates or classes of the precedence order to the resulting
   * list.
   */
  for (clPtr = mixinClasses; clPtr != NULL; clPtr = clPtr->nextPtr) {
    const NsfClass *class = clPtr->cl;
    NsfClasses     *checker;

    /*fprintf(stderr, "--- Work on %s\n", ClassName(cl));
      CmdListPrint(interp, "mixinOrder", object->mixinOrder);*/

    checker = NsfClassListFind(clPtr->nextPtr, class);

    /*
     * If checker is set it is a duplicate, ignore it.
     */
    if (checker == NULL) {
      /*
       * Check object->cl hierarchy.
       */
      checker = NsfClassListFind(PrecedenceOrder(object->cl), class);
      /*
       * If checker is set it was found in the class hierarchy. Ignore it.
       */
    }
    if (checker == NULL) {
      /*
       * Add the class to the mixinOrder.
       */
      NsfCmdList *new;

      /*fprintf(stderr, "--- adding to mixinOrder %s to cmdlist %p of object %s\n",
        ClassName(class), object->mixinOrder, ObjectName(object));*/
      new = CmdListAdd(&object->mixinOrder, class->object.id, NULL,
                       /*noDuplicates*/ NSF_FALSE, NSF_TRUE);
      /*CmdListPrint(interp, "mixinOrder", object->mixinOrder);*/

      /*
       * Store the first matching guard from the full list in the new client
       * data.
       */
      checker = NsfClassListFind(fullList, class);
      if (checker != NULL) {
        new->clientData = checker->clientData;
      }
    }

  }

  if (fullList != NULL) {
    NsfClassListFree(fullList);
  }

  /*CmdListPrint(interp, "mixin order\n", obj->mixinOrder);*/
}


/*
 *----------------------------------------------------------------------
 * MixinAdd --
 *
 *    Converts the object to NsfMixinregObjType if it isn't already, and adds
 *    the object to the given list.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    May allocate elements for mixinList.
 *
 *----------------------------------------------------------------------
 */
static int MixinAdd(Tcl_Interp *interp, NsfCmdList **mixinList, Tcl_Obj *nameObj)
  nonnull(1) nonnull(2) nonnull(3);

static int
MixinAdd(Tcl_Interp *interp, NsfCmdList **mixinList, Tcl_Obj *nameObj) {
  int         result;

  nonnull_assert(interp != NULL);
  nonnull_assert(mixinList != NULL);
  nonnull_assert(nameObj != NULL);

  /*fprintf(stderr, "MixinAdd gets obj %p type %p %s\n",
    nameObj, nameObj->typePtr, ObjTypeStr(nameObj));*/

  /*
   * Convert nameObj to NsfMixinregObjType if it isn't already.
   */
  if (nameObj->typePtr != &NsfMixinregObjType
      && Tcl_ConvertToType(interp, nameObj, &NsfMixinregObjType) != TCL_OK
     ) {
    result = TCL_ERROR;

  } else {
    Tcl_Obj  *guardObj = NULL;
    NsfClass *mixinCl = NULL;

    result = NsfMixinregGet(interp, nameObj, &mixinCl, &guardObj);
    if (result == TCL_OK) {
      NsfCmdList *new;

      assert(mixinCl != NULL);
      assert(((unsigned int)Tcl_Command_flags(mixinCl->object.id) & CMD_IS_DELETED) == 0);

      new = CmdListAdd(mixinList, mixinCl->object.id, NULL,
                       /*noDuplicates*/ NSF_TRUE, NSF_TRUE);

      if (guardObj != NULL) {
        GuardAdd(new, guardObj);
      } else if (new->clientData != NULL) {
        GuardDel(new);
      }
    }
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * AppendMatchingElement --
 *
 *    Appends the given name to the given list if it matches the given pattern.
 *
 * Results:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static void AppendMatchingElement(
    Tcl_Interp *interp, Tcl_Obj *resultObj, Tcl_Obj *nameObj, const char *pattern
) nonnull(1) nonnull(2) nonnull(3);

static void
AppendMatchingElement(
    Tcl_Interp *interp, Tcl_Obj *resultObj, Tcl_Obj *nameObj, const char *pattern
) {

  nonnull_assert(interp != NULL);
  nonnull_assert(resultObj != NULL);
  nonnull_assert(nameObj != NULL);

  if (pattern == NULL || Tcl_StringMatch( ObjStr(nameObj), pattern)) {
    Tcl_ListObjAppendElement(interp, resultObj, nameObj);
  }
}

/*
 *----------------------------------------------------------------------
 * AppendMatchingElementsFromCmdList --
 *
 *    Applies AppendMatchingElement() to each element of the given list and
 *    appends the result to the list given by resultObj, stopping at
 *    matchObject if it is not NULL and occurs in the given list.
 *
 * Results:
 *    NSF_TRUE if the given matchObject is not NULL and occurs in the list,
 *    and NSF_FALSE otherwise.
 *
 * Side effects:
 *    Appends elements to the result.
 *
 *----------------------------------------------------------------------
 */
static bool AppendMatchingElementsFromCmdList(
    Tcl_Interp *interp, const NsfCmdList *cmdList,
    Tcl_Obj *resultObj,
    const char *pattern, NsfObject *matchObject
) nonnull(1) nonnull(2) nonnull(3);

static bool
AppendMatchingElementsFromCmdList(
    Tcl_Interp *interp, const NsfCmdList *cmdList,
    Tcl_Obj *resultObj,
    const char *pattern, NsfObject *matchObject
) {
  int success = NSF_FALSE;

  nonnull_assert(interp != NULL);
  nonnull_assert(cmdList != NULL);
  nonnull_assert(resultObj != NULL);

  do {
    NsfObject *object = NsfGetObjectFromCmdPtr(cmdList->cmdPtr);
    if (object != NULL) {
      if (matchObject == object) {
        return NSF_TRUE;
      } else {
        AppendMatchingElement(interp, resultObj, object->cmdName, pattern);
      }
    }
    cmdList = cmdList->nextPtr;
  } while (cmdList != NULL);

  return success;
}

/*
 *----------------------------------------------------------------------
 * AppendMatchingElementsFromClasses --
 *
 *    Applies AppendMatchingElement() to each element of the given class list
 *    and appends the result to the list given by resultObj, stopping at
 *    matchObject if it is not NULL and occurs in the given class list.
 *
 * Results:
 *    NSF_TRUE if the given matchObject is not NULL and occurs in the list, and
 *    NSF_FALSE otherwise.
 *
 * Side effects:
 *    Appends elements to the list.
 *
 *----------------------------------------------------------------------
 */
static bool AppendMatchingElementsFromClasses(
    Tcl_Interp *interp, const NsfClasses *cls,
    const char *pattern, NsfObject *matchObject
) nonnull(1);

static bool
AppendMatchingElementsFromClasses(
    Tcl_Interp *interp, const NsfClasses *cls,
    const char *pattern, NsfObject *matchObject
) {
  Tcl_Obj *resultObj;

  nonnull_assert(interp != NULL);

  resultObj = Tcl_GetObjResult(interp);
  for ( ; cls != NULL; cls = cls->nextPtr) {
    NsfObject *object = (NsfObject *)cls->cl;

    if (object != NULL) {
      if (matchObject != NULL && object == matchObject) {
        return NSF_TRUE;
      } else {
        AppendMatchingElement(interp, resultObj, object->cmdName, pattern);
      }
    }
  }
  return NSF_FALSE;
}

/*
 *----------------------------------------------------------------------
 * GetAllInstances --
 *
 *    Adds each instance of a class or any classes in its subclass hierarchy to
 *    an initialized hash table having String keys.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void
GetAllInstances(Tcl_Interp *interp, NsfCmdList **instances, NsfClass *startClass) {
  NsfClasses *clPtr, *subClasses;

  nonnull_assert(interp != NULL);
  nonnull_assert(instances != NULL);
  nonnull_assert(startClass != NULL);

  subClasses = TransitiveSubClasses(startClass);
  for (clPtr = subClasses; clPtr != NULL; clPtr = clPtr->nextPtr) {
    Tcl_HashTable *tablePtr = &clPtr->cl->instances;
    Tcl_HashSearch search;
    const Tcl_HashEntry *hPtr;

    for (hPtr = Tcl_FirstHashEntry(tablePtr, &search);
         hPtr != NULL;
         hPtr = Tcl_NextHashEntry(&search)) {

      NsfObject *inst = (NsfObject *)Tcl_GetHashKey(tablePtr, hPtr);
      Command *cmdPtr;

      assert(inst != NULL);

      if (unlikely((inst->flags & NSF_TCL_DELETE) != 0u)) {
        NsfLog(interp, NSF_LOG_NOTICE, "Object %s is apparently deleted", ObjectName(inst));
        continue;
      }

      cmdPtr = (Command *)inst->id;
      assert(cmdPtr != NULL);

      if (unlikely((cmdPtr->nsPtr->flags & NS_DYING) != 0u)) {
        NsfLog(interp, NSF_LOG_WARN, "Namespace of %s is apparently deleted", ObjectName_(inst));
        continue;
      }

#if defined(NSF_DEVELOPMENT_TEST)
      {
        /*
         * Ensure that the object can still be looked up.
         */
        NsfObject *object = GetObjectFromString(interp, ObjectName(inst));
        /*
	 * HIDDEN OBJECTS: Provide a fallback to a pointer-based lookup. This
	 * is needed because objects can be hidden or re-exposed under a
	 * different name which is not reported back to the object system by
	 * the [interp hide|expose] mechanism. However, during cleanup hidden
	 * and re-exposed objects should be exposed just ordinary objects are.
         */
        if (unlikely(object == NULL)) {
          object = GetHiddenObjectFromCmd(interp, inst->id);
        }
        assert(object != NULL);
      }
#endif

      /*fprintf (stderr, " -- %p flags %.6x activation %d %s id %p id->flags %.6x "
        "nsPtr->flags %.6x (instance of %s)\n",
        inst, inst->flags, inst->activationCount,
        ObjectName(inst), inst->id, cmdPtr->flags, (cmdPtr->nsPtr != NULL) ? cmdPtr->nsPtr->flags : 0,
        ClassName(clPtr->cl));*/

      CmdListAdd(instances, inst->id, (NsfClass *)inst,
                 NSF_FALSE, NSF_FALSE);
    }
  }

  if (subClasses != NULL) {
    NsfClassListFree(subClasses);
  }
}

/*
 *----------------------------------------------------------------------
 * AddToResultSet --
 *
 *    Adds an object to the given hash table and appends it to the given result
 *    set if it isn't matchObject.
 *
 * Results:
 *    NSF_TRUE if the object is new in the hash table and is also matchObject,
 *    and NSF_FALSE otherwise.
 *
 * Side effects:
 *    May append a value to the result set.
 *
 *----------------------------------------------------------------------
 */
static bool AddToResultSet(
    Tcl_Interp *interp, Tcl_HashTable *destTablePtr,
    Tcl_Obj *resultSet, const NsfObject *object, int *isNewPtr,
    bool appendResult, const char *pattern, NsfObject *matchObject
) nonnull(1) nonnull(2) nonnull(3) nonnull(4) nonnull(5);

static bool
AddToResultSet(
    Tcl_Interp *interp, Tcl_HashTable *destTablePtr,
    Tcl_Obj *resultSet, const NsfObject *object, int *isNewPtr,
    bool appendResult, const char *pattern, NsfObject *matchObject
) {

  nonnull_assert(interp != NULL);
  nonnull_assert(destTablePtr != NULL);
  nonnull_assert(resultSet != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(isNewPtr != NULL);

  Tcl_CreateHashEntry(destTablePtr, (char *)object, isNewPtr);
  if (*isNewPtr != 0) {
    if (matchObject != NULL && matchObject == object) {
      return NSF_TRUE;
    }
    if (appendResult) {
        AppendMatchingElement(interp, resultSet, object->cmdName, pattern);
    }
  }
  return NSF_FALSE;
}

/*
 *----------------------------------------------------------------------
 * AddToResultSetWithGuards --
 *
 *    Adds a class with guards to a hash table, optionally adding it also to
 *    the result list if it matches the given pattern.

 * Results:
 *    NSF_TRUE if the object is appended to the result set and is matchObject,
 *    and NSF_FALSE otherwise.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static bool AddToResultSetWithGuards(
    Tcl_Interp *interp, Tcl_HashTable *destTablePtr,
    Tcl_Obj *resultSet, const NsfClass *class,
    ClientData clientData, int *isNewPtr, bool appendResult,
    const char *pattern, NsfObject *matchObject
) nonnull(1) nonnull(2) nonnull(3) nonnull(4) nonnull(6) nonnull(5);

static bool
AddToResultSetWithGuards(
    Tcl_Interp *interp, Tcl_HashTable *destTablePtr,
    Tcl_Obj *resultSet, const NsfClass *class,
    ClientData clientData, int *isNewPtr, bool appendResult,
    const char *pattern, NsfObject *matchObject
) {
  bool result;

  nonnull_assert(clientData != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(destTablePtr != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(resultSet != NULL);
  nonnull_assert(isNewPtr != NULL);

  Tcl_CreateHashEntry(destTablePtr, (char *)class, isNewPtr);
  if (*isNewPtr != 0 && appendResult) {
    if (pattern == NULL || Tcl_StringMatch(ClassName_(class), pattern)) {
      Tcl_Obj *listObj = Tcl_NewListObj(0, NULL);
      Tcl_Obj *g       = (Tcl_Obj *)clientData;

      INCR_REF_COUNT(listObj);
      Tcl_ListObjAppendElement(interp, listObj, class->object.cmdName);
      Tcl_ListObjAppendElement(interp, listObj, NsfGlobalObjs[NSF_GUARD_OPTION]);
      Tcl_ListObjAppendElement(interp, listObj, g);
      Tcl_ListObjAppendElement(interp, resultSet, listObj);
      DECR_REF_COUNT(listObj);
    }
    result = (matchObject != NULL && matchObject == (NsfObject *)class);
  } else {
    result = NSF_FALSE;
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * GetAllObjectMixinsOf --
 *
 *    Adds to the given TCL_ONE_WORD_KEYS hash table each instance the given
 *    class or any class it is mixed into is mixed into, recursively.
 *
 * Results:
 *    True if the process completes successfully.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static bool GetAllObjectMixinsOf(
    Tcl_Interp *interp, Tcl_HashTable *destTablePtr,
    Tcl_Obj *resultSet, const NsfClass *startClass, bool isMixin,
    bool appendResult, const char *pattern, NsfObject *matchObject
) nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static bool
GetAllObjectMixinsOf(
    Tcl_Interp *interp, Tcl_HashTable *destTablePtr,
    Tcl_Obj *resultSet, const NsfClass *startClass, bool isMixin,
    bool appendResult, const char *pattern, NsfObject *matchObject
) {
  int         isNew = 0;
  NsfClasses *sc;
  bool        done = NSF_FALSE;

  nonnull_assert(interp != NULL);
  nonnull_assert(destTablePtr != NULL);
  nonnull_assert(resultSet != NULL);
  nonnull_assert(startClass != NULL);

  /*fprintf(stderr, "startClass = %s, opt %p, isMixin %d, pattern '%s', matchObject %p\n",
    ClassName(startClass), startClass->opt, isMixin, pattern, matchObject);*/

  /*
   * check all subclasses of startCl for mixins
   */
  for (sc = startClass->sub; sc != NULL; sc = sc->nextPtr) {
    done = GetAllObjectMixinsOf(interp, destTablePtr, resultSet,
                              sc->cl, isMixin, appendResult,
                              pattern, matchObject);
    if (done) {
      return done;
    }
  }
  /*fprintf(stderr, "check subclasses of %s done\n", ClassName(startClass));*/

  if (startClass->opt != NULL) {
    NsfCmdList *m;

    /*
     * Process each class that startCl is mixed into.
     */
    for (m = startClass->opt->isClassMixinOf; m != NULL; m = m->nextPtr) {
      NsfClass *class;

      /*
       * There should be no deleted commands in the list.
       */
      assert(((unsigned int)Tcl_Command_flags(m->cmdPtr) & CMD_IS_DELETED) == 0);

      class = NsfGetClassFromCmdPtr(m->cmdPtr);
      assert(class != NULL);
      /*fprintf(stderr, "check %s mixinof %s\n", ClassName(class), ClassName((startClass)));*/
      done = GetAllObjectMixinsOf(interp, destTablePtr, resultSet,
                                class, isMixin, appendResult,
                                pattern, matchObject);
      /* fprintf(stderr, "check %s mixinof %s done\n",
         ClassName(class), ClassName(startClass));*/
      if (done) {
        return done;
      }
    }

    /*
     * Process each object startCl is mixed into.
     */
    for (m = startClass->opt->isObjectMixinOf; m != NULL; m = m->nextPtr) {
      NsfObject *object;

      /*
       * There should be no deleted commands in the list.
       */
      assert(((unsigned int)Tcl_Command_flags(m->cmdPtr) & CMD_IS_DELETED) == 0);

      object = NsfGetObjectFromCmdPtr(m->cmdPtr);
      assert(object != NULL);

      done = AddToResultSet(interp, destTablePtr, resultSet,
                            object, &isNew, appendResult,
                            pattern, matchObject);
      if (done) {
        return done;
      }
    }
  }
  return done;
}

/*
 *----------------------------------------------------------------------
 * AddClassListEntriesToMixinsOfSet --
 *
 *    Adds each item in the given list to the result set, calling
 *    GetAllClassMixinsOf() on the item if it didn't already exist in the set.
 *
 * Results:
 *    True if the process completes successfully.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static bool
AddClassListEntriesToMixinsOfSet(
    Tcl_Interp *interp, Tcl_HashTable *destTablePtr,
    Tcl_Obj *resultSet, const NsfCmdList *mixinOfs,
    bool appendResult,
    const char *pattern, NsfObject *matchObject
) nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static bool GetAllClassMixinsOf(
    Tcl_Interp *interp, Tcl_HashTable *destTablePtr,
    Tcl_Obj *resultSet, NsfClass *startClass,
    bool isPCM, bool appendResult,
    const char *pattern, NsfObject *matchObject
) nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static bool
AddClassListEntriesToMixinsOfSet(
    Tcl_Interp *interp, Tcl_HashTable *destTablePtr,
    Tcl_Obj *resultSet, const NsfCmdList *mixinOfs,
    bool appendResult,
    const char *pattern, NsfObject *matchObject
) {
  const NsfCmdList *m;

  nonnull_assert(interp != NULL);
  nonnull_assert(destTablePtr != NULL);
  nonnull_assert(resultSet != NULL);
  nonnull_assert(mixinOfs != NULL);

  for (m = mixinOfs; m != NULL; m = m->nextPtr) {
    NsfClass *class;
    int       isNew;
    bool      done;

    /*
     * There must be no deleted commands in the list.
     */
    assert(((unsigned int)Tcl_Command_flags(m->cmdPtr) & CMD_IS_DELETED) == 0);

    class = NsfGetClassFromCmdPtr(m->cmdPtr);
    assert(class != NULL);

    done = AddToResultSet(interp, destTablePtr, resultSet,
                        &class->object, &isNew,
                        appendResult, pattern, matchObject);
    if (done) {
      return done;
    }
    if (isNew != 0) {
      done = GetAllClassMixinsOf(interp, destTablePtr, resultSet, class,
                                 NSF_TRUE, appendResult, pattern, matchObject);
      if (done) {
        return done;
      }
    }
  }
  return NSF_FALSE;
}

/*
 *----------------------------------------------------------------------
 * GetAllClassMixinsOf --
 *
 *    Adds to the given TCL_ONE_WORD_KEYS hash table the given class and each
 *    class in its subclass hierarchy has been mixed into.
 *
 * Results:
 *    True if the process completes successfully.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static bool
GetAllClassMixinsOf(
    Tcl_Interp *interp, Tcl_HashTable *destTablePtr,
    Tcl_Obj *resultSet, NsfClass *startClass,
    bool isPCM, bool appendResult,
    const char *pattern, NsfObject *matchObject
) {
  NsfClasses *sc;
  int         isNew = 0;
  bool        done = NSF_FALSE;

  nonnull_assert(interp != NULL);
  nonnull_assert(destTablePtr != NULL);
  nonnull_assert(resultSet != NULL);
  nonnull_assert(startClass != NULL);

  /*fprintf(stderr, "GetAllClassMixinsOf startClass = %p %s, opt %p, isPCM %d\n",
    startClass, ClassName(startClass), startClass->opt, isPCM);*/

  /*
   * Add startClass to the result if it is a per-class mixin.
   */
  if (isPCM) {
    done = AddToResultSet(interp, destTablePtr, resultSet,
                        &startClass->object, &isNew,
                        appendResult, pattern, matchObject);
    if (done) {
      return done;
    }

    /*
     * Process all subclasses of startClass.
     */
    for (sc = startClass->sub; sc != NULL; sc = sc->nextPtr) {
#if !defined(NDEBUG)
      if (sc->cl == startClass) {
        /*
         * Sanity check: Apparently it is possible to create via
         *  __default_superclass a class which has itself as subclass!
         */
        fprintf(stderr, "... STRANGE %p is subclass of %p %s, sub %p\n",
                (void *)sc->cl, (void *)startClass, ClassName_(startClass),
                (void *)startClass->sub);
        continue;
      }
#endif
      assert(sc->cl != startClass);
      done = GetAllClassMixinsOf(interp, destTablePtr, resultSet,
                               sc->cl, isPCM,
                               appendResult, pattern, matchObject);
      if (done) {
        return done;
      }
    }
  }

  /*
   * Does "startClass" have subclass which is mixed into any other classes?
   */
  {
    NsfClasses *subClasses = TransitiveSubClasses(startClass), *subClass;

    for (subClass = subClasses; subClass; subClass = subClass->nextPtr) {
      const NsfClass *subSubClass = subClass->cl;

      /*fprintf(stderr, "... check subclass = %p %s, opt %p, isPCM %d\n",
        subSubClass, ClassName(subSubClass), subSubClass->opt, isPCM);*/

      if (subSubClass->opt != NULL && subSubClass->opt->isClassMixinOf) {
        done = AddClassListEntriesToMixinsOfSet(interp, destTablePtr, resultSet,
                                                subSubClass->opt->isClassMixinOf,
                                                appendResult, pattern, matchObject);
        if (done) {
          goto subclassExit;
        }
      }
    }

  subclassExit:
    if (subClasses != NULL) {
      NsfClassListFree(subClasses);
    }
    if (done) {
      return done;
    }
  }

  /*
   * Is "startClass" itself mixed into any other classes?
   */
  if (startClass->opt != NULL && startClass->opt->isClassMixinOf) {
    done = AddClassListEntriesToMixinsOfSet(interp, destTablePtr, resultSet,
                                            startClass->opt->isClassMixinOf,
                                            appendResult, pattern, matchObject);
  }

  return done;
}

/*
 *----------------------------------------------------------------------
 * GetAllClassMixins --
 *
 *    Adds to the given TCL_ONE_WORD_KEYS hash table each class that is mixed
 *    into the given class or any class in its superclass hierarchy.  The
 *    classes are added it into an initialized.
 *
 * Results:
 *    True if the process completes sucessfully.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static bool GetAllClassMixins(
    Tcl_Interp *interp, Tcl_HashTable *destTablePtr,
    Tcl_Obj *resultObj, const NsfClass *startClass,
    bool withGuards, const char *pattern, NsfObject *matchObject
) nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static bool
GetAllClassMixins(
    Tcl_Interp *interp, Tcl_HashTable *destTablePtr,
    Tcl_Obj *resultObj, const NsfClass *startClass,
    bool withGuards, const char *pattern, NsfObject *matchObject
) {
  int         isNew = 0;
  NsfClass   *class;
  NsfClasses *sc;
  bool        done = NSF_FALSE;

  nonnull_assert(interp != NULL);
  nonnull_assert(destTablePtr != NULL);
  nonnull_assert(resultObj != NULL);
  nonnull_assert(startClass != NULL);

  /*
   * Add classes mixed into the given class.
   */
  if (startClass->opt != NULL) {
    NsfCmdList *m;

    for (m = startClass->opt->classMixins; m != NULL; m = m->nextPtr) {

      /*
       * There should be no deleted commands in the list.
       */
      assert(((unsigned int)Tcl_Command_flags(m->cmdPtr) & CMD_IS_DELETED) == 0);

      class = NsfGetClassFromCmdPtr(m->cmdPtr);
      assert(class != NULL);

      /* fprintf(stderr, "class mixin found: %s\n", ClassName(class)); */

      if (withGuards && (m->clientData)) {
        /* fprintf(stderr, "AddToResultSetWithGuards: %s\n", ClassName(class)); */
        done = AddToResultSetWithGuards(interp, destTablePtr, resultObj,
                                        class, m->clientData, &isNew,
                                        NSF_TRUE, pattern, matchObject);
      } else {
        /* fprintf(stderr, "AddToResultSet: %s\n", ClassName(class)); */
        done = AddToResultSet(interp, destTablePtr, resultObj,
                              &class->object, &isNew,
                              NSF_TRUE, pattern, matchObject);
      }
      if (done) {
        return done;
      }

      if (isNew != 0) {
        /* fprintf(stderr, "class mixin GetAllClassMixins for: %s (%s)\n",
           ClassName(class), ClassName(startClass)); */
        done = GetAllClassMixins(interp, destTablePtr, resultObj,
                               class, withGuards,
                               pattern, matchObject);
        if (done) {
          return done;
        }
      }
    }
  }


  /*
   * Process superclasses of startCl.
   */
  for (sc = startClass->super; sc != NULL; sc = sc->nextPtr) {
    /* fprintf(stderr, "Superclass GetAllClassMixins for %s (%s)\n",
       ClassName(sc->cl), ClassName(startClass)); */
    done = GetAllClassMixins(interp, destTablePtr, resultObj,
                             sc->cl, withGuards,
                             pattern, matchObject);
    if (done) {
      return done;
    }
  }
  return done;
}

/*
 *----------------------------------------------------------------------
 * RemoveFromClassMixinsOf --
 *
 *    Removes the class of the given command from the isClassMixinOf list of
 *    the class of each command in the given list.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static void RemoveFromClassMixinsOf(Tcl_Command cmd, NsfCmdList *cmdList)
  nonnull(1) nonnull(2);

static void
RemoveFromClassMixinsOf(Tcl_Command cmd, NsfCmdList *cmdList) {

  nonnull_assert(cmd != NULL);
  nonnull_assert(cmdList != NULL);

  do {
    const NsfClass *class = NsfGetClassFromCmdPtr(cmdList->cmdPtr);
    NsfClassOpt *nclopt = (class != NULL) ? class->opt : NULL;
    if (nclopt != NULL) {
      NsfCmdList *del = CmdListFindCmdInList(cmd, nclopt->isClassMixinOf);
      if (del != NULL) {
        /* fprintf(stderr, "Removing class %s from isClassMixinOf of class %s\n",
           ClassName(cl), ObjStr(NsfGetClassFromCmdPtr(cmdList->cmdPtr)->object.cmdName)); */
        del = CmdListRemoveFromList(&nclopt->isClassMixinOf, del);
        CmdListDeleteCmdListEntry(del, GuardDel);
      }
    }
    cmdList = cmdList->nextPtr;
  } while (cmdList != NULL);
}

/*
 *----------------------------------------------------------------------
 * RemoveFromObjectMixinsOf --
 *
 *    Removes the class of the given command from the isObjectMixinOf list of
 *    the class of each command in the given list.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static void RemoveFromObjectMixinsOf(Tcl_Command cmd, NsfCmdList *cmdList)
  nonnull(1) nonnull(2);

static void
RemoveFromObjectMixinsOf(Tcl_Command cmd, NsfCmdList *cmdList) {

  nonnull_assert(cmd != NULL);
  nonnull_assert(cmdList != NULL);

  do {
    const NsfClass *class = NsfGetClassFromCmdPtr(cmdList->cmdPtr);
    NsfClassOpt    *clopt = (class != NULL) ? class->opt : NULL;

    if (clopt != NULL) {
      NsfCmdList *del = CmdListFindCmdInList(cmd, clopt->isObjectMixinOf);

      if (del != NULL) {
        /* fprintf(stderr, "Removing object %s from isObjectMixinOf of Class %s\n",
           ObjectName(object), ObjStr(NsfGetClassFromCmdPtr(cmdList->cmdPtr)->object.cmdName)); */
        del = CmdListRemoveFromList(&clopt->isObjectMixinOf, del);
        CmdListDeleteCmdListEntry(del, GuardDel);
      }
    } /* else fprintf(stderr, "CleanupDestroyObject %s: NULL pointer in mixins!\n", ObjectName(object)); */
    cmdList = cmdList->nextPtr;
  } while(likely(cmdList != NULL));
}

/*
 *----------------------------------------------------------------------
 * RemoveFromClassmixins --
 *
 *    Removes the class of the given command from the class mixins list of the
 *    class of each command in the given list.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static void RemoveFromClassmixins(Tcl_Command cmd, NsfCmdList *cmdList)
  nonnull(1) nonnull(2);

static void
RemoveFromClassmixins(Tcl_Command cmd, NsfCmdList *cmdList) {

  nonnull_assert(cmd != NULL);
  nonnull_assert(cmdList != NULL);

  do {
    NsfClass    *class = NsfGetClassFromCmdPtr(cmdList->cmdPtr);
    NsfClassOpt *clopt = (class != NULL) ? class->opt : NULL;

    if (clopt != NULL) {
      NsfCmdList *del = CmdListFindCmdInList(cmd, clopt->classMixins);

      if (del != NULL) {
        /* fprintf(stderr, "Removing class %s from mixins of object %s\n",
           ClassName(class), ObjStr(NsfGetObjectFromCmdPtr(cmdList->cmdPtr)->cmdName)); */
        del = CmdListRemoveFromList(&clopt->classMixins, del);
        CmdListDeleteCmdListEntry(del, GuardDel);
        if (class->object.mixinOrder != NULL) {
          MixinResetOrder(&class->object);
        }
      }
    }
    cmdList = cmdList->nextPtr;
  } while (likely(cmdList != NULL));
}

/*
 *----------------------------------------------------------------------
 * RemoveFromObjectMixins --
 *
 *    Removes the class of the given command from the object mixin list of the
 *    class of each command in the given list.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void RemoveFromObjectMixins(Tcl_Command cmd, NsfCmdList *cmdList)
  nonnull(1) nonnull(2);

static void
RemoveFromObjectMixins(Tcl_Command cmd, NsfCmdList *cmdList) {

  nonnull_assert(cmd != NULL);
  nonnull_assert(cmdList != NULL);

  do {
    NsfObject    *object = NsfGetObjectFromCmdPtr(cmdList->cmdPtr);
    NsfObjectOpt *objopt = (object != 0) ? object->opt : NULL;

    if (objopt != NULL) {
      NsfCmdList *del = CmdListFindCmdInList(cmd, objopt->objMixins);

      if (del != NULL) {
        /* fprintf(stderr, "Removing class %s from mixins of object %s\n",
           ClassName(del->clorobj), ObjStr(NsfGetObjectFromCmdPtr(cmdList->cmdPtr)->cmdName)); */
        del = CmdListRemoveFromList(&objopt->objMixins, del);
        CmdListDeleteCmdListEntry(del, GuardDel);
        if (object->mixinOrder != NULL) {
          MixinResetOrder(object);
        }
      }
    }
    cmdList = cmdList->nextPtr;
  } while (likely(cmdList != NULL));
}


/*
 *----------------------------------------------------------------------
 * ResetOrderOfObjectsUsingThisClassAsObjectMixin --
 *
 *    Resets the mixin order for each object this class is mixed into.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void ResetOrderOfObjectsUsingThisClassAsObjectMixin(const NsfClass *class)
  nonnull(1);

static void
ResetOrderOfObjectsUsingThisClassAsObjectMixin(const NsfClass *class) {

  /*fprintf(stderr, "ResetOrderOfObjectsUsingThisClassAsObjectMixin %s - %p\n",
    ClassName(class), class->opt);*/

  nonnull_assert(class != NULL);

  if (class->opt != NULL) {
    const NsfCmdList *ml;

    for (ml = class->opt->isObjectMixinOf; ml != NULL; ml = ml->nextPtr) {
      NsfObject *object = NsfGetObjectFromCmdPtr(ml->cmdPtr);

      if (object != NULL) {
        if (object->mixinOrder != NULL) {
          MixinResetOrder(object);
        }
        object->flags &= ~NSF_MIXIN_ORDER_VALID;
      }
    }
  }
}

/*
 *----------------------------------------------------------------------
 * MixinInvalidateObjOrders --
 *
 *    Invalidates the current mixin order for each instance of the class and
 *    the class hierarchy under it.  Typically called when the class hierarchy
 *    or the class mixins have changed.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static void MixinInvalidateObjOrders(NsfClasses *subClasses)
  nonnull(1);

static void
MixinInvalidateObjOrders(NsfClasses *subClasses) {

  nonnull_assert(subClasses != NULL);

  /*
   * Iterate through the subclass hierarchy.
   */
  do {
    Tcl_HashSearch       hSrch;
    const Tcl_HashEntry *hPtr;
    Tcl_HashTable       *instanceTablePtr;

    /*
     * Reset mixin order for each object his class is mixed into.
     */
    ResetOrderOfObjectsUsingThisClassAsObjectMixin(subClasses->cl);

    if (subClasses->cl->parsedParamPtr != NULL) {
      ParsedParamFree(subClasses->cl->parsedParamPtr);
      subClasses->cl->parsedParamPtr = NULL;
    }

    instanceTablePtr = &subClasses->cl->instances;
    for (hPtr = Tcl_FirstHashEntry(instanceTablePtr, &hSrch);
         hPtr != NULL;
         hPtr = Tcl_NextHashEntry(&hSrch)) {
      NsfObject *object = (NsfObject *)Tcl_GetHashKey(instanceTablePtr, hPtr);

      assert(object != NULL);

      if (likely((object->flags & NSF_DURING_DELETE) == 0u)
          && ((object->flags & NSF_MIXIN_ORDER_DEFINED_AND_VALID) != 0u)
          ) {
        MixinResetOrder(object);
        object->flags &= ~NSF_MIXIN_ORDER_VALID;
      }
    }
    subClasses = subClasses->nextPtr;
  } while (subClasses != NULL);

}

/*
 *----------------------------------------------------------------------
 * MixinComputeDefined --
 *
 *    Computes the mixin order for the given object and adjusts the mixin flags
 *    accordingly. The mixin order is one of:
 *
 *       DEFINED
 *            The instance has mixins.
 *       NONE
 *            The instance has no mixins.
 *       INVALID
 *            A class restructuring has occurred.  It is not clear whether
 *            mixins are defined or not.
 *
 *    If the mixin order is INVALID, MixinComputeDefined() can compute the
 *    order and set the instance to DEFINED or NONE.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Might alter the mixin order.
 *
 *----------------------------------------------------------------------
 */
static void
MixinComputeDefined(Tcl_Interp *interp, NsfObject *object) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  MixinComputeOrder(interp, object);
  object->flags |= NSF_MIXIN_ORDER_VALID;
  if (object->mixinOrder != NULL) {
    object->flags |= NSF_MIXIN_ORDER_DEFINED;
  } else {
    object->flags &= ~NSF_MIXIN_ORDER_DEFINED;
  }
}

/*
 *----------------------------------------------------------------------
 * ComputePrecedenceList --
 *
 *    Returns a precedence list for the given object, which may be NULL due to
 *    filtering.  The precedence list can optionally include the mixins and the
 *    root class. If pattern is given it is used to filter the list.  The
 *    caller must use NsfClassListFree() to free the resulting list.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    Allocates list elements.
 *
 *----------------------------------------------------------------------
 */

static NsfClasses *ComputePrecedenceList(Tcl_Interp *interp, NsfObject *object,
                                         const char *pattern,
                                         bool withMixins, bool withRootClass)
  nonnull(1) nonnull(2);

static NsfClasses *
ComputePrecedenceList(Tcl_Interp *interp, NsfObject *object,
                      const char *pattern,
                      bool withMixins, bool withRootClass) {
  NsfClasses *precedenceList = NULL, *pcl, **npl = &precedenceList;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  if (withMixins) {
    if ((object->flags & NSF_MIXIN_ORDER_VALID) == 0u) {
      MixinComputeDefined(interp, object);
    }
    if ((object->flags & NSF_MIXIN_ORDER_DEFINED_AND_VALID) != 0u) {
      NsfCmdList *ml;

      for (ml = object->mixinOrder; ml; ml = ml->nextPtr) {
        NsfClass *mixin = NsfGetClassFromCmdPtr(ml->cmdPtr);

        if ((pattern != NULL)
            && (mixin != NULL)
            && !Tcl_StringMatch(ClassName(mixin), pattern)) {
          continue;
        }
        npl = NsfClassListAdd(npl, mixin, NULL);
      }
    }
  }

  pcl = PrecedenceOrder(object->cl);
  for (; pcl != NULL; pcl = pcl->nextPtr) {
    if (!withRootClass && IsRootClass(pcl->cl)) {
      continue;
    }
    if (pattern != NULL && !Tcl_StringMatch(ClassName(pcl->cl), pattern)) {
      continue;
    }
    npl = NsfClassListAdd(npl, pcl->cl, NULL);
  }
  return precedenceList;
}

/*
 *----------------------------------------------------------------------
 * SeekCurrent --
 *
 *    Finds the given command in the given list and returns the next
 *    entry, or NULL if the command is not in the list.
 *
 *    Returns the first entry if the given cmd is NULL.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static NsfCmdList *SeekCurrent(const Tcl_Command cmd, register NsfCmdList *cmdListPtr)
  nonnull(2) NSF_pure;

static NsfCmdList *
SeekCurrent(const Tcl_Command cmd, register NsfCmdList *cmdListPtr) {

  nonnull_assert(cmdListPtr != NULL);

  if (cmd != NULL) {
    do {
      if (cmdListPtr->cmdPtr == cmd) {
        return cmdListPtr->nextPtr;
      }
      cmdListPtr = cmdListPtr->nextPtr;
    } while  likely(cmdListPtr != NULL);

    return NULL;
  }
  return cmdListPtr;
}

/*
 *----------------------------------------------------------------------
 * CanInvokeMixinMethod --
 *
 *    Returns TCL_OK if the given cmd may be dispatched through a mixin, and
 *    NSF_CHECK_FAILED otherwise.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static int CanInvokeMixinMethod(Tcl_Interp *interp, NsfObject *object, Tcl_Command cmd, NsfCmdList *cmdList)
  nonnull(1) nonnull(2) nonnull(4);

static int
CanInvokeMixinMethod(Tcl_Interp *interp, NsfObject *object, Tcl_Command cmd, NsfCmdList *cmdList) {
  int result = TCL_OK;
  unsigned int cmdFlags = (unsigned int)Tcl_Command_flags(cmd);

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(cmdList != NULL);

  if ((cmdFlags & NSF_CMD_CALL_PRIVATE_METHOD) != 0u ||
      ((cmdFlags & NSF_CMD_CLASS_ONLY_METHOD) != 0u && !NsfObjectIsClass(object))) {
    /*
     * The command is designed to be dispatched on an object.  Dispatching it
     * on a class might cause a crash.  Skip it.
     */
    return NSF_CHECK_FAILED;
  }

  if ((cmdList->clientData != NULL) && !RUNTIME_STATE(interp)->guardCount) {
    /*fprintf(stderr, "guard call\n");*/
    result = GuardCall(object, interp, (Tcl_Obj *)cmdList->clientData, NULL);
  }

  return result;
}


/*
 *----------------------------------------------------------------------
 * MixinSearchProc --
 *
 *    Searches by name for a method in the mixin list of the given object and
 *    stores the result, possibly NULL, in cmdPtr.  Also stores the last
 *    inspected command currentCmdPtr.  On success, stores the class in
 *    *classPtr. Used when dispatching the overriden method via [next].
 *    Depending on the state of the mixin stack, the search either starts at
 *    the beginning or at the last dispatched overridden method in the mixin
 *    path.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int MixinSearchProc(
    Tcl_Interp *interp, NsfObject *object,
    const char *methodName,
    NsfClass **classPtr, Tcl_Command *currentCmdPtr, Tcl_Command *cmdPtr
) nonnull(1) nonnull(2) nonnull(3) nonnull(4) nonnull(5) nonnull(6);

static int
MixinSearchProc(
    Tcl_Interp *interp, NsfObject *object,
    const char *methodName,
    NsfClass **classPtr, Tcl_Command *currentCmdPtr, Tcl_Command *cmdPtr
) {
  Tcl_Command cmd = NULL;
  NsfCmdList *cmdList;
  NsfClass   *class = NULL;
  int         result = TCL_OK;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodName != NULL);
  nonnull_assert(classPtr != NULL);
  nonnull_assert(currentCmdPtr != NULL);
  nonnull_assert(cmdPtr != NULL);

  assert(object->mixinStack != NULL);

  /*
   * Ensure that the mixin order is valid.
   */
  assert((object->flags & NSF_MIXIN_ORDER_VALID) != 0u);

  if (object->mixinOrder == NULL) {
    return TCL_OK;
  }

  cmdList = SeekCurrent(object->mixinStack->currentCmdPtr, object->mixinOrder);
  RUNTIME_STATE(interp)->currentMixinCmdPtr = (cmdList != NULL) ? cmdList->cmdPtr : NULL;

  /*fprintf(stderr, "searching for '%s' in %p\n", methodName, cmdList);
  CmdListPrint(interp, "MixinSearch CL = \n", cmdList);*/

  if (unlikely((*classPtr != NULL) && (*cmdPtr != NULL))) {
    Tcl_Command lastCmdPtr = NULL;

    /*fprintf(stderr, "... new branch\n");*/

    for (; cmdList != NULL; cmdList = cmdList->nextPtr) {
      NsfClass *class1;

      /*
       * Ignore deleted commands.
       */
      if (((unsigned int)Tcl_Command_flags(cmdList->cmdPtr) & CMD_IS_DELETED) != 0u) {
        continue;
      }

      class1 = NsfGetClassFromCmdPtr(cmdList->cmdPtr);
      assert(class1 != NULL);
      lastCmdPtr = cmdList->cmdPtr;

      if (class1 == *classPtr) {
        /*
         * Do guards and permissions allow this method to be invoked?
         */
        result = CanInvokeMixinMethod(interp, object, *cmdPtr, cmdList);

        if (likely(result == TCL_OK)) {
          class = class1;
        } else if (result == NSF_CHECK_FAILED) {
          result = TCL_OK;
        }
        /*
         * Regardless of the result, stop searching through the mixin classes
         * here.
         */
        break;
      }
    }

    if (class != NULL) {
      assert(cmdList != NULL);
      /*
       * Success. Return class and cmdList->cmdPtr;
       */
      *currentCmdPtr = cmdList->cmdPtr;
      /*fprintf(stderr, "... mixinsearch success returns %p (class %s)\n", cmd, ClassName(class));*/

    } else {
      /*
       * No absolute entry in the mixins.  To flag that the mixin list should
       * not be started again when dispatching the next method, set the
       * currentCmdPtr on the mixin stack to the last entry
       */
      *cmdPtr = NULL;
      *currentCmdPtr = lastCmdPtr;
      /*fprintf(stderr, "... mixinsearch success failure %p (class %s)\n", cmd, ClassName(class));*/
    }

    return result;

  } else {

    for (; cmdList; cmdList = cmdList->nextPtr) {
      /*
       * Ignore deleted commands.
       */
      if (((unsigned int)Tcl_Command_flags(cmdList->cmdPtr) & CMD_IS_DELETED) != 0u) {
        continue;
      }
      class = NsfGetClassFromCmdPtr(cmdList->cmdPtr);
      assert(class != NULL);
      /*
        fprintf(stderr, "+++ MixinSearch %s->%s in %p cmdPtr %p clientData %p\n",
        ObjectName(object), methodName, cmdList,
        cmdList->cmdPtr, cmdList->clientData);
      */
      cmd = FindMethod(class->nsPtr, methodName);
      if (cmd == NULL) {
        continue;
      }

      result = CanInvokeMixinMethod(interp, object, cmd, cmdList);

      if (unlikely(result == TCL_ERROR)) {
        return result;
      } else if (result == NSF_CHECK_FAILED) {
        result = TCL_OK;
        cmd = NULL;
        continue;
      }

      /*
       * Return the class and cmdPtr.
       */
      *classPtr = class;
      *currentCmdPtr = cmdList->cmdPtr;
      /*fprintf(stderr, "mixinsearch returns %p (cl %s)\n", cmd, ClassName(class));*/
      break;
    }

  }
  *cmdPtr = cmd;
  return result;
}

/*
 * info option for mixins and class mixins.
 */
static int MixinInfo(
    Tcl_Interp *interp, const NsfCmdList *m, const char *pattern,
    bool withGuards, const NsfObject *matchObject
) nonnull(1);

static int
MixinInfo(
    Tcl_Interp *interp, const NsfCmdList *m, const char *pattern,
    bool withGuards, const NsfObject *matchObject
) {
  Tcl_Obj *list = Tcl_NewListObj(0, NULL);

  nonnull_assert(interp != NULL);

  /*fprintf(stderr, "   mixin info m=%p, pattern %s, matchObject %p\n",
    m, pattern, matchObject);*/

  while (m != NULL) {
    const NsfClass *mixinClass = NsfGetClassFromCmdPtr(m->cmdPtr);

    /* fprintf(stderr, "   mixin info m=%p, next=%p, pattern %s, matchObject %p\n",
       m, m->next, pattern, matchObject);*/

    if (mixinClass != NULL &&
        (pattern == NULL
         || (matchObject != NULL && &(mixinClass->object) == matchObject)
         || (matchObject == NULL && Tcl_StringMatch(ObjStr(mixinClass->object.cmdName), pattern)))) {
      if (withGuards && (m->clientData != NULL)) {
        Tcl_Obj *l = Tcl_NewListObj(0, NULL);
        Tcl_Obj *g = (Tcl_Obj *) m->clientData;

        Tcl_ListObjAppendElement(interp, l, mixinClass->object.cmdName);
        Tcl_ListObjAppendElement(interp, l, NsfGlobalObjs[NSF_GUARD_OPTION]);
        Tcl_ListObjAppendElement(interp, l, g);
        Tcl_ListObjAppendElement(interp, list, l);
      } else {
        Tcl_ListObjAppendElement(interp, list, mixinClass->object.cmdName);
      }
      if (matchObject != NULL) {
        break;
      }
    }
    m = m->nextPtr;
  }

  Tcl_SetObjResult(interp, list);
  return TCL_OK;
}

/*
 * info option for mixinOfs and isClassMixinOf.
 */

static Tcl_Command MixinSearchMethodByName(NsfCmdList *mixinList, const char *name, NsfClass **classPtr)
  nonnull(1) nonnull(2) nonnull(3);

static Tcl_Command
MixinSearchMethodByName(NsfCmdList *mixinList, const char *name, NsfClass **classPtr) {
  Tcl_Command cmd;

  nonnull_assert(mixinList != NULL);
  nonnull_assert(name != NULL);
  nonnull_assert(classPtr != NULL);

  do {
    NsfClass *foundClass = NsfGetClassFromCmdPtr(mixinList->cmdPtr);

    if ((foundClass != NULL) && SearchCMethod(foundClass, name, &cmd)) {
      *classPtr = foundClass;
      return cmd;
    }
    mixinList = mixinList->nextPtr;
  } while (mixinList != NULL);

  return NULL;
}


/*
 *  Filter-Commands
 */

/*
 * To search through object and class filters:  First interpret the given name
 * as a fully-qualified method name.  If no method is found, search by
 * fully-qualified name. Otherwise search for by simple name following the
 * inheritance order: object (only for per-object filters), class, metaclass.
 */

static Tcl_Command FilterSearch(const char *name, NsfObject *startingObject,
             NsfClass *startingClass, NsfClass **classPtr)
  nonnull(1) nonnull(4);

static Tcl_Command
FilterSearch(const char *name, NsfObject *startingObject,
             NsfClass *startingClass, NsfClass **classPtr) {
  Tcl_Command cmd = NULL;

  nonnull_assert(name != NULL);
  nonnull_assert(classPtr != NULL);

  if (startingObject != NULL) {
    NsfObjectOpt *opt = startingObject->opt;
    /*
     * A filter for an object may be defined on its class, its superclass
     * hierarchy, or its class mixins.  When searching the class hierarchy
     * start with the class of the object.
     */
    startingClass = startingObject->cl;

    /*
     * Search for filters of the mixins of the object.
     */
    if (opt != NULL
        && opt->objMixins != NULL
        && (cmd = MixinSearchMethodByName(opt->objMixins, name, classPtr))
       ) {
      return cmd;
    }
  }

  /*
   * Search for the filters of each class and its mixins.
   */
  if (startingClass != NULL) {
    NsfClassOpt *opt = startingClass->opt;
    if (opt != NULL && opt->classMixins != NULL) {
      if ((cmd = MixinSearchMethodByName(opt->classMixins, name, classPtr))) {
        return cmd;
      }
    }
  }

  /*
   * Search for object procs that are used as filters.
   */
  if ((startingObject != NULL) && (startingObject->nsPtr != NULL)) {
    /*fprintf(stderr, "search filter %s as proc \n", name);*/
    if ((cmd = FindMethod(startingObject->nsPtr, name))) {
      *classPtr = (NsfClass *)startingObject;
      return cmd;
    }
  }

  /*
   * No filter or mixins on obj. Search class.
   */
  if (startingClass != NULL) {
    *classPtr = SearchCMethod(startingClass, name, &cmd);
    if (*classPtr == NULL) {
      /*
       * Still nothing. Search the metaclass.
       */
      *classPtr = SearchCMethod(startingClass->object.cl, name, &cmd);
    }
  }
  return cmd;
}

/*
 * Filter Guards
 */

/*
 *----------------------------------------------------------------------
 * GuardCheck --
 *
 *    Returns NSF_CHECK_FAILED if the condition isn't true in the environment
 *    of the current call frame, and the result of the evaluation of the
 *    condition otherwise.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static int GuardCheck(Tcl_Interp *interp, Tcl_Obj *guardObj)
  nonnull(1) nonnull(2);

static int
GuardCheck(Tcl_Interp *interp, Tcl_Obj *guardObj) {
  NsfRuntimeState *rst;
  int              result;

  nonnull_assert(interp != NULL);
  nonnull_assert(guardObj != NULL);

  /*
   * If there is more than one filter guard for this filter, i.e. filter
   * guards are inherited, then they are OR combined: If any check succeeds,
   * return TCL_OK.
   */

  /*fprintf(stderr, "checking guard **%s**\n", ObjStr(guardObj));*/
  rst = RUNTIME_STATE(interp);
  rst->guardCount++;
  result = CheckConditionInScope(interp, guardObj);
  rst->guardCount--;

  /*fprintf(stderr, "checking guard **%s** returned rc=%d\n", ObjStr(guardObj), rc);*/

  if (likely(result == TCL_OK)) {
    /* fprintf(stderr, " +++ OK\n"); */

  } else if (unlikely(result == TCL_ERROR)) {
    Tcl_Obj *sr = Tcl_GetObjResult(interp);

    INCR_REF_COUNT(sr);
    NsfPrintError(interp, "Guard error: '%s'\n%s", ObjStr(guardObj), ObjStr(sr));
    DECR_REF_COUNT(sr);

  } else {
    /*
      fprintf(stderr, " +++ FAILED\n");
    */
    result = NSF_CHECK_FAILED;
  }
  return result;
}

/*
  static void
  GuardPrint(Tcl_Interp *interp, ClientData clientData) {
  Tcl_Obj *guardObj = (Tcl_Obj *) clientData;
  fprintf(stderr, " +++ <GUARDS> \n");
  if (guardObj != NULL) {
  fprintf(stderr, "   *     %s \n", ObjStr(guardObj));
  }
  fprintf(stderr, " +++ </GUARDS>\n");
  }
*/

static void
GuardDel(NsfCmdList *guardList) {

  nonnull_assert(guardList != NULL);

  /*fprintf(stderr, "GuardDel %p clientData = %p\n",
    guardList, (guardList != NULL) ? guardList->clientData : NULL);*/

  if (guardList->clientData != NULL) {
    DECR_REF_COUNT2("guardObj", (Tcl_Obj *)guardList->clientData);
    guardList->clientData = NULL;
  }
}

NSF_INLINE static void
GuardAdd(NsfCmdList *guardList, Tcl_Obj *guardObj) {

  nonnull_assert(guardList != NULL);
  nonnull_assert(guardObj != NULL);

  GuardDel(guardList);
  if (strlen(ObjStr(guardObj)) > 0) {
    INCR_REF_COUNT2("guardObj", guardObj);
    guardList->clientData = guardObj;
    /*fprintf(stderr, "guard added to %p cmdPtr=%p, clientData= %p\n",
      guardList, guardList->cmdPtr, guardList->clientData);
    */
  }
}

static int
GuardCall(NsfObject *object, Tcl_Interp *interp, Tcl_Obj *guardObj, NsfCallStackContent *cscPtr) {
  int result = TCL_OK;
  Tcl_Obj *res = Tcl_GetObjResult(interp); /* save the result */
  CallFrame frame, *framePtr = &frame;

  nonnull_assert(object != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(guardObj != NULL);

  INCR_REF_COUNT(res);

  /*
   * Push a fake call frame so that, e.g. a "self calledproc" and other methods
   * in the guard behave as they do in the proc.
   */
  if (cscPtr != NULL) {
    Nsf_PushFrameCsc(interp, cscPtr, framePtr);
  } else {
    Nsf_PushFrameObj(interp, object, framePtr);
  }
  result = GuardCheck(interp, guardObj);

  if (cscPtr != NULL) {
    Nsf_PopFrameCsc(interp, framePtr);
  } else {
    Nsf_PopFrameObj(interp, framePtr);
  }

  if (result != TCL_ERROR) {
    Tcl_SetObjResult(interp, res);  /* restore the result */
  }

  DECR_REF_COUNT(res);
  return result;
}

/*
 *----------------------------------------------------------------------
 * GuardAddFromDefinitionList --
 *
 *    Adds the given guard to the given list if the guard exists in the given
 *    list of guards and the guard has client data.
 *
 * Results:
 *    True if the guard was found in the list of guards.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static bool GuardAddFromDefinitionList(NsfCmdList *dest, Tcl_Command interceptorCmd,
                                      NsfCmdList *interceptorDefList)
  nonnull(1) nonnull(2) nonnull(3);

static bool
GuardAddFromDefinitionList(NsfCmdList *dest, Tcl_Command interceptorCmd,
                           NsfCmdList *interceptorDefList) {
  NsfCmdList *h;

  nonnull_assert(interceptorCmd != NULL);
  nonnull_assert(dest != NULL);
  nonnull_assert(interceptorDefList != NULL);

  h = CmdListFindCmdInList(interceptorCmd, interceptorDefList);
  if (h != NULL) {
    if (h->clientData != NULL) {
      GuardAdd(dest, (Tcl_Obj *) h->clientData);
    }
    return NSF_TRUE;
  }

  return NSF_FALSE;
}

/*
 *----------------------------------------------------------------------
 * GuardAddInheritedGuards --
 *
 *    Finds the given command in the filters of the given object or its
 *    superclass hierarchy and adds it to the given list if found.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void GuardAddInheritedGuards(Tcl_Interp *interp, NsfCmdList *dest,
                                    NsfObject *object, Tcl_Command filterCmd)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static void
GuardAddInheritedGuards(Tcl_Interp *interp, NsfCmdList *dest,
                        NsfObject *object, Tcl_Command filterCmd) {
  NsfClasses   *pl;
  bool          guardAdded = NSF_FALSE;
  NsfObjectOpt *opt;

  nonnull_assert(filterCmd != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(dest != NULL);
  nonnull_assert(object != NULL);

  /*
   * Search for the guard in classes mixed into the given object.
   */
  if (((object->flags & NSF_MIXIN_ORDER_VALID)) == 0u) {
    MixinComputeDefined(interp, object);
  }
  if ((object->flags & NSF_MIXIN_ORDER_DEFINED_AND_VALID) != 0u) {
    NsfCmdList *ml;

    for (ml = object->mixinOrder; ml != NULL && !guardAdded; ml = ml->nextPtr) {
      NsfClass *mixin = NsfGetClassFromCmdPtr(ml->cmdPtr);

      if (mixin != NULL && mixin->opt != NULL && mixin->opt->classFilters != NULL) {
        guardAdded = GuardAddFromDefinitionList(dest, filterCmd, mixin->opt->classFilters);
      }
    }
  }

  /*
   * Search for the guard in filters of the object.
   */
  opt = object->opt;
  if (!guardAdded && (opt != NULL) && (opt->objFilters != NULL)) {
    guardAdded = GuardAddFromDefinitionList(dest, filterCmd, opt->objFilters);
  }

  if (!guardAdded) {
    /*
     * Search for the guard in the superclass hierarchy of the object.
     */
    for (pl = PrecedenceOrder(object->cl); !guardAdded && (pl != NULL); pl = pl->nextPtr) {
      NsfClassOpt *clopt = pl->cl->opt;
      if (clopt != NULL && clopt->classFilters != NULL) {
        guardAdded = GuardAddFromDefinitionList(dest, filterCmd, clopt->classFilters);
      }
    }

    /*
     * if this is not a registered filter, it is an inherited filter, like:
     *   Class create A
     *   A method f ...
     *   Class create B -superclass A
     *   B method {{f {<guard>}}}
     *   B filter f
     * -> get the guard from the filter that inherits it (here B->f)
     */
    if (!guardAdded) {
      NsfCmdList *registeredFilter =
        CmdListFindNameInList(interp, (char *) Tcl_GetCommandName(interp, filterCmd),
                              object->filterOrder);
      if (registeredFilter && registeredFilter->clientData) {
        GuardAdd(dest, (Tcl_Obj *) registeredFilter->clientData);
      }
    }
  }
}

/*
 *----------------------------------------------------------------------
 * GuardList --
 *
 *    Sets the interp result to the named guard if the guard is in the given
 *    list, which might be NULL.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int GuardList(Tcl_Interp *interp, NsfCmdList *guardList, const char *interceptorName)
  nonnull(1) nonnull(3);

static int
GuardList(Tcl_Interp *interp, NsfCmdList *guardList, const char *interceptorName) {

  nonnull_assert(interp != NULL);
  nonnull_assert(interceptorName != NULL);

  if (guardList != NULL) {
    /*
     * Try to find simple name first.
     */
    NsfCmdList *h = CmdListFindNameInList(interp, interceptorName, guardList);
    if (h == NULL) {
      /*
       * Maybe it is a qualified name.
       */
      Tcl_Command cmd = NSFindCommand(interp, interceptorName);
      if (cmd != NULL) {
        h = CmdListFindCmdInList(cmd, guardList);
      }
    }
    if (h != NULL) {
      Tcl_ResetResult(interp);
      if (h->clientData != NULL) {
        Tcl_Obj *g = (Tcl_Obj *) h->clientData;
        Tcl_SetObjResult(interp, g);
      }
      return TCL_OK;
    }
  }
  return NsfPrintError(interp, "info guard: can't find filter/mixin %s", interceptorName);
}

/*
 *----------------------------------------------------------------------
 * FilterAddActive --
 *
 *    Adds the given method name to the set of names of filters active in the
 *    current interpreter.
 *
 *    TODO: Remove the name from the set when a filter is removed.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void FilterAddActive(Tcl_Interp *interp, const char *methodName)
  nonnull(1) nonnull(2);

static void
FilterAddActive(Tcl_Interp *interp, const char *methodName) {
  Tcl_HashEntry *hPtr;
  int            newItem;

  nonnull_assert(interp != NULL);
  nonnull_assert(methodName != NULL);

  hPtr = Tcl_CreateHashEntry(&RUNTIME_STATE(interp)->activeFilterTablePtr, methodName, &newItem);
  if (newItem != 0) {
    Tcl_SetHashValue(hPtr, INT2PTR(1));
  } else {
    long count = PTR2INT(Tcl_GetHashValue(hPtr));
    Tcl_SetHashValue(hPtr, INT2PTR(count+1));
  }
}

/*
 *----------------------------------------------------------------------
 * FilterIsActive --
 *
 *    Determines whether the named method is in the set of names of filters
 *    active in the current interpreter.
 *
 * Results:
 *    True if the name is successfully added.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static bool FilterIsActive(Tcl_Interp *interp, const char *methodName)
  nonnull(1) nonnull(2);

static bool
FilterIsActive(Tcl_Interp *interp, const char *methodName) {
  const Tcl_HashEntry *hPtr;

  nonnull_assert(interp != NULL);
  nonnull_assert(methodName != NULL);

  hPtr = Tcl_CreateHashEntry(&RUNTIME_STATE(interp)->activeFilterTablePtr, methodName, NULL);
  return (hPtr != NULL);
}

/*
 *----------------------------------------------------------------------
 * FiltersDefined --
 *
 *    Returns the number of names of active filters.
 *
 * Results:
 *    A positive number.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int FiltersDefined(Tcl_Interp *interp)
  nonnull(1) NSF_pure;

static int
FiltersDefined(Tcl_Interp *interp) {

  nonnull_assert(interp != NULL);

  return Tcl_HashSize(&RUNTIME_STATE(interp)->activeFilterTablePtr);
}


/*
 *----------------------------------------------------------------------
 * FilterAdd --
 *
 *    Appends a filter to filter list of an object if it isn't
 *    already in the list.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Sets the interp result if there is an error.
 *
 *----------------------------------------------------------------------
 */
static int FilterAdd(Tcl_Interp *interp, NsfCmdList **filterList, Tcl_Obj *filterregObj,
                     NsfObject *startingObject, NsfClass *startingClass)
  nonnull(1) nonnull(2) nonnull(3);

static int
FilterAdd(Tcl_Interp *interp, NsfCmdList **filterList, Tcl_Obj *filterregObj,
          NsfObject *startingObject, NsfClass *startingClass) {
  Tcl_Obj     *filterObj = NULL;
  Tcl_Obj     *guardObj = NULL;
  Tcl_Command  cmd = NULL;
  NsfClass    *class = NULL;
  int          result = TCL_OK;

  nonnull_assert(interp != NULL);
  nonnull_assert(filterList != NULL);
  nonnull_assert(filterregObj != NULL);

  /*
   * Convert the object to NsfFilterregObjType if needed.
   */
  if (filterregObj->typePtr != &NsfFilterregObjType) {
    /*fprintf(stderr, "FilterAdd: convert %s in FilterAdd\n", ObjStr(filterregObj));*/
    if (Tcl_ConvertToType(interp, filterregObj, &NsfFilterregObjType) != TCL_OK) {
      result = TCL_ERROR;
    }
  } else {
    /*fprintf(stderr, "FilterAdd: %s already converted\n", ObjStr(filterregObj));*/
  }

  if (result == TCL_OK) {
    result = NsfFilterregGet(interp, filterregObj, &filterObj, &guardObj);

    if (result == TCL_OK) {
      const char *filterName = ObjStr(filterObj);

      cmd = FilterSearch(filterName, startingObject, startingClass, &class);
      if (cmd == NULL) {
        if (startingObject != NULL) {
          result = NsfPrintError(interp, "object filter: can't find filterproc '%s' on %s ",
                                 filterName, ObjectName(startingObject));
        } else {
          result = NsfPrintError(interp, "class filter: can't find filterproc '%s' on %s ",
                                 filterName, ClassName(startingClass));
        }
        assert(result == TCL_ERROR);
      }
    }
  }

  if (result == TCL_OK) {
    NsfCmdList *new;

    /*fprintf(stderr, " +++ adding filter %s cl %p\n", ObjStr(nameObj), class);*/

    new = CmdListAdd(filterList, cmd, class,
                     /*noDuplicates*/ NSF_TRUE, NSF_TRUE);
    FilterAddActive(interp, ObjStr(filterObj));

    if (guardObj != NULL) {
      GuardAdd(new, guardObj);
    } else if (new->clientData != NULL) {
      GuardDel(new);
    }
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * FilterResetOrder --
 *
 *    Resets the filter order cached in obj->filterOrder.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static void FilterResetOrder(NsfObject *object)
  nonnull(1);

static void
FilterResetOrder(NsfObject *object) {

  nonnull_assert(object != NULL);

  CmdListFree(&object->filterOrder, GuardDel);
  object->filterOrder = NULL;
}

/*
 *----------------------------------------------------------------------
 * FilterSearchAgain --
 *
 *    For each filter in the given list, Search again in the given object and
 *    class for the filter, deleting filters that can no longer be found, and
 *    updating filter details for filters that are found.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static void FilterSearchAgain(Tcl_Interp *interp, NsfCmdList **filters,
                              NsfObject *startingObject, NsfClass *startingClass)
  nonnull(1) nonnull(2);

static void
FilterSearchAgain(Tcl_Interp *interp, NsfCmdList **filters,
                  NsfObject *startingObject, NsfClass *startingClass) {
  NsfCmdList *cmdList;

  nonnull_assert(interp != NULL);
  nonnull_assert(filters != NULL);

  CmdListRemoveDeleted(filters, GuardDel);
  cmdList = *filters;

  while (cmdList != NULL) {
    NsfCmdList *del = NULL;
    NsfClass   *class = NULL;
    const char *simpleName = Tcl_GetCommandName(interp, cmdList->cmdPtr);
    Tcl_Command cmd = FilterSearch(simpleName, startingObject, startingClass,
                                   &class);

    if (cmd == NULL) {
      del = CmdListRemoveFromList(filters, cmdList);
      /*
       * The actual deletion via CmdListDeleteCmdListEntry is deferred to the
       * end of the loop block. Otherwise, for del == cmdList, there is a risk
       * of an invalid pointer access.
       */
    } else if (cmd != cmdList->cmdPtr) {
      CmdListReplaceCmd(cmdList, cmd, class);
    }

    cmdList = cmdList->nextPtr;

    if (del != NULL) {
      CmdListDeleteCmdListEntry(del, GuardDel);
    }
  }
}

/*
 *----------------------------------------------------------------------
 * FilterInvalidateObjOrders --
 *
 *    Invalidates filters on all instances of the class classes in its subclass
 *    hierarchy. Necessary, e.g. when the class hierarchy or the class filters
 *    have changed.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static void FilterInvalidateObjOrders(Tcl_Interp *interp, NsfClasses *subClasses)
  nonnull(1) nonnull(2);

static void
FilterInvalidateObjOrders(Tcl_Interp *interp, NsfClasses *subClasses) {

  nonnull_assert(interp != NULL);
  nonnull_assert(subClasses != NULL);

  do {
    Tcl_HashSearch hSrch;
    const Tcl_HashEntry *hPtr;

    assert(subClasses->cl);

    hPtr = Tcl_FirstHashEntry(&subClasses->cl->instances, &hSrch);

    /*
     * Recalculate the command of each filter on the class.
     */
    if (subClasses->cl->opt != NULL) {
      FilterSearchAgain(interp, &subClasses->cl->opt->classFilters, NULL, subClasses->cl);
    }

    for (; hPtr != NULL; hPtr = Tcl_NextHashEntry(&hSrch)) {
      NsfObject *object = (NsfObject *)Tcl_GetHashKey(&subClasses->cl->instances, hPtr);

      FilterResetOrder(object);
      object->flags &= ~NSF_FILTER_ORDER_VALID;

      /*
       * Recalculate the command of each filter on the object.
       */
      if (object->opt != NULL) {
        FilterSearchAgain(interp, &object->opt->objFilters, object, NULL);
      }
    }
    subClasses = subClasses->nextPtr;
  } while (likely(subClasses != NULL));
}

/*
 *----------------------------------------------------------------------
 * FilterRemoveDependentFilterCmds --
 *
 *
 *    Removes from all subclasses all filters that refer to "removeClass".
 *    Used, e.g. to remove filters defined in a list of superclass from a
 *    dependent class.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
/*
 */
static void FilterRemoveDependentFilterCmds(NsfClass *removeClass, NsfClasses *subClasses)
  nonnull(1) nonnull(2);

static void
FilterRemoveDependentFilterCmds(NsfClass *removeClass, NsfClasses *subClasses) {

  nonnull_assert(removeClass != NULL);
  nonnull_assert(subClasses != NULL);

  /*fprintf(stderr, "FilterRemoveDependentFilterCmds removeClass %p %s\n",
    removeClass, ObjStr(removeClass->object.cmdName));*/

  do {
    Tcl_HashSearch hSrch;
    const Tcl_HashEntry *hPtr;
    NsfClassOpt   *opt;

    assert(subClasses->cl);
    hPtr = Tcl_FirstHashEntry(&subClasses->cl->instances, &hSrch);

    opt = subClasses->cl->opt;
    if (opt != NULL) {
      CmdListRemoveContextClassFromList(&opt->classFilters, removeClass, GuardDel);
    }
    for (; hPtr != NULL; hPtr = Tcl_NextHashEntry(&hSrch)) {
      NsfObject *object = (NsfObject *) Tcl_GetHashKey(&subClasses->cl->instances, hPtr);

      if (object->opt != NULL) {
        CmdListRemoveContextClassFromList(&object->opt->objFilters, removeClass, GuardDel);
      }
    }
    subClasses = subClasses->nextPtr;
  } while (subClasses != NULL);
}

/*
 *----------------------------------------------------------------------
 * MethodHandleObj --
 *
 *    Builds a methodHandle from a method name that is not fully qualified.
 *
 * Results:
 *    A new Tcl_Obj.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static Tcl_Obj * MethodHandleObj(NsfObject *object, int withPer_object, const char *methodName)
  nonnull(1) nonnull(3) returns_nonnull;

static Tcl_Obj *
MethodHandleObj(NsfObject *object, int withPer_object, const char *methodName) {
  Tcl_Obj *resultObj;

  nonnull_assert(object != NULL);
  nonnull_assert(methodName != NULL);
  assert(*methodName != ':');

  if (withPer_object == 1) {
    resultObj = Tcl_NewStringObj("", 0);
  } else {
    resultObj = Tcl_NewStringObj(nsfClassesPrefix, (int)nsfClassesPrefixLength);
  }
  Tcl_AppendObjToObj(resultObj, object->cmdName);
  Tcl_AppendStringsToObj(resultObj, "::", methodName, (char *) NULL);

  return resultObj;
}

/*
 *----------------------------------------------------------------------
 * FilterInfo --
 *
 *    Sets as the interp result the list of filters for the given command,
 *    optionally including either guards or method handles.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static int FilterInfo(Tcl_Interp *interp, NsfCmdList *f, const char *pattern,
                      bool withGuards, bool withMethodHandles)
  nonnull(1);

static int
FilterInfo(Tcl_Interp *interp, NsfCmdList *f, const char *pattern,
           bool withGuards, bool withMethodHandles) {
  Tcl_Obj *list = Tcl_NewListObj(0, NULL);

  nonnull_assert(interp != NULL);

  /*
   * If "withGuards" is active each item in the guard list is an unqualified
   * name and "withMethodHandles" has no effect.
   */
  if (withGuards) {
    withMethodHandles = NSF_FALSE;
  }

  while (f != NULL) {
    const char *simpleName = Tcl_GetCommandName(interp, f->cmdPtr);

    if (pattern == NULL || Tcl_StringMatch(simpleName, pattern)) {
      if (withGuards && (f->clientData != NULL)) {
        Tcl_Obj *innerList = Tcl_NewListObj(0, NULL);
        Tcl_Obj *g = (Tcl_Obj *) f->clientData;

        Tcl_ListObjAppendElement(interp, innerList,
                                 Tcl_NewStringObj(simpleName, -1));
        Tcl_ListObjAppendElement(interp, innerList, NsfGlobalObjs[NSF_GUARD_OPTION]);
        Tcl_ListObjAppendElement(interp, innerList, g);
        Tcl_ListObjAppendElement(interp, list, innerList);
      } else {
        if (withMethodHandles) {
          NsfClass *filterClass = f->clorobj;

          Tcl_ListObjAppendElement(interp, list,
                                   MethodHandleObj((NsfObject *)filterClass,
                                                   !NsfObjectIsClass(&filterClass->object), simpleName));
        } else {
          Tcl_ListObjAppendElement(interp, list, Tcl_NewStringObj(simpleName, -1));
        }
      }
    }
    f = f->nextPtr;
  }
  Tcl_SetObjResult(interp, list);
  return TCL_OK;
}


/*
 *----------------------------------------------------------------------
 * FilterComputeOrderFullList --
 *
 *    Adds the command of each given filter and the command of each class in
 *    the superclass hierarchy of the filter to the given list if it isn't
 *    already in the list.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void FilterComputeOrderFullList(
    Tcl_Interp *interp, NsfCmdList **filters,
    NsfCmdList **filterList
) nonnull(1) nonnull(2) nonnull(3);

static void
FilterComputeOrderFullList(
    Tcl_Interp *interp, NsfCmdList **filters,
    NsfCmdList **filterList
) {
  const NsfCmdList *f ;
  const NsfClasses *pl;
  NsfClass         *filterClass;

  nonnull_assert(interp != NULL);
  nonnull_assert(filters != NULL);
  nonnull_assert(filterList != NULL);

  /*
   * Ensure that no deleted command is in the filters list.
   */
  CmdListRemoveDeleted(filters, GuardDel);

  for (f = *filters; f != NULL; f = f->nextPtr) {
    const char *simpleName = Tcl_GetCommandName(interp, f->cmdPtr);

    filterClass = f->clorobj;
    CmdListAdd(filterList, f->cmdPtr, filterClass,
               /*noDuplicates*/ NSF_FALSE, NSF_TRUE);

    if (filterClass != NULL && !NsfObjectIsClass(&filterClass->object)) {
      /*
       * Get the class from the object to check for a filter on the object.
       */
      filterClass = ((NsfObject *)filterClass)->cl;
    }

    if (filterClass != NULL) {
      pl = PrecedenceOrder(filterClass);
      if (pl != NULL && pl->nextPtr != NULL) {
        /*
         * Don't search on the starting class again.
         */
        pl = pl->nextPtr;
        /*
         * search up the hierarchy.
         */
        for(; pl != NULL; pl = pl->nextPtr) {
          Tcl_Command pi = FindMethod(pl->cl->nsPtr, simpleName);

          if (pi != NULL) {
            CmdListAdd(filterList, pi, pl->cl,
                       /*noDuplicates*/ NSF_FALSE, NSF_TRUE);
            /*
              fprintf(stderr, " %s::%s, ", ClassName(pl->cl), simpleName);
            */
          }
        }
      }
    }
  }
  /*CmdListPrint(interp, "FilterComputeOrderFullList....\n", *filterList);*/
}

/*
 *----------------------------------------------------------------------
 * FilterComputeOrder --
 *
 *    Computes a linearized deduplicated order of filters on the given object.
 *    The precedence rule is that the last occurrence makes it into the final
 *    list (object->filterOrder).
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Updates interp result.
 *
 *----------------------------------------------------------------------
 */
static void FilterComputeOrder(Tcl_Interp *interp, NsfObject *object)
  nonnull(1) nonnull(2);

static void
FilterComputeOrder(Tcl_Interp *interp, NsfObject *object) {
  NsfCmdList *filterList = NULL, *next, *checker, *newList;
  NsfClasses *pl;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  if (object->filterOrder != NULL) {
    FilterResetOrder(object);
  }
  /*
    fprintf(stderr, "<Filter Order obj=%s> List: ", ObjectName(object));
  */

  /*
   * Append filters on classes mixed into this object.
   */
  if ((object->flags & NSF_MIXIN_ORDER_VALID) == 0u) {
    MixinComputeDefined(interp, object);
  }
  if ((object->flags & NSF_MIXIN_ORDER_DEFINED_AND_VALID) != 0u) {
    NsfCmdList *ml;

    for (ml = object->mixinOrder; ml != NULL; ml = ml->nextPtr) {
      NsfClass *mixin = NsfGetClassFromCmdPtr(ml->cmdPtr);

      if (mixin != NULL && mixin->opt != NULL && mixin->opt->classFilters != NULL) {
        FilterComputeOrderFullList(interp, &mixin->opt->classFilters, &filterList);
      }
    }
  }

  /*
   * Append filters on the object.
   */
  if (object->opt != NULL) {
    FilterComputeOrderFullList(interp, &object->opt->objFilters, &filterList);
  }

  /*
   * Append filters on the classes in the superclass hierarchy.
   */
  for (pl = PrecedenceOrder(object->cl); pl != NULL; pl = pl->nextPtr) {
    NsfClassOpt *clopt = pl->cl->opt;
    if (clopt != NULL && clopt->classFilters != NULL) {
      FilterComputeOrderFullList(interp, &clopt->classFilters, &filterList);
    }
  }

  /*
   * Do add duplicates or classes of the precedence order to the resulting
   * list.
   */
  while (filterList != NULL) {
    /*
     * Search for filterList->cmdPtr
     */
    for (checker = next = filterList->nextPtr; checker != NULL; checker = checker->nextPtr) {
      if (checker->cmdPtr == filterList->cmdPtr) {
        break;
      }
    }

    if (checker == NULL) {
      /*
       * filterList->cmdPtr was found
       */
      newList = CmdListAdd(&object->filterOrder, filterList->cmdPtr, filterList->clorobj,
                           /*noDuplicates*/ NSF_FALSE, NSF_TRUE);
      GuardAddInheritedGuards(interp, newList, object, filterList->cmdPtr);
      /*
        GuardPrint(interp, newList->clientData);
      */
    }

    CmdListDeleteCmdListEntry(filterList, GuardDel);
    filterList = next;
  }
}

/*
 *----------------------------------------------------------------------
 * FilterComputeDefined --
 *
 *    Sets the flags of the object to indicate the state of the filter order.
 *    The state is one of:
 *
 *       DEFINED
 *           There are one or more filters of the instance.
 *       NONE
 *           There are no filters of the instance.
 *       INVALID
 *           A class restructuring has occurred, so it is unclear whether or
 *           not filters are defined.  FilterComputeDefined computes the order
 *           and sets the instance to DEFINE or NONE.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void
FilterComputeDefined(Tcl_Interp *interp, NsfObject *object) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  FilterComputeOrder(interp, object);
  object->flags |= NSF_FILTER_ORDER_VALID;
  if (object->filterOrder != NULL) {
    object->flags |= NSF_FILTER_ORDER_DEFINED;
  } else {
    object->flags &= ~NSF_FILTER_ORDER_DEFINED;
  }
}

/*
 *----------------------------------------------------------------------
 * FilterStackPush --
 *
 *    Creates a new item for the filter stack, initializes it with calledProc,
 *    and pushes it on the given object.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void FilterStackPush(NsfObject *object, Tcl_Obj *calledProc)
  nonnull(1) nonnull(2);

static void
FilterStackPush(NsfObject *object, Tcl_Obj *calledProc) {
  register NsfFilterStack *h = NEW(NsfFilterStack);

  nonnull_assert(object != NULL);
  nonnull_assert(calledProc != NULL);

  h->currentCmdPtr = NULL;
  h->calledProc = calledProc;
  INCR_REF_COUNT(h->calledProc);
  h->nextPtr = object->filterStack;
  object->filterStack = h;
}

/*
 *----------------------------------------------------------------------
 * FilterStackPush --
 *
 *    Pops a filter stack item from the given object.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Frees the popped item.
 *
 *----------------------------------------------------------------------
 */
static void FilterStackPop(NsfObject *object)
  nonnull(1);

static void
FilterStackPop(NsfObject *object) {
  register NsfFilterStack *h;

  nonnull_assert(object != NULL);

  h = object->filterStack;
  object->filterStack = h->nextPtr;

  /*
   * Free stack entry.
   */
  DECR_REF_COUNT(h->calledProc);
  FREE(NsfFilterStack, h);
}

/*
 *----------------------------------------------------------------------
 * FilterFindReg --
 *
 *    Searches for the given command in the filter list of the given object and
 *    its class hierarchy.
 *
 * Results:
 *    Either a list containing filter information in the form "<obj> filter
 *    <filterName>" or "<class> filter <filterName>", or an empty list.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static Tcl_Obj * FilterFindReg(Tcl_Interp *interp, NsfObject *object, Tcl_Command cmd)
  nonnull(1) nonnull(2) nonnull(3) returns_nonnull;

static Tcl_Obj *
FilterFindReg(Tcl_Interp *interp, NsfObject *object, Tcl_Command cmd) {
  Tcl_Obj *list = Tcl_NewListObj(0, NULL);
  NsfClasses *pl;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(cmd != NULL);

  /*
   * Search filters of the object.
   */
  if (object->opt != NULL
      && object->opt->objFilters != NULL
      && CmdListFindCmdInList(cmd, object->opt->objFilters)) {
    Tcl_ListObjAppendElement(interp, list, object->cmdName);
    Tcl_ListObjAppendElement(interp, list, NsfGlobalObjs[NSF_OBJECT]);
    Tcl_ListObjAppendElement(interp, list, NsfGlobalObjs[NSF_FILTER]);
    Tcl_ListObjAppendElement(interp, list,
                             Tcl_NewStringObj(Tcl_GetCommandName(interp, cmd), -1));
    return list;
  }

  /*
   * Search on the class of the object.
   */
  for (pl = PrecedenceOrder(object->cl); pl != NULL; pl = pl->nextPtr) {
    NsfClassOpt *opt = pl->cl->opt;
    if (opt != NULL && opt->classFilters != NULL) {
      if (CmdListFindCmdInList(cmd, opt->classFilters)) {
        Tcl_ListObjAppendElement(interp, list, pl->cl->object.cmdName);
        Tcl_ListObjAppendElement(interp, list, NsfGlobalObjs[NSF_FILTER]);
        Tcl_ListObjAppendElement(interp, list,
                                 Tcl_NewStringObj(Tcl_GetCommandName(interp, cmd), -1));
        return list;
      }
    }
  }
  return list;
}

/*
 *----------------------------------------------------------------------
 * FilterSearchProc --
 *
 *     For the active filter, if any, stores the current command in *currentCmd
 *     and its class in *classPtr, and returns the filter.  Assumes a
 *     filterStack exists on the object.
 *
 * Results:
 *     See description.
 *
 * Side effects:
 *     See description.
 *
 *----------------------------------------------------------------------
 */
/*
 */
static Tcl_Command FilterSearchProc(Tcl_Interp *interp, NsfObject *object,
                 Tcl_Command *currentCmd, NsfClass **classPtr)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static Tcl_Command
FilterSearchProc(Tcl_Interp *interp, NsfObject *object,
                 Tcl_Command *currentCmd, NsfClass **classPtr) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(currentCmd != NULL);
  nonnull_assert(classPtr != NULL);

  assert(object->filterStack != NULL);
  /*
   * Compute the filter order if the current order is invalid.
   * FilterComputeDefined(interp, object);
   */
  assert(object->flags & NSF_FILTER_ORDER_VALID);

  if (object->filterOrder != NULL) {
    NsfCmdList *cmdList;

    *currentCmd = NULL;
    cmdList = SeekCurrent(object->filterStack->currentCmdPtr, object->filterOrder);

    while (cmdList != NULL) {
      /*fprintf(stderr, "FilterSearchProc found %s\n",
        Tcl_GetCommandName(interp, (Tcl_Command)cmdList->cmdPtr));*/
      if (Tcl_Command_cmdEpoch(cmdList->cmdPtr) != 0) {
        cmdList = cmdList->nextPtr;
      } else if (FilterActiveOnObj(interp, object, cmdList->cmdPtr)) {
        /* fprintf(stderr, "Filter <%s> -- Active on: %s\n",
           Tcl_GetCommandName(interp, (Tcl_Command)cmdList->cmdPtr), ObjectName(object));
        */
        object->filterStack->currentCmdPtr = cmdList->cmdPtr;
        cmdList = SeekCurrent(object->filterStack->currentCmdPtr, object->filterOrder);
      } else {
        if (cmdList->clorobj && !NsfObjectIsClass(&cmdList->clorobj->object)) {
          *classPtr = NULL;
        } else {
          *classPtr = cmdList->clorobj;
        }
        *currentCmd = cmdList->cmdPtr;
        /* fprintf(stderr, "FilterSearchProc - found: %s, %p\n",
           Tcl_GetCommandName(interp, (Tcl_Command)cmdList->cmdPtr), cmdList->cmdPtr);
        */
        return cmdList->cmdPtr;
      }
    }
  }
  return NULL;
}

/*
 *----------------------------------------------------------------------
 * SuperclassAdd --
 *
 *    Adds the given superclasses to the given class.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Rearranges class relations and flushes previous precedence orders.
 *
 *----------------------------------------------------------------------
 */
static int SuperclassAdd(Tcl_Interp *interp, NsfClass *class, int oc, Tcl_Obj **ov, Tcl_Obj *arg)
  nonnull(1) nonnull(2) nonnull(4) nonnull(5);

static int
SuperclassAdd(Tcl_Interp *interp, NsfClass *class, int oc, Tcl_Obj **ov, Tcl_Obj *arg) {
  NsfClasses       *superClasses, *subClasses, *osl = NULL;
  NsfObjectSystem  *osPtr;
  NsfClass        **classPtr;
  int i, j;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(ov != NULL);
  nonnull_assert(arg != NULL);

  superClasses = PrecedenceOrder(class);
  subClasses = DependentSubClasses(class);

  /*
   * Remove all dependent superclass filters referenced by class or a class in
   * its subclass hierarchy.
   *
   */
  if (superClasses != NULL) {
   /*
   * Do not check the class itself.
   */
    superClasses = superClasses->nextPtr;
  }
  for (; superClasses; superClasses = superClasses->nextPtr) {
    FilterRemoveDependentFilterCmds(superClasses->cl, subClasses);
  }

  /*
   * Invalidate all interceptors' orders of instances of this and of all
   * depended classes.
   */
  MixinInvalidateObjOrders(subClasses);
  if (FiltersDefined(interp) > 0) {
    FilterInvalidateObjOrders(interp, subClasses);
  }

  /*
   * Build an array of superClasses from the arguments.
   */
  classPtr = NEW_ARRAY(NsfClass*, oc);
  for (i = 0; i < oc; i++) {
    if (GetClassFromObj(interp, ov[i], &classPtr[i], NSF_TRUE) != TCL_OK) {
      FREE(NsfClass**, classPtr);
      NsfClassListFree(subClasses);
      return NsfObjErrType(interp, "superclass", arg, "a list of classes", NULL);
    }
  }

  /*
   * Check that superClasses don't precede their classes.
   */
  for (i = 0; i < oc; i++) {
    for (j = i+1; j < oc; j++) {
      NsfClasses *dl = PrecedenceOrder(classPtr[j]);

      dl = NsfClassListFind(dl, classPtr[i]);
      if (dl != NULL) {
        FREE(NsfClass**, classPtr);
        NsfClassListFree(subClasses);
        return NsfObjErrType(interp, "superclass", arg, "classes in dependence order", NULL);
      }
    }
  }

  /*
   * Ensure that the current class and new superClasses are from the
   * same object system.
   */
  osPtr = GetObjectSystem(&class->object);
  for (i = 0; i < oc; i++) {
    if (osPtr != GetObjectSystem(&classPtr[i]->object)) {
      NsfPrintError(interp, "class \"%s\" has a different object system as class  \"%s\"",
                           ClassName_(class), ClassName(classPtr[i]));
      NsfClassListFree(subClasses);
      FREE(NsfClass**, classPtr);
      return TCL_ERROR;
    }
  }

  while (class->super != NULL) {
    /*
     * Build a backup of the old superclass list in case it is necessary to
     * revert.
     */
    NsfClass   *superClass = class->super->cl;
    NsfClasses *l = osl;

    osl = NEW(NsfClasses);
    osl->cl = superClass;
    osl->nextPtr = l;
    (void)RemoveSuper(class, class->super->cl);
  }

  for (i = 0; i < oc; i++) {
    AddSuper(class, classPtr[i]);
  }

  FlushPrecedences(subClasses);
  NsfClassListFree(subClasses);
  FREE(NsfClass**, classPtr);

  if (unlikely(!PrecedenceOrder(class))) {
    NsfClasses *l;
    /*
     * There is a cycle in the superclass graph. Revert and return an error.
     */
    while (class->super != NULL) {
      (void)RemoveSuper(class, class->super->cl);
    }
    for (l = osl; l != NULL; l = l->nextPtr) {
      AddSuper(class, l->cl);
    }
    if (osl != NULL) {
      NsfClassListFree(osl);
    }

    return NsfObjErrType(interp, "superclass", arg, "a cycle-free graph", NULL);
  }

  if (osl != NULL) {
    NsfClassListFree(osl);
  }

  assert(class->super != NULL);

  Tcl_ResetResult(interp);
  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 * CheckVarName --
 *
 *    Rejects the given a name if it contains namespace component delimiters.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int CheckVarName(Tcl_Interp *interp, const char *varNameString)
  nonnull(1) nonnull(2);

static int
CheckVarName(Tcl_Interp *interp, const char *varNameString) {

  nonnull_assert(interp != NULL);
  nonnull_assert(varNameString != NULL);

  /*
   * The name should be a plain variable name so that namespace resolvers do
   * not interfere.  Initially, "::" was simply disallowed, but that
   * incorrectly rejected array variables where the index component contained
   * "::", e.g.  arrayName(::x::y).
   *
   * TODO: A more general and efficient solution to disallow e.g. a::b
   * (check for :: until parens)
   */
  /*if (strstr(varNameString, "::") || *varNameString == ':') {*/
  if (*varNameString == ':') {
    return NsfPrintError(interp, "variable name \"%s\" must not contain "
                         "namespace separator or colon prefix",
                         varNameString);
  }
  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 * VarExists --
 *
 *    Returns true if the named variable exists on the given object.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static bool VarExists(
    Tcl_Interp *interp, NsfObject *object,
    const char *name1, const char *name2, unsigned int flags
) nonnull(1) nonnull(2) nonnull(3);

static bool
VarExists(
    Tcl_Interp *interp, NsfObject *object,
    const char *name1, const char *name2,
    unsigned int flags
) {
  CallFrame frame, *framePtr = &frame;
  const Var *varPtr;
  Var *arrayPtr;
  bool result;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(name1 != NULL);

  Nsf_PushFrameObj(interp, object, framePtr);

  if ((flags & NSF_VAR_TRIGGER_TRACE) != 0u) {
    varPtr = TclVarTraceExists(interp, name1);
  } else {
    varPtr = TclLookupVar(interp, name1, name2, 0, "access",
                          /*createPart1*/ 0, /*createPart2*/ 0, &arrayPtr);
  }
  /*
    fprintf(stderr, "VarExists %s varPtr %p flags %.4x isundef %d\n",
    name1,
    varPtr,
    flags, (varPtr != NULL) ? TclIsVarUndefined(varPtr) : NULL);
  */
  result = ((varPtr != NULL) && ((flags & NSF_VAR_REQUIRE_DEFINED) == 0u || !TclIsVarUndefined(varPtr)));
  if (result && ((flags & NSF_VAR_ISARRAY) != 0u) && !TclIsVarArray(varPtr)) {
    result = NSF_FALSE;
  }
  Nsf_PopFrameObj(interp, framePtr);

  return result;
}

#if defined(WITH_TCL_COMPILE)
# include <tclCompile.h>
#endif

/*
 *----------------------------------------------------------------------
 * MakeProcError --
 *
 *    Called internally from Tcl if the definition of the proc failed.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static void
MakeProcError(
    Tcl_Interp *interp,        /* The interpreter in which the procedure was called. */
    Tcl_Obj *procNameObj       /* Name of the procedure. Used for error
                                * messages and trace information. */
) {
  int         overflow, limit = 60, nameLen;
  const char *procName;

  /*fprintf(stderr, "MakeProcError %p type %p refCount %d\n",
    procNameObj, procNameObj->typePtr, procNameObj->refCount);*/

  procName = Tcl_GetString(procNameObj);
  nameLen = procNameObj->length;
  overflow = (nameLen > limit);
  Tcl_AppendObjToErrorInfo(interp, Tcl_ObjPrintf(
                                                 "\n    (procedure \"%.*s%s\" line %d)",
                                                 ((overflow != 0) ? limit : nameLen), procName,
                                                 ((overflow != 0) ? "..." : ""), Tcl_GetErrorLine(interp)));
}

/*
 *----------------------------------------------------------------------
 * ByteCompiled --
 *
 *    Determines whether a proc is already byte-compiled.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int ByteCompiled(
    Tcl_Interp *interp, unsigned int *flagsPtr,
    Proc *procPtr, Namespace *nsPtr, const char *procName
) nonnull(1) nonnull(2) nonnull(3) nonnull(4) nonnull(5);

static int
ByteCompiled(
    Tcl_Interp *interp, unsigned int *flagsPtr,
    Proc *procPtr, Namespace *nsPtr, const char *procName
) {
  Tcl_Obj *bodyObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(flagsPtr != NULL);
  nonnull_assert(procPtr != NULL);
  nonnull_assert(procName != NULL);
  nonnull_assert(nsPtr != NULL);

  bodyObj = procPtr->bodyPtr;

  if (likely(bodyObj->typePtr == Nsf_OT_byteCodeType)) {
#if defined(HAVE_TCL_COMPILE_H)
    ByteCode *codePtr;
    Interp   *iPtr = (Interp *) interp;

    /*
     * For bytecode the validity check is:  The bytecode must be for the right
     * interpreter (no cross-leaks!), the code must be from the current epoch
     * so subcommand compilation is up-to-date, the namespace must match so
     * variable handling is right, and the resolverEpoch must match so that new
     * overridden commands and/or resolver changes are considered.
     */

    codePtr = bodyObj->internalRep.otherValuePtr;
    if (unlikely(((Interp *) *codePtr->interpHandle != iPtr)
                 || (codePtr->compileEpoch != iPtr->compileEpoch)
                 || (codePtr->nsPtr != nsPtr)
                 || (codePtr->nsEpoch != nsPtr->resolverEpoch))) {

# if defined(VAR_RESOLVER_TRACE)
      fprintf(stderr, "ByteCompiled bytecode not valid proc %p cmd %p method %s\n",
              procPtr, procPtr->cmdPtr,
              Tcl_GetCommandName(interp, (Tcl_Command)procPtr->cmdPtr));
      fprintf(stderr, "    %d %d %d %d\n",
              ((Interp *) *codePtr->interpHandle != iPtr),
               (codePtr->compileEpoch != iPtr->compileEpoch),
               (codePtr->nsPtr != nsPtr),
               (codePtr->nsEpoch != nsPtr->resolverEpoch));

      {
        CompiledLocal *localPtr = procPtr->firstLocalPtr;
        for (; localPtr != NULL; localPtr = localPtr->nextPtr) {
          fprintf(stderr, "... local %p '%s' resolveInfo %p deleteProc %p\n",
                  localPtr, localPtr->name, localPtr->resolveInfo,
                  (localPtr->resolveInfo != NULL) ? localPtr->resolveInfo->deleteProc : NULL);
        }
      }
# endif
      /* dummy statement for coverage analysis */
      assert(1);
      goto doCompilation;
    }
#endif
    return TCL_OK;
  } else {
    int        result;
    Namespace *definitionNsPtr;

#if defined(HAVE_TCL_COMPILE_H)
  doCompilation:
#endif

    *flagsPtr |= NSF_CSC_CALL_IS_COMPILE;
    /*fprintf(stderr, "compiling '%s' with ns %s\n", procName, nsPtr->name);*/

    /*
     * Tcl's bytecode compiler, TclCompileScript & friends, access the
     * namespace of the procedure as resolution context for command lookups
     * (Tcl_FindCommand), so for the compilation step, patch the proc command
     * to point to the execution namespace, and restore the definition
     * namespace on leaving.
     */

    definitionNsPtr = procPtr->cmdPtr->nsPtr;
    procPtr->cmdPtr->nsPtr = nsPtr;

    result = TclProcCompileProc(interp, procPtr, bodyObj,
                                (Namespace *) nsPtr, "body of proc",
                                procName);
    procPtr->cmdPtr->nsPtr = definitionNsPtr;

    /*fprintf(stderr, "compiling '%s' with ns %s DONE\n", procName, nsPtr->name);*/
    *flagsPtr &= ~NSF_CSC_CALL_IS_COMPILE;

    return result;
  }
}

/*
 *----------------------------------------------------------------------
 * PushProcCallFrame --
 *
 *    Sets up and pushes a new call frame for the procedure invocation.  The
 *    proc is passed via clientData.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    May compile the body.
 *
 *----------------------------------------------------------------------
 */
static int PushProcCallFrame(
    Proc *procPtr, Tcl_Interp *interp,
    int objc, Tcl_Obj *const objv[],
    Tcl_Namespace *execNsPtr,
    NsfCallStackContent *cscPtr
) nonnull(1) nonnull(2) nonnull(4) nonnull(6);

static int
PushProcCallFrame(
    Proc *procPtr, Tcl_Interp *interp,
    int objc, Tcl_Obj *const objv[],
    Tcl_Namespace *execNsPtr,
    NsfCallStackContent *cscPtr
) {
  Tcl_CallFrame *framePtr;
  int            result;

  nonnull_assert(procPtr != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);
  nonnull_assert(cscPtr != NULL);

  /*
   * Set up and push a new call frame.  This call frame executes either in the
   * provided execNs or in the namespace of the procedure, which might be
   * different than the current namespace. The namespace of the procedure is
   * that of its command, which can change when the command is renamed from one
   * namespace to another.
   */

  if (execNsPtr == NULL) {
    execNsPtr = (Tcl_Namespace *) procPtr->cmdPtr->nsPtr;
  }

  /*
   * TODO: Tcl_PushCallFrame() could be used if the Tcl stack frame could be
   * allocated earlier.
   */
  result = TclPushStackFrame(interp, (Tcl_CallFrame **)&framePtr,
                             execNsPtr,
                             (FRAME_IS_PROC|FRAME_IS_NSF_METHOD));

  if (likely(result == TCL_OK)) {

    Tcl_CallFrame_objc(framePtr) = objc;
    Tcl_CallFrame_objv(framePtr) = objv;
    Tcl_CallFrame_procPtr(framePtr) = procPtr;
    Tcl_CallFrame_clientData(framePtr) = cscPtr;

    /*fprintf(stderr, "Stack Frame %p procPtr %p compiledLocals %p firstLocal %p\n",
      framePtr, procPtr, Tcl_CallFrame_compiledLocals(framePtr), procPtr->firstLocalPtr);*/

    result = ByteCompiled(interp, &cscPtr->flags, procPtr, (Namespace *)execNsPtr, ObjStr(objv[0]));
  }

  return result;
}

#include "nsfAPI.h"

/*
 *----------------------------------------------------------------------
 * ObjectSystemsCheckSystemMethod --
 *
 *    Marks the names system method as (potentially) 'overloaded' in all object
 *    systems and declares it as defined in the object system for the given
 *    object.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Updates the object system structure(s).
 *
 *----------------------------------------------------------------------
 */
static int
ObjectSystemsCheckSystemMethod(
    Tcl_Interp *interp, const char *methodName, const NsfObject *object, unsigned int flags
) {
  NsfObjectSystem *osPtr, *defOsPtr;
  char             firstChar;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodName != NULL);

  firstChar = *methodName;
  defOsPtr = GetObjectSystem(object);

  for (osPtr = RUNTIME_STATE(interp)->objectSystems; osPtr != NULL; osPtr = osPtr->nextPtr) {
    int           i, isRootClassMethod;
    unsigned int  flag = 0u;
    NsfObject    *defObject;
    const char  **methodStrings = osPtr->methodNames;

    for (i = 0; i <= NSF_s_set_idx; i++) {
      const char *methodString = *methodStrings ++;

      if (likely(methodString != NULL)
          && unlikely(*methodString == firstChar)
          && strcmp(methodName, methodString) == 0) {
        flag = 1u << i;
        break;
      }
    }
    if (flag == 0u) {
      continue;
    }

    isRootClassMethod = *(Nsf_SystemMethodOpts[i]+1) == 'o';
    defObject = (isRootClassMethod == 1)
      ? &osPtr->rootClass->object
      : &osPtr->rootMetaClass->object;

    if (osPtr->handles[i] && osPtr->protected[i]) {
      if (defObject == object && (flags & NSF_CMD_REDEFINE_PROTECTED_METHOD) == 0u) {
        return NsfPrintError(interp, "refuse to overwrite protected method %s on %s",
                             methodName, ObjectName(defObject));
      }
    }

    if ((osPtr->definedMethods & flag) != 0u) {
      /*
       *  If for some reason base methods become redefined, e.g. during reload,
       *  do not count them as overloads.
       */
      if ((isRootClassMethod == 1
           && object == &defOsPtr->rootClass->object)
          || (isRootClassMethod == 0
              && object == &defOsPtr->rootMetaClass->object)
          ) {
        /*fprintf(stderr, "+++ %s %.6x NOT overloading %s.%s %s (is root %d, is meta %d)\n",
          ClassName(defOsPtr->rootClass),
          osPtr->overloadedMethods, ObjectName(object), methodName, Nsf_SystemMethodOpts[i],
          object == &defOsPtr->rootClass->object,
          object == &defOsPtr->rootMetaClass->object);*/
      } else {
        osPtr->overloadedMethods |= flag;
        /*fprintf(stderr, "+++ %s %.6x overloading %s.%s %s (is root %d, is meta %d)\n",
          ClassName(defOsPtr->rootClass),
          osPtr->overloadedMethods, ObjectName(object), methodName, Nsf_SystemMethodOpts[i],
          object == &defOsPtr->rootClass->object,
          object == &defOsPtr->rootMetaClass->object);*/
      }
    }
    if ((osPtr == defOsPtr)
        && ((osPtr->definedMethods & flag) == 0u)
        ) {
      /*
       * Flag the method as defined.
       */
      osPtr->definedMethods |= flag;

      /*fprintf(stderr, "+++ %s %.6x defining %s.%s %s osPtr %p defined %.8x flag %.8x handle %p\n",
              ClassName(defOsPtr->rootClass),  osPtr->definedMethods, ObjectName(object),
              methodName, Nsf_SystemMethodOpts[i], osPtr, osPtr->definedMethods, flag,
              osPtr->handles[i]);*/

      /*
       * If there is a method handle provided for this system method, register
       * it as a fallback unless the method is to be defined on the root class.
       */
      if (osPtr->handles[i]) {

        if (defObject != object) {
          int result;

          NsfLog(interp, NSF_LOG_DEBUG, "Define automatically alias %s for %s",
                 ObjStr(osPtr->handles[i]), Nsf_SystemMethodOpts[i]);

          result = NsfMethodAliasCmd(interp, defObject, 0, methodName, 0,
                                         ProtectionRedefine_protectedIdx, osPtr->handles[i]);

          if (unlikely(result != TCL_OK)) {
            /*
             * Alias definition failed.
             */
            NsfLog(interp, NSF_LOG_WARN, "Could not define alias %s for %s",
                   ObjStr(osPtr->handles[i]), Nsf_SystemMethodOpts[i]);
            return TCL_ERROR;
          } else {
            /*
             * Alias definition succeeded.
             */
            Tcl_Obj     *methodObj = Tcl_GetObjResult(interp);
            Tcl_Command  cmd       = Tcl_GetCommandFromObj(interp, methodObj);

            /*
             * Since defObject is not equal to the overridden method, the
             * definition above is effectively an overrides of the alias.
             */
            osPtr->overloadedMethods |= flag;

            /*
             * Set method protection.
             */
            if (cmd != NULL) {
              Tcl_Command_flags(cmd) |= NSF_CMD_CALL_PROTECTED_METHOD;
              if (osPtr->protected[i]) {
                Tcl_Command_flags(cmd) |= NSF_CMD_REDEFINE_PROTECTED_METHOD;
              }
            }
            Tcl_ResetResult(interp);
          }
        }
      }
    }
  }

  return TCL_OK;
}


/*----------------------------------------------------------------------
 * ParamsNew --
 *
 *    Allocates an array of Nsf_Param structures and returns a pointer to these
 *    structures.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static Nsf_Param *
ParamsNew(size_t nr) {
  Nsf_Param *paramsPtr = NEW_ARRAY(Nsf_Param, nr+1);

  memset(paramsPtr, 0, sizeof(Nsf_Param) * (nr+1));

  return paramsPtr;
}

/*----------------------------------------------------------------------
 * ParamFree --
 *
 *    Deallocates the contents of a single Nsf_Param*.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void ParamFree(Nsf_Param *paramPtr)
  nonnull(1);

static void
ParamFree(Nsf_Param *paramPtr) {

  nonnull_assert(paramPtr != NULL);

  /*fprintf(stderr, "ParamFree %p\n", paramPtr);*/
  if (paramPtr->name != NULL) {STRING_FREE("paramPtr->name", paramPtr->name);}
  if (paramPtr->nameObj != NULL) {DECR_REF_COUNT(paramPtr->nameObj);}
  if (paramPtr->defaultValue != NULL) {DECR_REF_COUNT(paramPtr->defaultValue);}
  if (paramPtr->converterName != NULL) {DECR_REF_COUNT2("converterNameObj", paramPtr->converterName);}
  if (paramPtr->converterArg != NULL) {DECR_REF_COUNT(paramPtr->converterArg);}
  if (paramPtr->paramObj != NULL) {DECR_REF_COUNT(paramPtr->paramObj);}
  if (paramPtr->slotObj != NULL) {DECR_REF_COUNT(paramPtr->slotObj);}
  if (paramPtr->method != NULL) {DECR_REF_COUNT(paramPtr->method);}
}

/*----------------------------------------------------------------------
 * ParamsFree --
 *
 *    Deallocates a Nsf_Param* pointers.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Free the parameter definition.
 *
 *----------------------------------------------------------------------
 */
static void ParamsFree(Nsf_Param *paramsPtr)
  nonnull(1);

static void
ParamsFree(Nsf_Param *paramsPtr) {
  Nsf_Param *paramPtr;

  nonnull_assert(paramsPtr != NULL);

  /*fprintf(stderr, "ParamsFree %p\n", paramsPtr);*/
  for (paramPtr = paramsPtr; paramPtr->name != NULL; paramPtr++) {
    ParamFree(paramPtr);
  }

  FREE(Nsf_Param*, paramsPtr);
}

/*----------------------------------------------------------------------
 * ParamDefsGet --
 *
 *    Returns the parameter definitions for a cmdPtr if there is one,
 *    optionally also storing in *checkAlwaysFlagPtr a flag indicating whether
 *    the parameter must always be checked.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static NsfParamDefs *
ParamDefsGet(
    const Tcl_Command cmdPtr,
    unsigned int *checkAlwaysFlagPtr,
    Tcl_Namespace **execNsPtrPtr
) {
  NsfParamDefs *result;

  nonnull_assert(cmdPtr != NULL);

  if (likely(Tcl_Command_deleteProc(cmdPtr) == NsfProcDeleteProc)) {
    NsfProcContext *ctx = (NsfProcContext *)Tcl_Command_deleteData(cmdPtr);

    if (checkAlwaysFlagPtr != NULL) {
      *checkAlwaysFlagPtr = ctx->checkAlwaysFlag;
    }
    if (execNsPtrPtr != NULL) {
      *execNsPtrPtr = ctx->execNsPtr;
    }
    result = ctx->paramDefs;
  } else {
    result = NULL;
  }

  return result;
}

/*----------------------------------------------------------------------
 * ParamDefsGetReturns --
 *
 *    Returns the "returns" value of NsfProcContext, if any, for the given
 *    command.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static Tcl_Obj *ParamDefsGetReturns(
    const Tcl_Command cmdPtr
) nonnull(1) NSF_pure;

NSF_INLINE static Tcl_Obj *
ParamDefsGetReturns(const Tcl_Command cmdPtr) {
  const NsfProcContext *pCtx;
  Tcl_Obj              *resultObj;

  nonnull_assert(cmdPtr != NULL);

  pCtx = ProcContextGet(cmdPtr);
  if (pCtx != NULL) {
    resultObj = pCtx->returnsObj;
  } else {
    resultObj = NULL;
  }
  return resultObj;
}


/*----------------------------------------------------------------------
 * NsfParamDefsNonposLookup --
 *
 *    Stores in paramPtrPtr the non-positional arguments in the given parameter
 *    definitions. If there is no exact match, looks for an abbreviated match
 *    having at least NSF_ABBREV_MIN_CHARS leading chars that match.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static int NsfParamDefsNonposLookup(
    Tcl_Interp *interp, const char *nameString,
    const Nsf_Param *paramsPtr,  const Nsf_Param **paramPtrPtr
) nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static int
NsfParamDefsNonposLookup(
    Tcl_Interp *interp, const char *nameString,
    const Nsf_Param *paramsPtr, const Nsf_Param **paramPtrPtr
) {
  const Nsf_Param *paramPtr;
  char             ch1;
  size_t           length;

  nonnull_assert(interp != NULL);
  nonnull_assert(nameString != NULL);
  nonnull_assert(paramsPtr != NULL);
  nonnull_assert(paramPtrPtr != NULL);

  /*
   * paramsPtr must point to a block starting with a non-positional argument.
   */
  assert(paramsPtr->name != NULL);
  assert(*paramsPtr->name == '-');

  /*
   * nameString also starts with a leading dash.
   */
  assert(*nameString == '-');

  ch1 = nameString[2];
  for (paramPtr = paramsPtr; likely(paramPtr->name != NULL) && *paramPtr->name == '-'; paramPtr++) {
    if (unlikely((paramPtr->flags & NSF_ARG_NOCONFIG) != 0u)) {
      continue;
    }
    if (ch1 == paramPtr->name[2]
        && strcmp(nameString, paramPtr->name) == 0) {
        *paramPtrPtr = paramPtr;
        return TCL_OK;
    }
  }

  length = strlen(nameString);

  if (length >= NSF_ABBREV_MIN_CHARS) {

    for (paramPtr = paramsPtr; likely(paramPtr->name != NULL) && *paramPtr->name == '-'; paramPtr++) {
      if (unlikely((paramPtr->flags & NSF_ARG_NOCONFIG) != 0u)) {
        continue;
      }

      if (ch1 == paramPtr->name[2]
          && strncmp(nameString, paramPtr->name, length) == 0) {
        const Nsf_Param *pPtr;

        /* fprintf(stderr, "... <%s> is an abbrev of <%s>\n", nameString, paramPtr->name); */
        /*
         * Is the abbreviation unique?
         */
        for (pPtr = paramPtr + 1; likely(pPtr->name != NULL) && *pPtr->name == '-'; pPtr++) {
          if (unlikely((pPtr->flags & NSF_ARG_NOCONFIG) != 0u)) {
            continue;
          }
          if (ch1 == pPtr->name[2]
              && strncmp(nameString, pPtr->name, length) == 0) {
            /*
             * The abbreviation is not unique.
             */
            *paramPtrPtr = NULL;
            return NsfPrintError(interp, "the provided argument %s is an abbreviation for %s and %s",
                                 nameString, paramPtr->name, pPtr->name);
          }
        }
        /*
         * The abbreviation is unique.
         */
        *paramPtrPtr = paramPtr;
        return TCL_OK;
      }
    }
  }
  *paramPtrPtr = NULL;
  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 * CGetParamLookup --
 *
 *    Stores in *paramPtrPtr the parameter definition for the given name
 *    starting with a "-".  Returns an an error if the name is ambiguous.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int
CGetParamLookup(
    Tcl_Interp       *interp,
    Tcl_Obj          *nameObj,
    NsfParamDefs     *paramDefs,
    const Nsf_Param **paramPtrPtr
) nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static int
CGetParamLookup(Tcl_Interp *interp, Tcl_Obj *nameObj, NsfParamDefs *paramDefs, const Nsf_Param **paramPtrPtr)
{
  const char *nameString;
  int         result = TCL_OK;

  nonnull_assert(interp != NULL);
  nonnull_assert(nameObj != NULL);
  nonnull_assert(paramDefs != NULL);
  nonnull_assert(paramPtrPtr != NULL);

  /*
   * Does provided value start with a dash?
   */
  nameString = ObjStr(nameObj);
  if (unlikely(*nameString != '-')) {
    result = NsfPrintError(interp,
                           "cget: parameter must start with a '-': %s",
                           nameString);

  } else {
    NsfFlag *flagPtr = nameObj->internalRep.twoPtrValue.ptr1;

    if ((nameObj->typePtr == &NsfFlagObjType)
        && (flagPtr->signature == paramDefs->paramsPtr)
        && (flagPtr->serial == paramDefs->serial)
        ) {
      *paramPtrPtr = flagPtr->paramPtr;

    } else {
      Nsf_Param  *paramPtr;

      /*
       * Skip any leading parameters in the definition that are non-positional
       * arguments, which is very unlikely.
       */
      for (paramPtr = paramDefs->paramsPtr;
           (paramPtr->name != NULL) && (*paramPtr->name != '-');
           paramPtr++) {
        ;
      }

      /*
       * Look up the parameter starting with paramPtr.
       */
      result = NsfParamDefsNonposLookup(interp, nameString, paramPtr, paramPtrPtr);
      if (unlikely(result == TCL_OK)) {
        /*
         * Set the flag value. Probably should prohibit conversion on some
         * types.
         */
        NsfFlagObjSet(interp, nameObj, paramDefs->paramsPtr, paramDefs->serial,
                      *paramPtrPtr, NULL, 0u);
      }
    }
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * NsfProcDeleteProc --
 *
 *    FreeProc for procedures with associated parameter definitions.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Frees memory.
 *
 *----------------------------------------------------------------------
 */
static void
NsfProcDeleteProc(
    ClientData clientData
) {
  const NsfProcContext *ctxPtr;

  nonnull_assert(clientData != NULL);

  ctxPtr = (NsfProcContext *)clientData;
  if (ctxPtr->oldDeleteProc != NULL) {
    (*ctxPtr->oldDeleteProc)(ctxPtr->oldDeleteData);
  }
  if (ctxPtr->paramDefs != NULL) {
    /*fprintf(stderr, "free ParamDefs %p\n", (void*)ctxPtr->paramDefs);*/
    ParamDefsRefCountDecr(ctxPtr->paramDefs);
  }
  if (ctxPtr->colonLocalVarCache != NULL) {
    /*fprintf(stderr, "free colonLocalVarCache %p\n", (void*)ctxPtr->colonLocalVarCache);*/
    FREE(int*, ctxPtr->colonLocalVarCache);
  }
  if (ctxPtr->returnsObj != NULL) {
    DECR_REF_COUNT2("returnsObj", ctxPtr->returnsObj);
  }

  if (ctxPtr->execNsPtr != NULL) {
    /*
     * Balances increment in ParamDefsStore.
     */
    NSNamespaceRelease(ctxPtr->execNsPtr);
  }

  /*fprintf(stderr, "free %p\n", ctxPtr);*/
  FREE(NsfProcContext, ctxPtr);
}

/*
 *----------------------------------------------------------------------
 * ProcContextRequire --
 *
 *    Returns a NsfProcContext for the given command, creating a new one if
 *    needed.
 *
 * Results:
 *    An NsfProcContext*.
 *
 * Side effects:
 *    Might allocate a NsfProcContext.
 *
 *----------------------------------------------------------------------
 */
static NsfProcContext *
ProcContextRequire(
    Tcl_Command cmd
) {
  NsfProcContext *ctxPtr;
  Command        *cmdPtr;

  nonnull_assert(cmd != NULL);

  cmdPtr = (Command *)cmd;

  if (cmdPtr->deleteProc != NsfProcDeleteProc) {
    ctxPtr = NEW(NsfProcContext);

    /*fprintf(stderr, "ParamDefsStore %p replace deleteProc %p by %p\n",
      paramDefs, cmdPtr->deleteProc, NsfProcDeleteProc);*/

    ctxPtr->oldDeleteData      = (Proc *)cmdPtr->deleteData;
    ctxPtr->oldDeleteProc      = cmdPtr->deleteProc;
    cmdPtr->deleteProc         = NsfProcDeleteProc;
    cmdPtr->deleteData         = ctxPtr;

    ctxPtr->paramDefs          = NULL;
    ctxPtr->checkAlwaysFlag    = 0;
    ctxPtr->execNsPtr          = NULL;
    ctxPtr->colonLocalVarCache = NULL;
    ctxPtr->returnsObj         = NULL;
  } else {
    ctxPtr = (NsfProcContext *)Tcl_Command_deleteData(cmdPtr);
  }
  return ctxPtr;
}

/*
 *----------------------------------------------------------------------
 * ProcContextGet --
 *
 *    Returns an NsfProcContext for the given command if one is defined.
 *
 * Results:
 *    NsfProcContext* or NULL.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static NsfProcContext *
ProcContextGet(
    const Tcl_Command cmdPtr
) {
  NsfProcContext *result;

  nonnull_assert(cmdPtr != NULL);

  if (likely(Tcl_Command_deleteProc(cmdPtr) == NsfProcDeleteProc)) {
    result = (NsfProcContext *)Tcl_Command_deleteData(cmdPtr);
  } else {
    result = NULL;
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * ParamDefsStore --
 *
 *    Stores the given parameter definitions in the given command, setting a
 *    deleteProc that automatically calls the original delete proc.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static void ParamDefsStore(
    Tcl_Command cmd,
    NsfParamDefs *paramDefs,
    unsigned int checkAlwaysFlag,
    Tcl_Namespace *execNsPtr
) nonnull(1);

static void
ParamDefsStore(
    Tcl_Command cmd,
    NsfParamDefs *paramDefs,
    unsigned int checkAlwaysFlag,
    Tcl_Namespace *execNsPtr
) {
  NsfProcContext *ctxPtr;

  nonnull_assert(cmd != NULL);

  ctxPtr = ProcContextRequire(cmd);

  /*
   * Assume that this routine is never called for overwriting paramDefs.
   */
  assert(ctxPtr->paramDefs == NULL);
  /* fprintf(stderr, "ParamDefsStore paramDefs %p called: NS %s\n", paramDefs, execNsPtr ? execNsPtr->fullName : "na");*/
  ctxPtr->paramDefs       = paramDefs;
  ctxPtr->checkAlwaysFlag = checkAlwaysFlag;
  ctxPtr->execNsPtr       = execNsPtr;

  if (ctxPtr->execNsPtr != NULL) {
    /*
     * Corresponding decrement is in NsfProcDeleteProc.
     */
    NSNamespacePreserve(ctxPtr->execNsPtr);
  }
}

/*
 *----------------------------------------------------------------------
 * ParamDefsNew --
 *
 *    Allocates a new paramDefs structure and initializes it with zeros. The
 *    allocated structure should be freed with ParamDefsFree().
 *
 * Results:
 *    A paramDefs*.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static NsfParamDefs *
ParamDefsNew(void) {
  NsfParamDefs    *paramDefs;
  static NsfMutex  serialMutex = 0;
  static int       serial = 0;

  paramDefs = NEW(NsfParamDefs);
  memset(paramDefs, 0, sizeof(NsfParamDefs));

  /*
   * The serial could also be stored in thread-local storage.
   */
  NsfMutexLock(&serialMutex);
  paramDefs->serial = serial++;
  NsfMutexUnlock(&serialMutex);

  /*fprintf(stderr, "ParamDefsNew %p\n", paramDefs);*/

  return paramDefs;
}


/*
 *----------------------------------------------------------------------
 * ParamDefsFree --
 *
 *    Frees the parameter definitions. Since the parameter definitions are
 *    ref-counted, this routine should be called only by ParamDefsRefCountDecr.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Frees the parameter definitions.
 *
 *----------------------------------------------------------------------
 */

static void ParamDefsFree(NsfParamDefs *paramDefs)
  nonnull(1);

static void
ParamDefsFree(NsfParamDefs *paramDefs) {
  /* fprintf(stderr, "ParamDefsFree %p \n",
     paramDefs, paramDefs);*/

  nonnull_assert(paramDefs != NULL);

  if (paramDefs->paramsPtr != NULL) {
    ParamsFree(paramDefs->paramsPtr);
  }

  FREE(NsfParamDefs, paramDefs);
}

/*
 *----------------------------------------------------------------------
 * ParamDefsRefCountIncr --
 * ParamDefsRefCountDecr --
 *
 *    Performs reference-couting bookkeeping on the parameter definitions,
 *    which might be redefined when, e.g. an object parameter calls a method.
 *    ParamDefsRefCountDecr() frees the structure when the reference count
 *    so indicates.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    No direct effects.
 *
 *----------------------------------------------------------------------
 */


static void
ParamDefsRefCountIncr(NsfParamDefs *paramDefs) {

  nonnull_assert(paramDefs != NULL);

  paramDefs->refCount ++;
}

static void
ParamDefsRefCountDecr(NsfParamDefs *paramDefs) {

  nonnull_assert(paramDefs != NULL);

  paramDefs->refCount --;
  if (paramDefs->refCount < 1) {
    ParamDefsFree(paramDefs);
  }
}

/*
 *----------------------------------------------------------------------
 * ParamDefsFormatOption --
 *
 *    Appends a parameter option to nameStringObj, whose value is the parameter
 *    definition.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static void ParamDefsFormatOption(
    Tcl_Obj *nameStringObj, const char *option, int optionLength,
    int *colonWritten, int *firstOption
) nonnull(1) nonnull(2) nonnull(4) nonnull(5);

static void
ParamDefsFormatOption(
    Tcl_Obj *nameStringObj, const char *option, int optionLength,
    int *colonWritten, int *firstOption
) {

  nonnull_assert(nameStringObj != NULL);
  nonnull_assert(option != NULL);
  nonnull_assert(colonWritten != NULL);
  nonnull_assert(firstOption != NULL);

  if (!*colonWritten) {
    Tcl_AppendLimitedToObj(nameStringObj, ":", 1, INT_MAX, NULL);
    *colonWritten = 1;
  }
  if (*firstOption) {
    *firstOption = 0;
  } else {
    Tcl_AppendLimitedToObj(nameStringObj, ",", 1, INT_MAX, NULL);
  }
  Tcl_AppendLimitedToObj(nameStringObj, option, optionLength, INT_MAX, NULL);
}

/*
 *----------------------------------------------------------------------
 * ParamDefsFormat --
 *
 *    Returns a Tcl_Obj whose value is the parameter definition.
 *
 * Results:
 *    A Tcl_Obj*.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static Tcl_Obj *ParamDefsFormat(
    Tcl_Interp *interp, const Nsf_Param *paramsPtr, NsfObject *contextObject, const char *pattern
) nonnull(1) nonnull(2) returns_nonnull;

static int ParamsDefMatchPattern(const Nsf_Param *paramsPtr, const char *pattern) {
  if (paramsPtr->nameObj != NULL) {
    return Tcl_StringMatch(ObjStr(paramsPtr->nameObj), pattern);
  } else {
    return Tcl_StringMatch(paramsPtr->name, pattern);
  }
}


static Tcl_Obj *
ParamDefsFormat(
    Tcl_Interp *interp, const Nsf_Param *paramsPtr, NsfObject *contextObject, const char *pattern
) {
  int      first, colonWritten;
  Tcl_Obj *listObj = Tcl_NewListObj(0, NULL), *innerListObj, *nameStringObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(paramsPtr != NULL);

  INCR_REF_COUNT2("paramDefsObj", listObj);

  for (; likely(paramsPtr->name != NULL); paramsPtr++) {
    if ((paramsPtr->flags & NSF_ARG_NOCONFIG) != 0u) {
      continue;
    }
    if (paramsPtr->paramObj != NULL) {
      if (pattern != NULL && !ParamsDefMatchPattern(paramsPtr, pattern)) {
        continue;
      }
      innerListObj = paramsPtr->paramObj;
    } else {
      /*
       * Only needed for C-defined parameter definitions defined via genTclAPI.
       *
       * TODO: streamline this by defining a C-API having the same
       * syntax as for the Tcl_obj type "nsfParam".
       */
      int isNonpos = *paramsPtr->name == '-';
      int outputRequired = (isNonpos && ((paramsPtr->flags & NSF_ARG_REQUIRED) != 0u));
      int outputOptional = (!isNonpos && ((paramsPtr->flags & NSF_ARG_REQUIRED) == 0u)
                            && !paramsPtr->defaultValue &&
                            paramsPtr->converter != ConvertToNothing);
      first = 1;
      colonWritten = 0;

      if (NsfParamDefsAppendVirtual(interp, listObj, paramsPtr, contextObject, pattern, ParamDefsFormat)) {
        continue;
      }
      if (pattern != NULL && !ParamsDefMatchPattern(paramsPtr, pattern)) {
        continue;
      }

      nameStringObj = Tcl_NewStringObj(paramsPtr->name, -1);

      if (paramsPtr->type != NULL) {
        ParamDefsFormatOption(nameStringObj, paramsPtr->type, -1, &colonWritten, &first);
      } else if (isNonpos && paramsPtr->nrArgs == 0) {
        ParamDefsFormatOption(nameStringObj, "switch", 6, &colonWritten, &first);
      }
      if (outputRequired != 0) {
        ParamDefsFormatOption(nameStringObj, "required", 8, &colonWritten, &first);
      } else if (outputOptional != 0) {
        ParamDefsFormatOption(nameStringObj, "optional", 8, &colonWritten, &first);
      }
      if ((paramsPtr->flags & NSF_ARG_SUBST_DEFAULT) != 0u) {
        char buffer[30];
        int  len = 12;

        memcpy(buffer, "substdefault", (size_t)len);

        if ((paramsPtr->flags & NSF_ARG_SUBST_DEFAULT_ALL) != 0u) {
          memcpy(buffer + len + 1, "=0b", 3u);
          len += 4;
          buffer[len] = ((paramsPtr->flags & NSF_ARG_SUBST_DEFAULT_VARIABLES) != 0u) ? '1' : '0';
          len ++;
          buffer[len] = ((paramsPtr->flags & NSF_ARG_SUBST_DEFAULT_COMMANDS) != 0u) ? '1' : '0';
          len ++;
          buffer[len] = ((paramsPtr->flags & NSF_ARG_SUBST_DEFAULT_BACKSLASHES) != 0u) ? '1' : '0';
          len ++;
        } else {
          len ++;
        }
        buffer[len] = '\0';
        ParamDefsFormatOption(nameStringObj, buffer, len, &colonWritten, &first);

      }
      if ((paramsPtr->flags & NSF_ARG_ALLOW_EMPTY) != 0u || (paramsPtr->flags & NSF_ARG_MULTIVALUED) != 0u) {
        char option[10] = "....";

        option[0] = ((paramsPtr->flags & NSF_ARG_ALLOW_EMPTY) != 0u) ? '0' : '1';
        option[3] = ((paramsPtr->flags & NSF_ARG_MULTIVALUED) != 0u) ? '*' : '1';
        ParamDefsFormatOption(nameStringObj, option, 4, &colonWritten, &first);
      }
      if ((paramsPtr->flags & NSF_ARG_IS_CONVERTER) != 0u) {
        ParamDefsFormatOption(nameStringObj, "convert", 7, &colonWritten, &first);
      }
      if ((paramsPtr->flags & NSF_ARG_INITCMD) != 0u) {
        ParamDefsFormatOption(nameStringObj, "initcmd", 7, &colonWritten, &first);
      } else if ((paramsPtr->flags & NSF_ARG_CMD) != 0u) {
        ParamDefsFormatOption(nameStringObj, "cmd", 3, &colonWritten, &first);
      } else if ((paramsPtr->flags & NSF_ARG_ALIAS) != 0u) {
        ParamDefsFormatOption(nameStringObj, "alias", 5, &colonWritten, &first);
      } else if ((paramsPtr->flags & NSF_ARG_FORWARD) != 0u) {
        ParamDefsFormatOption(nameStringObj, "forward", 7, &colonWritten, &first);
      } else if ((paramsPtr->flags & NSF_ARG_NOARG) != 0u) {
        ParamDefsFormatOption(nameStringObj, "noarg", 5, &colonWritten, &first);
      } else if ((paramsPtr->flags & NSF_ARG_NOCONFIG) != 0u) {
        ParamDefsFormatOption(nameStringObj, "noconfig", 8, &colonWritten, &first);
      }

      innerListObj = Tcl_NewListObj(0, NULL);
      Tcl_ListObjAppendElement(interp, innerListObj, nameStringObj);
      if (paramsPtr->defaultValue != NULL) {
        Tcl_ListObjAppendElement(interp, innerListObj, paramsPtr->defaultValue);
      }
    }

    Tcl_ListObjAppendElement(interp, listObj, innerListObj);
  }

  return listObj;
}

/*
 *----------------------------------------------------------------------
 * ParamDefsList --
 *
 *    Returns a list, owned by the caller, of parameters in given the parameter
 *    structures.
 *
 * Results:
 *    A Tcl_Obj*.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static Tcl_Obj *ParamDefsList(
    Tcl_Interp *interp, const Nsf_Param *paramsPtr, NsfObject *contextObject, const char *pattern
) nonnull(1) nonnull(2) returns_nonnull;

static Tcl_Obj *
ParamDefsList(
    Tcl_Interp *interp, const Nsf_Param *paramsPtr, NsfObject *contextObject, const char *pattern
) {
  Tcl_Obj *listObj = Tcl_NewListObj(0, NULL);

  nonnull_assert(interp != NULL);
  nonnull_assert(paramsPtr != NULL);

  INCR_REF_COUNT2("paramDefsObj", listObj);

  for (; likely(paramsPtr->name != NULL); paramsPtr++) {
    if ((paramsPtr->flags & NSF_ARG_NOCONFIG) != 0u) {
      continue;
    }
    if (NsfParamDefsAppendVirtual(interp, listObj, paramsPtr, contextObject, pattern, ParamDefsList)) {
      continue;
    }

    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewStringObj(paramsPtr->name, -1));
  }

  return listObj;
}


/*
 *----------------------------------------------------------------------
 * ParamDefsNames --
 *
 *    Returns a Tcl_ListObj containing the names of the parameters in the
 *    parameter structures.
 *
 * Results:
 *    A Tcl_Obj*.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static Tcl_Obj * ParamDefsNames(
    Tcl_Interp *interp, const Nsf_Param *paramsPtr, NsfObject *contextObject, const char *pattern
) nonnull(1) nonnull(2) returns_nonnull;

static Tcl_Obj *
ParamDefsNames(
    Tcl_Interp *interp, const Nsf_Param *paramsPtr, NsfObject *contextObject, const char *pattern
) {
  Tcl_Obj *listObj = Tcl_NewListObj(0, NULL);

  nonnull_assert(interp != NULL);
  nonnull_assert(paramsPtr != NULL);

  INCR_REF_COUNT2("paramDefsObj", listObj);

  for (; likely(paramsPtr->name != NULL); paramsPtr++) {
    const char* paramName;

    if ((paramsPtr->flags & NSF_ARG_NOCONFIG) != 0u) {
      continue;
    }
    if (NsfParamDefsAppendVirtual(interp, listObj, paramsPtr, contextObject, pattern, ParamDefsNames)) {
      continue;
    }

    paramName = *paramsPtr->name == '-' ? paramsPtr->name+1 : paramsPtr->name;
    if (pattern != NULL && !Tcl_StringMatch(paramName, pattern)) {
      continue;
    }
    Tcl_ListObjAppendElement(interp, listObj, (paramsPtr->nameObj != NULL) ?
                             paramsPtr->nameObj : Tcl_NewStringObj(paramsPtr->name, -1));
  }

  return listObj;
}

/*
 *----------------------------------------------------------------------
 * ParamGetType --
 *
 *    Returns the string value of the type of a single parameter.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static const char *ParamGetType(Nsf_Param const *paramPtr)
  nonnull(1) returns_nonnull;

static const char *
ParamGetType(Nsf_Param const *paramPtr) {
  const char *result = "value";

  nonnull_assert(paramPtr != NULL);

  if (paramPtr->type != NULL) {
    if (paramPtr->converter == ConvertViaCmd) {
      result = paramPtr->type + 5;
    } else if (paramPtr->converter == Nsf_ConvertToClass &&
               ((paramPtr->flags & (NSF_ARG_BASECLASS|NSF_ARG_METACLASS)) != 0u) ) {
      if ((paramPtr->flags & NSF_ARG_BASECLASS) != 0u) {
        result = "baseclass";
      } else {
        result = "metaclass";
      }
    } else if (strcmp(paramPtr->type, "stringtype") == 0) {
      if (paramPtr->converterArg != NULL) {
        result = ObjStr(paramPtr->converterArg);
      }
    } else {
      result = paramPtr->type;
    }
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * ParamGetDomain --
 *
 *    Returns as a string the domain of a single parameter. The domain is an
 *    approximate type used in the parameter syntax.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static const char * ParamGetDomain(Nsf_Param const *paramPtr)
  nonnull(1) returns_nonnull;

static const char *
ParamGetDomain(Nsf_Param const *paramPtr) {
  const char *result;

  nonnull_assert(paramPtr != NULL);

  if ((paramPtr->flags & NSF_ARG_IS_ENUMERATION) != 0u) {
    return Nsf_EnumerationTypeGetDomain(paramPtr->converter);
  } else {
    result = ParamGetType(paramPtr);
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * NsfParamDefsSyntaxOne --
 *
 *    Appends the given formatted parameter to the given string.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static void NsfParamDefsSyntaxOne(Tcl_Obj *argStringObj, const Nsf_Param *pPtr)
  nonnull(1) nonnull(2);

static void
NsfParamDefsSyntaxOne(Tcl_Obj *argStringObj, const Nsf_Param *pPtr) {

  nonnull_assert(argStringObj != NULL);
  nonnull_assert(pPtr != NULL);

  if (pPtr->nrArgs > 0 && *pPtr->name == '-') {
    Tcl_AppendLimitedToObj(argStringObj, pPtr->name, -1, INT_MAX, NULL);
    Tcl_AppendLimitedToObj(argStringObj, " ", 1, INT_MAX, NULL);
    if ((pPtr->flags & NSF_ARG_IS_ENUMERATION) != 0u) {
      Tcl_AppendLimitedToObj(argStringObj, ParamGetDomain(pPtr), -1, INT_MAX, NULL);
      if ((pPtr->flags & NSF_ARG_MULTIVALUED) != 0u)  {
        Tcl_AppendLimitedToObj(argStringObj, " ...", 4, INT_MAX, NULL);
      }
    } else {
      Tcl_AppendLimitedToObj(argStringObj, "/", 1, INT_MAX, NULL);
      Tcl_AppendLimitedToObj(argStringObj, ParamGetDomain(pPtr), -1, INT_MAX, NULL);
      if ((pPtr->flags & NSF_ARG_MULTIVALUED) != 0u) {
        Tcl_AppendLimitedToObj(argStringObj, " ...", 4, INT_MAX, NULL);
      }
      Tcl_AppendLimitedToObj(argStringObj, "/", 1, INT_MAX, NULL);
    }
  } else if (*pPtr->name != '-') {
    Tcl_AppendLimitedToObj(argStringObj, "/", 1, INT_MAX, NULL);
    Tcl_AppendLimitedToObj(argStringObj, pPtr->name, -1, INT_MAX, NULL);
    Tcl_AppendLimitedToObj(argStringObj, "/", 1, INT_MAX, NULL);
  } else {
    Tcl_AppendLimitedToObj(argStringObj, pPtr->name, -1, INT_MAX, NULL);
  }
}

/*
 *----------------------------------------------------------------------
 * NsfParamDefsVirtualFormat --
 *
 *    Called when a virtual argument can be resolved against the context object.
 *    Obtains the resolved parsed params and calls the formatter.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static Tcl_Obj *
NsfParamDefsVirtualFormat(
    Tcl_Interp *interp, const Nsf_Param *pPtr,
    NsfObject *contextObject, const char *pattern,
    NsfFormatFunction formatFunction
) {
  NsfParsedParam parsedParam;
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(pPtr != NULL);
  nonnull_assert(contextObject != NULL);
  nonnull_assert(formatFunction != NULL);
  assert(pPtr->type != NULL);

  parsedParam.paramDefs = NULL;
  if (strcmp(pPtr->type, "virtualobjectargs") == 0) {
    result = GetObjectParameterDefinition(interp, NsfGlobalObjs[NSF_EMPTY], contextObject, NULL, &parsedParam);
  } else if (NsfObjectIsClass(contextObject)) {
    result = GetObjectParameterDefinition(interp, NsfGlobalObjs[NSF_EMPTY], NULL, (NsfClass *)contextObject, &parsedParam);
  } else {
    NsfLog(interp, NSF_LOG_WARN, "virtual args: provided context is not a class <%s>", ObjectName_(contextObject));
    result = TCL_ERROR;
  }

  if (result == TCL_OK && parsedParam.paramDefs != NULL) {
    return (*formatFunction)(interp, parsedParam.paramDefs->paramsPtr, contextObject, pattern);
  }

  return NULL;
}

/*
 *----------------------------------------------------------------------
 * NsfParamDefsAppendVirtual --
 *
 *    Determines whether the given paramsPtr is a virtual parameter, and if
 *    possible, resolves it and appends the formatted content to the given
 *    list.
 *
 * Results:
 *    True on success.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static bool
NsfParamDefsAppendVirtual(
    Tcl_Interp *interp, Tcl_Obj *listObj,
    const Nsf_Param *paramsPtr, NsfObject *contextObject,
    const char *pattern, NsfFormatFunction formatFunction
) {
  nonnull_assert(interp != NULL);
  nonnull_assert(listObj != NULL);
  nonnull_assert(paramsPtr != NULL);
  nonnull_assert(formatFunction != NULL);

  assert(paramsPtr->name != NULL);

  if (paramsPtr->converter == ConvertToNothing && strcmp(paramsPtr->name, "args") == 0) {

    if ((contextObject != NULL)
        && (paramsPtr->type != NULL)
        && strncmp(paramsPtr->type, "virtual", 7) == 0
        ) {
      Tcl_Obj *formattedObj = NsfParamDefsVirtualFormat(interp, paramsPtr, contextObject, pattern, formatFunction);

      if (formattedObj != NULL) {
        Tcl_ListObjAppendList(interp, listObj, formattedObj);
        DECR_REF_COUNT2("paramDefsObj", formattedObj);

        return NSF_TRUE;
      }
    }
  }
  return NSF_FALSE;
}

/*
 *----------------------------------------------------------------------
 * NsfParamDefsSyntax --
 *
 *    Returns the parameter definitions of a sequence of parameters in the
 *    "parameter syntax" form inspired by the Tcl manual pages.
 *
 * Results:
 *    Tcl_Obj containing the parameter syntax.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *NsfParamDefsSyntax(
    Tcl_Interp *interp, const Nsf_Param *paramsPtr, NsfObject *contextObject, const char *pattern
) nonnull(1) nonnull(2) returns_nonnull;

Tcl_Obj *
NsfParamDefsSyntax(
    Tcl_Interp *interp, const Nsf_Param *paramsPtr, NsfObject *contextObject, const char *pattern
) {
  Tcl_Obj         *argStringObj = Tcl_NewObj();
  const Nsf_Param *pPtr;
  int              needSpace = 0;

  nonnull_assert(interp != NULL);
  nonnull_assert(paramsPtr != NULL);

  INCR_REF_COUNT2("paramDefsObj", argStringObj);

  for (pPtr = paramsPtr; pPtr->name != NULL; pPtr++) {

    if ((pPtr->flags & NSF_ARG_NOCONFIG) != 0u) {
      /*
       * Don't output non-configurable parameters.
       */
      continue;
    }

    if (pPtr != paramsPtr) {
      /*
       * Don't output non-consuming parameters, i.e. positional parameters and
       * no args.
       */
      if (*pPtr->name != '-' && pPtr->nrArgs == 0) {
        continue;
      }
    }

    if (pPtr->converter == ConvertToNothing && strcmp(pPtr->name, "args") == 0) {
      int argsResolved = 0;

      if ((contextObject != NULL)
          && (pPtr->type != NULL)
          && strncmp(pPtr->type, "virtual", 7) == 0
          ) {
        Tcl_Obj *formattedObj = NsfParamDefsVirtualFormat(interp, pPtr, contextObject,
                                                          pattern, NsfParamDefsSyntax);

        if (formattedObj != NULL) {
          argsResolved = 1;
          if (needSpace != 0) {
            Tcl_AppendLimitedToObj(argStringObj, " ", 1, INT_MAX, NULL);
          }
          Tcl_AppendObjToObj(argStringObj, formattedObj);
          DECR_REF_COUNT2("paramDefsObj", formattedObj);
        }
      }
      if (argsResolved == 0) {
        if (pattern != NULL && !ParamsDefMatchPattern(pPtr, pattern)) {
          continue;
        }
        if (needSpace != 0) {
          Tcl_AppendLimitedToObj(argStringObj, " ", 1, INT_MAX, NULL);
        }
        Tcl_AppendLimitedToObj(argStringObj, "?/arg .../?", 11, INT_MAX, NULL);
      }

    } else if ((pPtr->flags & NSF_ARG_REQUIRED) != 0u) {
      if (pattern != NULL && !ParamsDefMatchPattern(pPtr, pattern)) {
        continue;
      }
      if (needSpace != 0) {
        Tcl_AppendLimitedToObj(argStringObj, " ", 1, INT_MAX, NULL);
      }

      if ((pPtr->flags & NSF_ARG_IS_ENUMERATION) != 0u) {
        Tcl_AppendLimitedToObj(argStringObj, Nsf_EnumerationTypeGetDomain(pPtr->converter), -1, INT_MAX, NULL);
      } else {
        NsfParamDefsSyntaxOne(argStringObj, pPtr);
      }

    } else {
      if (pattern != NULL && !ParamsDefMatchPattern(pPtr, pattern)) {
        continue;
      }
      if (needSpace != 0) Tcl_AppendLimitedToObj(argStringObj, " ", 1, INT_MAX, NULL);
      Tcl_AppendLimitedToObj(argStringObj, "?", 1, INT_MAX, NULL);
      NsfParamDefsSyntaxOne(argStringObj, pPtr);
      Tcl_AppendLimitedToObj(argStringObj, "?", 1, INT_MAX, NULL);
    }
    needSpace = 1;
  }

  /*
   * Caller must decrement.
   */
  return argStringObj;
}

/*
 *----------------------------------------------------------------------
 * ParsedParamFree --
 *
 *    Frees the given parsedParamPtr.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *----------------------------------------------------------------------
 */
static void
ParsedParamFree(NsfParsedParam *parsedParamPtr) {

  nonnull_assert(parsedParamPtr != NULL);

  /*fprintf(stderr, "ParsedParamFree %p, npargs %p\n",
    parsedParamPtr, parsedParamPtr->paramDefs);*/
  if (parsedParamPtr->paramDefs != NULL) {
    ParamDefsRefCountDecr(parsedParamPtr->paramDefs);
  }
  FREE(NsfParsedParam, parsedParamPtr);
}



/*
 * method dispatch
 */
/*
 *----------------------------------------------------------------------
 * ProcMethodDispatchFinalize --
 *
 *    Finalizer for ProcMethodDispatch.  Executes scripted methods:  Handles
 *    post-assertions and frees per-invocation memory. Developed for
 *    NRE-enabled Tcl but used in all versions.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */
static int ProcMethodDispatchFinalize(ClientData data[], Tcl_Interp *interp, int result)
  nonnull(1) nonnull(2);

static int
ProcMethodDispatchFinalize(ClientData data[], Tcl_Interp *interp, int result) {
  ParseContext       *pcPtr;
  /*const char *methodName = data[2];*/
#if defined(NSF_WITH_ASSERTIONS) || defined(NRE)
  NsfCallStackContent *cscPtr;
#endif
#if defined(NSF_WITH_ASSERTIONS)
  NsfObject           *object;
  NsfObjectOpt        *opt;
#endif

  nonnull_assert(data != NULL);
  nonnull_assert(interp != NULL);

  pcPtr = data[0];

#if defined(NSF_WITH_ASSERTIONS) || defined(NRE)
  cscPtr = data[1];
  assert(cscPtr != NULL);
#endif
#if defined(NSF_WITH_ASSERTIONS)
  object = cscPtr->self;
  opt = object->opt;
#endif

  /*fprintf(stderr, "ProcMethodDispatchFinalize %s %s flags %.6x isNRE %d pcPtr %p result %d\n",
          ObjectName(object), methodName,
          cscPtr->flags, (cscPtr->flags & NSF_CSC_CALL_IS_NRE), pcPtr, result);*/

#if defined(NSF_WITH_ASSERTIONS)
  if (unlikely(opt != NULL && object->teardown != NULL && (opt->checkoptions & CHECK_POST))
      && likely(result == TCL_OK)) {
    int rc = AssertionCheck(interp, object, cscPtr->cl, data[2], CHECK_POST);
    if (rc != TCL_OK) {
      result = rc;
    }
  }
#endif

#if defined(NRE)
  if (likely((cscPtr->flags & NSF_CSC_CALL_IS_NRE) != 0u)) {
    if (likely(pcPtr != NULL)) {
      ParseContextRelease(pcPtr);
      NsfTclStackFree(interp, pcPtr, "release parse context");
    }
    result = ObjectDispatchFinalize(interp, cscPtr, result /*, "NRE" , methodName*/);

    CscFinish(interp, cscPtr, result, "scripted finalize");
  }
#else
  if (unlikely(pcPtr != NULL)) {
    ParseContextRelease(pcPtr);
  }
#endif

  return result;
}

/*
 *----------------------------------------------------------------------
 * ProcDispatchFinalize --
 *
 *    A simplified version of ProcMethodDispatchFinalize() that finalizes
 *    nsf::proc.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */
static int ProcDispatchFinalize(ClientData data[], Tcl_Interp *interp, int result)
  nonnull(1) nonnull(2);

static int
ProcDispatchFinalize(ClientData data[], Tcl_Interp *interp, int result) {
  ParseContext *pcPtr;
  Tcl_Time     *ttPtr;

  nonnull_assert(data != NULL);
  nonnull_assert(interp != NULL);

  /*const char *methodName = data[0];
    fprintf(stderr, "ProcDispatchFinalize of method %s\n", methodName);*/

  pcPtr = data[1];
  ttPtr = data[2];

  if (ttPtr != NULL) {
    const char      *methodName = data[0];
    unsigned int     cmdFlags   = (unsigned int)PTR2UINT(data[3]);
#if defined(NSF_PROFILE)
    NsfRuntimeState *rst        = RUNTIME_STATE(interp);
#endif
    /*fprintf(stderr, "ProcDispatchFinalize methodName %s flags %.6lx\n",
      methodName, (cmdFlags & NSF_CMD_DEBUG_METHOD));*/
    if ((cmdFlags & NSF_CMD_DEBUG_METHOD) != 0u) {
      NsfProfileDebugExit(interp, NULL, NULL, methodName, ttPtr->sec, ttPtr->usec);
    }
#if defined(NSF_PROFILE)
    if (rst->doProfile != 0) {
      NsfProfileRecordProcData(interp, methodName, ttPtr->sec, ttPtr->usec);
    }
#endif
    ckfree((char *)ttPtr);
  }

  ParseContextRelease(pcPtr);
  NsfTclStackFree(interp, pcPtr, "nsf::proc dispatch finalize release parse context");
  return result;
}


/*
 *----------------------------------------------------------------------
 * ProcMethodDispatch --
 *
 *    Invokes a scripted method after assertion checking and filters.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */
static int ProcMethodDispatch(
    ClientData cp, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[],
    const char *methodName, NsfObject *object, NsfClass *class, Tcl_Command cmdPtr,
    NsfCallStackContent *cscPtr
) nonnull(1) nonnull(2) nonnull(4) nonnull(5) nonnull(6) nonnull(8) nonnull(9);

static int
ProcMethodDispatch(
    ClientData cp, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[],
    const char *methodName, NsfObject *object, NsfClass *class, Tcl_Command cmdPtr,
    NsfCallStackContent *cscPtr
) {
  NsfParamDefs  *paramDefs;
  int            result;
  bool           releasePc = NSF_FALSE;
  Tcl_Namespace *execNsPtr = NULL;
  unsigned int   checkAlwaysFlag = 0u;
#if defined(NSF_WITH_ASSERTIONS)
  NsfObjectOpt  *opt;
#endif
#if defined(NRE)
  ParseContext  *pcPtr = NULL;
#else
  ParseContext   pc, *pcPtr = &pc;
#endif

  nonnull_assert(cp != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);
  nonnull_assert(methodName != NULL);
  nonnull_assert(cmdPtr != NULL);
  nonnull_assert(cscPtr != NULL);
  nonnull_assert(object != NULL);

  assert(object->teardown != NULL);

#if defined(NRE)
  /*fprintf(stderr, "ProcMethodDispatch cmd %s\n", Tcl_GetCommandName(interp, cmdPtr));*/
  assert((cscPtr->flags & NSF_CSC_CALL_IS_NRE) != 0u);
#endif

  /*
   * If this is a filter, call its guard if applicable.  Otherwise, step
   * forward to the next filter.
   */

  if (unlikely(cscPtr->frameType == NSF_CSC_TYPE_ACTIVE_FILTER)) {
    NsfCmdList *cmdList;
    /*
     * Search for cmd in the filterOrder of the obj.
     */
    assert((object->flags & NSF_FILTER_ORDER_VALID) != 0u);
    /* otherwise: FilterComputeDefined(interp, object);*/

    for (cmdList = object->filterOrder;
         (cmdList != NULL) && (cmdList->cmdPtr != cmdPtr);
         cmdList = cmdList->nextPtr) {
      ;
    }

    if (cmdList != NULL) {
      /*
       * A filter was found. Call the guard if there is one.
       */
      if (cmdList->clientData != NULL) {
        result = GuardCall(object, interp, cmdList->clientData, cscPtr);
      } else {
        result = TCL_OK;
      }

      if (unlikely(result != TCL_OK)) {
        /*fprintf(stderr, "Filter GuardCall in invokeProc returned %d\n", result);*/

        if (likely(result != TCL_ERROR)) {
          /*
           * The guard did not return success, but it did not return error
           * either. Call "next".  Since this may not be a method with already
           * provided arguments, call next with the actual arguments and
           * perform no argument substitution.
           *
           * The call stack content is not yet pushed to the Tcl
           * stack. Pass it to search-and-invoke.
           */

          /*fprintf(stderr, "... calling nextmethod cscPtr %p\n", cscPtr);*/
          result = NextSearchAndInvoke(interp, methodName, objc, objv, cscPtr, NSF_FALSE);
          /*fprintf(stderr, "... after nextmethod result %d\n", result);*/
        }

        /*
         * Conclude regardless of whether Next succeeded.  CscFinish handles
         * the NRE-case for all return codes.
         */
#if defined(NRE)
        CscFinish(interp, cscPtr, result, "guard failed");
#endif
        return result;
      }
    }
  }

#if defined(NSF_WITH_ASSERTIONS)
  opt = object->opt;
  if (unlikely(opt != NULL && (opt->checkoptions & CHECK_PRE)) &&
      (result = AssertionCheck(interp, object, class, methodName, CHECK_PRE)) == TCL_ERROR) {
    goto prep_done;
  }
#endif

  /*
   *  If the method to be invoked has paramDefs, call the argument parser with
   *  the argument definitions obtained from the proc context from the cmdPtr.
   */
  paramDefs = ParamDefsGet(cmdPtr, &checkAlwaysFlag, &execNsPtr);

  if (paramDefs != NULL && paramDefs->paramsPtr != NULL) {
#if defined(NRE)
    pcPtr = (ParseContext *) NsfTclStackAlloc(interp, sizeof(ParseContext), "parse context");
#endif
    result = ProcessMethodArguments(pcPtr, interp, object,
                                    checkAlwaysFlag|NSF_ARGPARSE_METHOD_PUSH|NSF_ARGPARSE_FORCE_REQUIRED,
                                    paramDefs, objv[0], objc, objv);
    cscPtr->objc = objc;
    cscPtr->objv = (Tcl_Obj **)objv;

    if (likely(result == TCL_OK)) {
      releasePc = NSF_TRUE;
      result = PushProcCallFrame(cp, interp, pcPtr->objc+1, pcPtr->full_objv, execNsPtr, cscPtr);
    } else {
      /*
       * some error occurred
       */
#if defined(NRE)
      ParseContextRelease(pcPtr);
      NsfTclStackFree(interp, pcPtr, "parse context (proc prep failed)");
      pcPtr = NULL;
#else
      ParseContextRelease(pcPtr);
#endif
    }
  } else {
    /*if (execNsPtr == NULL) {
      fprintf(stderr, "PushProcCallFrame for %s without method arguments and empty execNsPtr %p\n",
              methodName, (void*)execNsPtr);
              }*/
    result = PushProcCallFrame(cp, interp, objc, objv, execNsPtr, cscPtr);
  }

  /*
   * The stack frame is pushed.  This would be the place for any action prior
   * to running the byte code for the body.
   */

  /* Consider running ARG_METHOD or ARG_INITCMD here.
  if (likely(result == TCL_OK)) {

  }
  */

#if defined(NSF_WITH_ASSERTIONS)
 prep_done:
#endif

  if (likely(result == TCL_OK)) {
#if defined(NRE)
    /*fprintf(stderr, "CALL TclNRInterpProcCore %s method '%s'\n",
      ObjectName(object), ObjStr(objv[0]));*/
    Tcl_NRAddCallback(interp, ProcMethodDispatchFinalize,
                      (releasePc ? pcPtr : NULL),
                      cscPtr,
                      (ClientData)methodName,
                      NULL);
    cscPtr->flags |= NSF_CSC_CALL_IS_NRE;
    result = TclNRInterpProcCore(interp, objv[0], 1, &MakeProcError);
#else
    ClientData data[3] = {
      (releasePc ? pcPtr : NULL),
      cscPtr,
      (ClientData)methodName
    };

    result = TclObjInterpProcCore(interp, objv[0], 1, &MakeProcError);
    result = ProcMethodDispatchFinalize(data, interp, result);
#endif
  } else /* result != OK */ {
#if defined(NRE)
    CscFinish(interp, cscPtr, result, "nre, prep failed");
#endif
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * CmdMethodDispatch --
 *
 *    Invokes a method implemented as a cmd:  Optionally stacks a frame, calls
 *    the method, pops the frame, and runs invariants.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */
static int CmdMethodDispatch(
    ClientData cp, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[],
    NsfObject *object, Tcl_Command cmd, NsfCallStackContent *cscPtr
) nonnull(2) nonnull(4) nonnull(5) nonnull(6);

static int
CmdMethodDispatch(
    ClientData cp, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[],
    NsfObject *object, Tcl_Command cmd, NsfCallStackContent *cscPtr
) {
  CallFrame frame, *framePtr = &frame;
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);
  nonnull_assert(cmd != NULL);
  nonnull_assert(object != NULL);

  assert(object->teardown != NULL);

#if defined(NRE)
  assert(!cscPtr || (cscPtr->flags & NSF_CSC_CALL_IS_NRE) == 0u);
#endif

  if (cscPtr != NULL) {
    /*
     * Method dispatch does not on its own store the call-stack content in a
     * corresponding call frame.  Introduce a CMETHOD frame, e.g. to get
     * self-introspection working.
     */
    /*fprintf(stderr, "Nsf_PushFrameCsc %s %s\n", ObjectName(object), Tcl_GetCommandName(interp, cmd));*/
    Nsf_PushFrameCsc(interp, cscPtr, framePtr);
    result = Tcl_NRCallObjProc(interp, Tcl_Command_objProc(cmd), cp, objc, objv);
    Nsf_PopFrameCsc(interp, framePtr);
  } else {
    result = Tcl_NRCallObjProc(interp, Tcl_Command_objProc(cmd), cp, objc, objv);
  }

#if defined(NSF_WITH_ASSERTIONS)
  /*
   * Reference counting in the calling ObjectDispatch() ensures
   * that obj->opt is still accessible even after "dealloc".
   */
  if (unlikely(object->opt != NULL) && likely(result == TCL_OK)) {
    CheckOptions co = object->opt->checkoptions;

    if ((co & CHECK_INVAR)) {
      int rc = AssertionCheckInvars(interp, object, Tcl_GetCommandName(interp, cmd), co);

      if (rc != TCL_OK) {
        result = rc;
      }
    }
  }
#endif

  return result;
}

/*
 *----------------------------------------------------------------------
 * ObjectCmdMethodDispatch --
 *
 *    Dispatches a method implemented as an object using the referenced
 *    object as a source for methods to be executed.  Used primarily to
 *    dispatch ensemble objects.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */

static int ObjectCmdMethodDispatch(
    NsfObject *invokedObject, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[],
    const char *methodName, NsfObject *callerSelf, NsfCallStackContent *cscPtr
) nonnull(1) nonnull(2) nonnull(4) nonnull(5) nonnull(6) nonnull(7);

static int
ObjectCmdMethodDispatch(
    NsfObject *invokedObject, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[],
    const char *methodName, NsfObject *callerSelf, NsfCallStackContent *cscPtr
) {
  CallFrame    frame, *framePtr = &frame;
  Tcl_Command  cmd, subMethodCmd;
  const char  *subMethodName;
  NsfObject   *actualSelf;
  NsfClass    *actualClass;
  int          result;

  nonnull_assert(invokedObject != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);
  nonnull_assert(methodName != NULL);
  nonnull_assert(callerSelf != NULL);
  nonnull_assert(cscPtr != NULL);

  cmd = cscPtr->cmdPtr;
  /*fprintf(stderr, "ObjectCmdMethodDispatch %p %s\n", cmd, Tcl_GetCommandName(interp, cmd));*/
  /*fprintf(stderr, "ObjectCmdMethodDispatch method %s invokedObject %p %s callerSelf %p %s\n",
          methodName, invokedObject, ObjectName(invokedObject),
          callerSelf, ObjectName(callerSelf));*/

  if (unlikely((invokedObject->flags & NSF_DELETED) != 0u)) {
    /*
     * This is a deleted object. Remove the alias. The cmd might be still
     * referenced in various entries in the call stack, but it is eventually
     * cleaned up as reference count dictates.
     */

    /*fprintf(stderr, "methodName %s found DELETED object with cmd %p my cscPtr %p\n",
      methodName, cmd, cscPtr);*/

    Tcl_DeleteCommandFromToken(interp, cmd);
    if (cscPtr->cl != NULL) {
      NsfInstanceMethodEpochIncr("DeleteObjectAlias");
    } else {
      NsfObjectMethodEpochIncr("DeleteObjectAlias");
    }

    NsfCleanupObject(invokedObject, "alias-delete1");
    return NsfPrintError(interp, "trying to dispatch deleted object via method '%s'",
                         methodName);
  }

  /*
   * Dispatch default methods if the object cmd was called without a reference
   * to a method.
   */
  if (unlikely(objc < 2)) {

    if ((invokedObject->flags & NSF_PER_OBJECT_DISPATCH) != 0u) {
      cscPtr->flags |= NSF_CSC_CALL_IS_ENSEMBLE;
    }
    Nsf_PushFrameCsc(interp, cscPtr, framePtr);
    result = DispatchDefaultMethod(interp, invokedObject, objv[0], NSF_CSC_IMMEDIATE);
    Nsf_PopFrameCsc(interp, framePtr);
    return result;
  }

  /*
   * NSF_KEEP_CALLER_SELF determines the values of actualSelf and actualClass.
   */
  if ((invokedObject->flags & NSF_KEEP_CALLER_SELF) != 0u) {
    actualSelf = callerSelf;
    actualClass = cscPtr->cl;
  } else {
    actualSelf = invokedObject;
    actualClass = NULL;
  }
  subMethodName = ObjStr(objv[1]);

  if ((invokedObject->flags & NSF_PER_OBJECT_DISPATCH) == 0u) {
    /*fprintf(stderr, "invokedObject %p %s methodName %s: no perobjectdispatch\n",
      invokedObject, ObjectName(invokedObject), methodName);*/
#if 0
    /*
     * One of two approaches is needed:
     *   Obtain the cmd from a method name and call e.g. MethodDispatch(), or
     *   pass a fully-qualified method name.
     *
     *   Pass both actualSelf and invokedObject to
     *   MethodDispatch/MethodDispatch.
     *
     *  TODO: maybe remove NSF_CM_KEEP_CALLER_SELF when done.
     */
    result = MethodDispatch(interp, nobjc+1, nobjv-1, cmd, object,
                            NULL /*NsfClass *cl*/,
                            Tcl_GetCommandName(interp, cmd),
                            NSF_CSC_TYPE_PLAIN, flags);
#endif
#if 1
    /*
     * Simple and brutal.
     */
    if (likely(invokedObject->nsPtr != NULL)) {
      subMethodCmd = FindMethod(invokedObject->nsPtr, subMethodName);
    } else {
      subMethodCmd = NULL;
    }

    if (subMethodCmd == NULL) {
      /*
       * no -system handling.
       */
      actualClass = SearchPLMethod(invokedObject->cl->order, subMethodName, &subMethodCmd,
                                   NSF_CMD_CALL_PRIVATE_METHOD);
    }
    if (likely(subMethodCmd != NULL)) {
      cscPtr->objc = objc;
      cscPtr->objv = objv;
      Nsf_PushFrameCsc(interp, cscPtr, framePtr);
      result = MethodDispatch(interp, objc-1, objv+1,
                              subMethodCmd, actualSelf, actualClass, subMethodName,
                              cscPtr->frameType|NSF_CSC_TYPE_ENSEMBLE,
                              (cscPtr->flags & 0xFF)|NSF_CSC_IMMEDIATE);
      Nsf_PopFrameCsc(interp, framePtr);
      return result;
    }

  /*fprintf(stderr, "... objv[0] %s cmd %p %s csc %p\n",
    ObjStr(objv[0]), subMethodCmd, subMethodName, cscPtr); */

#endif
    return ObjectDispatch(actualSelf, interp, objc, objv, NSF_CM_KEEP_CALLER_SELF);
  }

  /*
   * NSF_PER_OBJECT_DISPATCH is set.
   */

  if (likely(invokedObject->nsPtr != NULL)) {
    subMethodCmd = FindMethod(invokedObject->nsPtr, subMethodName);
  } else {
    subMethodCmd = NULL;
  }

#if 1
  if (subMethodCmd != NULL) {
    unsigned int cmdFlags = (unsigned int)Tcl_Command_flags(subMethodCmd);

    if ((cscPtr->flags & (NSF_CM_LOCAL_METHOD|NSF_CM_IGNORE_PERMISSIONS)) == 0u &&
        (cmdFlags & NSF_CMD_CALL_PRIVATE_METHOD) != 0u) {
      subMethodCmd = NULL;
    } else if (unlikely((cmdFlags & NSF_CMD_CALL_PROTECTED_METHOD) != 0u)) {
      const NsfObject *lastSelf;
      Tcl_CallFrame   *framePtr0;
      bool             withinEnsemble = ((cscPtr->frameType & NSF_CSC_TYPE_ENSEMBLE) != 0u);

      if (withinEnsemble) {
        Tcl_CallFrame *framePtr1;

        /* Alternatively: (void)NsfCallStackFindLastInvocation(interp, 0, &framePtr1); */
        (void)CallStackGetTopFrame(interp, &framePtr0);
        (void)CallStackFindEnsembleCsc(framePtr0, &framePtr1);
        /* NsfShowStack(interp);
           fprintf(stderr, "framePtr %p\n", framePtr1);*/
        if (framePtr1 != NULL) {
          lastSelf = GetSelfObj2(interp, framePtr1);
        } else {
          lastSelf = NULL;
        }
      } else {
        lastSelf = GetSelfObj(interp);
      }


      /* fprintf(stderr, "'%s (%s) == %s == %s? for %s\n", lastSelf != NULL ? ObjectName(lastSelf): "n/a",
              ObjectName(GetSelfObj(interp)), ObjectName(actualSelf), ObjectName(invokedObject), subMethodName); */

      if (actualSelf != lastSelf) {
        const char *path;
        Tcl_Obj *pathObj = NULL;

        if (withinEnsemble) {
          pathObj = NsfMethodNamePath(interp, framePtr0, methodName);
          INCR_REF_COUNT(pathObj);
          path = ObjStr(pathObj);
        } else {
          path = methodName;
        }

        NsfLog(interp, NSF_LOG_WARN, "'%s %s %s' fails since method %s.%s %s is protected",
               ObjectName(actualSelf), path, subMethodName, (actualClass != NULL) ?
               ClassName(actualClass) : ObjectName(actualSelf), path, subMethodName);

        subMethodCmd = NULL;
        if (pathObj != NULL) {
          DECR_REF_COUNT(pathObj);
        }
      }
    }
  }
#endif


  /*
   * Mark the current call as an ensemble call, both for dispatching to the
   * default-method and for dispatching the method interface of the given
   * object. Otherwise, current introspection specific to submethods fails,
   * e.g., on [current method-path] in the default-method.
   */
  cscPtr->flags |= NSF_CSC_CALL_IS_ENSEMBLE;

  /* fprintf(stderr, "ensemble dispatch cp %s %s objc %d\n",
     ObjectName((NsfObject*)cp), methodName, objc);*/

  cscPtr->objc = objc;
  cscPtr->objv = objv;
  Nsf_PushFrameCsc(interp, cscPtr, framePtr);

  /*fprintf(stderr, "... objv[0] %s cmd %p %s csc %p\n",
    ObjStr(objv[0]), subMethodCmd, subMethodName, cscPtr); */

  if (likely(subMethodCmd != NULL)) {
    /*
     * An extra call frame is needed So that [next] may be called in an
     * ensemble method. This CSC frame is typed as NSF_CSC_TYPE_ENSEMBLE.  Also
     * add the NSF_CSC_CALL_IS_ENSEMBLE flag to the frame to identify
     * ensemble-specific frames during [next] execution.
     *
     * Set NSF_CSC_IMMEDIATE to ensure that scripted methods are executed
     * before the ensemble ends. If they were executed later, their parent
     * frame, CMETHOD, would already be popped.
     */

    /*fprintf(stderr, ".... ensemble dispatch object %s self %s pass %s\n",
      ObjectName(invokedObject), ObjectName(actualSelf), (actualSelf->flags & NSF_KEEP_CALLER_SELF) ? "callerSelf" : "invokedObject");
      fprintf(stderr, ".... ensemble dispatch on %s.%s objflags %.8x cscPtr %p base flags %.6x flags %.6x cl %s\n",
      ObjectName(actualSelf), subMethodName, actualSelf->flags,
      cscPtr, (0xFF & cscPtr->flags), (cscPtr->flags & 0xFF)|NSF_CSC_IMMEDIATE, (actualClass != NULL) ? ClassName(actualClass) : "NONE");*/
    result = MethodDispatch(interp, objc-1, objv+1,
                            subMethodCmd, actualSelf, actualClass, subMethodName,
                            cscPtr->frameType|NSF_CSC_TYPE_ENSEMBLE,
                            (cscPtr->flags & 0xFF)|NSF_CSC_IMMEDIATE);
    /*if (unlikely(result != TCL_OK)) {
      fprintf(stderr, "ERROR: cmd %p %s subMethodName %s -- %s -- %s\n",
      subMethodCmd, Tcl_GetCommandName(interp, subMethodCmd), subMethodName,
      Tcl_GetCommandName(interp, cscPtr->cmdPtr), ObjStr(Tcl_GetObjResult(interp)));
      }*/

  } else {
    /*
     * The method is not part of this ensemble. Call next so that it might be
     * found.
     */
    Tcl_CallFrame       *framePtr1;
    NsfCallStackContent *cscPtr1 = CallStackGetTopFrame(interp, &framePtr1);

    /*fprintf(stderr, "call next instead of unknown %s.%s \n",
      ObjectName(cscPtr->self), methodName);*/

    assert(cscPtr1 != NULL);
    if ((cscPtr1->frameType & NSF_CSC_TYPE_ENSEMBLE)) {
      /*
       * This is an ensemble method. [next] works here not on the actual
       * methodName + frame, but on the ensemble above it.  Locate the
       * appropriate call-stack content and continue next on that.
       */
      cscPtr1 = CallStackFindEnsembleCsc(framePtr1, &framePtr1);
      assert(cscPtr1 != NULL);
    }

    /*
     * Flag this as an ensemble whose cmd has not yet been found.  Try to
     * resolve the unknown subcommand via next, and record this in the flags.
     * The method name for next might be colon-prefixed so use MethodName() to
     * skip the single colon.
     */
    cscPtr1->flags |= NSF_CM_ENSEMBLE_UNKNOWN;
    /*fprintf(stderr, "==> trying to find <%s> in ensemble <%s> via next\n",
      subMethodName, MethodName(cscPtr1->objv[0]));*/
    result = NextSearchAndInvoke(interp, MethodName(cscPtr1->objv[0]),
                                 cscPtr1->objc, cscPtr1->objv, cscPtr1, NSF_FALSE);

    /*fprintf(stderr, "==> next %s.%s subMethodName %s (obj %s) cscPtr %p (flags %.8x)) cscPtr1 %p (flags %.8x) result %d unknown %d\n",
            ObjectName(callerSelf), methodName, subMethodName, ObjectName(invokedObject),
            (void*)cscPtr, cscPtr->flags, (void*)cscPtr1, (cscPtr1 != NULL) ? cscPtr1->flags : 0,
            result, RUNTIME_STATE(interp)->unknown);*/

    if (RUNTIME_STATE(interp)->unknown) {
      Tcl_Obj       *callInfoObj = Tcl_NewListObj(1, &callerSelf->cmdName);
      Tcl_CallFrame *varFramePtr, *tclFramePtr = CallStackGetTclFrame(interp, (Tcl_CallFrame *)framePtr, 1);
      int            pathLength, pathLength0 = 0, unknownIndex;
      Tcl_Obj       *pathObj = NsfMethodNamePath(interp, tclFramePtr, MethodName(objv[0]));
      bool           getPath = NSF_TRUE;

      INCR_REF_COUNT(pathObj);

      /*
       * The "next" call could not resolve the unknown subcommand. At this
       * point several different ensembles found on the stack may have been
       * tried.
       *
       * Example1:  call: foo a b d
       *    mixin:  foo a b c
       *    object: foo a x
       *
       * Return the longest, most precise prefix, e.g. "foo a b", and flag "d",
       * e.g. the mixin frame, as unknown. Another inferior solution would be
       * to report "foo a" as a known prefix and "b d" as unknown when the
       * error is generated from the point of view of the object method frame.
       *
       * In the general case, traverse the stack for all ensembles, select the
       * longest known ensemble, and pass it to the unknown handler of the
       * ensemble.
       */

      Tcl_ListObjLength(interp, pathObj, &pathLength0);
      pathLength = pathLength0;

      for (varFramePtr = (Tcl_CallFrame *)framePtr; likely(varFramePtr != NULL);
           varFramePtr = Tcl_CallFrame_callerVarPtr(varFramePtr)) {
        const NsfCallStackContent *stackCscPtr;

        /*
         * If this is a non-Nsf frame or not an ensemble, there is nothing more
         * to do.
         */
        stackCscPtr =
          (((unsigned int)Tcl_CallFrame_isProcCallFrame(varFramePtr) & (FRAME_IS_NSF_METHOD|FRAME_IS_NSF_CMETHOD)) != 0u) ?
          ((NsfCallStackContent *)Tcl_CallFrame_clientData(varFramePtr)) : NULL;
        if (stackCscPtr == NULL || (stackCscPtr->flags & NSF_CSC_CALL_IS_ENSEMBLE) == 0u) {
          break;
        }
        /*
         * Every ensemble block starts with a frame of NSF_CSC_TYPE_ENSEMBLE.
         * If one is found, compute a new path in the next iteration.
         */
        if ((stackCscPtr->frameType & (NSF_CSC_TYPE_ENSEMBLE)) == 0) {
          /*
           * Get the method path for the next round.
           */
          getPath = NSF_TRUE;
        } else if (getPath) {
          int      pathLength1;
          Tcl_Obj *pathObj1 = CallStackMethodPath(interp, varFramePtr);

          INCR_REF_COUNT(pathObj1);
          getPath = NSF_FALSE;
          Tcl_ListObjLength(interp, pathObj1, &pathLength1);
          if (pathLength1 > pathLength) {
            if (pathObj != NULL) {
              DECR_REF_COUNT(pathObj);
            }
            pathObj    = pathObj1;
            pathLength = pathLength1;
          } else {
            DECR_REF_COUNT(pathObj1);
          }
        }
      }

      unknownIndex = pathLength <= pathLength0 ? 1 : 1 + pathLength - pathLength0;
      assert(objc > unknownIndex);

      INCR_REF_COUNT(callInfoObj);
      Tcl_ListObjAppendList(interp, callInfoObj, pathObj);
      Tcl_ListObjAppendElement(interp, callInfoObj, objv[unknownIndex]);

      /* fprintf(stderr, "DispatchUnknownMethod is called with callinfo <%s> (callerSelf <%s>, methodName '%s', methodPath '%s')\n",
              ObjStr(callInfoObj), ObjStr(callerSelf->cmdName), MethodName(objv[0]),
              ObjStr(callInfoObj)); */
      result = DispatchUnknownMethod(interp, invokedObject, objc-1, objv+1, callInfoObj,
                                     objv[1], NSF_CM_NO_OBJECT_METHOD|NSF_CSC_IMMEDIATE);
      DECR_REF_COUNT(callInfoObj);
      DECR_REF_COUNT(pathObj);
    }
  }
  Nsf_PopFrameCsc(interp, framePtr);

  return result;
}

#if !defined(NSF_ASSEMBLE)
static int NsfAsmProc(ClientData UNUSED(clientData), Tcl_Interp *UNUSED(interp),
                      int UNUSED(objc), Tcl_Obj *const UNUSED(objv[])) {
  return TCL_OK;
}
#endif


/*
 *----------------------------------------------------------------------
 * CheckCStack --
 *
 *    Monitors the growth of the C Stack if compiled with NSF_STACKCHECK.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Updates rst->bottomOfStack.
 *
 *----------------------------------------------------------------------
 */
#if defined(NSF_STACKCHECK)
NSF_INLINE static void CheckCStack(Tcl_Interp *interp, const char *prefix, const char *fullMethodName)
  nonnull(1) nonnull(2) nonnull(3);

NSF_INLINE static void
CheckCStack(Tcl_Interp *interp, const char *prefix, const char *fullMethodName) {
  int somevar;
  NsfRuntimeState *rst = RUNTIME_STATE(interp);

  nonnull_assert(interp != NULL);
  nonnull_assert(prefix != NULL);
  nonnull_assert(fullMethodName != NULL);

  if (rst->exitHandlerDestroyRound == NSF_EXITHANDLER_OFF) {
# if TCL_STACK_GROWS_UP
    if ((void *)&somevar < rst->bottomOfStack) {
      NsfLog(interp, NSF_LOG_WARN, "Stack adjust bottom %ld - %s %s",
             (void *)&somevar - rst->bottomOfStack, prefix, fullMethodName);
      rst->bottomOfStack = (void *)&somevar;
    } else if ((void *)&somevar > rst->maxStack) {
      NsfLog(interp, NSF_LOG_WARN, "Stack adjust top %ld - %s %s",
             (void *)&somevar - rst->bottomOfStack, prefix, fullMethodName);
      rst->maxStack = (void *)&somevar;
    }
# else
    if ((void *)&somevar > rst->bottomOfStack) {
      NsfLog(interp, NSF_LOG_WARN, "Stack adjust bottom %ld - %s %s",
             rst->bottomOfStack - (void *)&somevar, prefix, fullMethodName);
      rst->bottomOfStack = (void *)&somevar;
    } else if ((void *)&somevar < rst->maxStack) {
      NsfLog(interp, NSF_LOG_WARN, "Stack adjust top %ld - %s %s",
             rst->bottomOfStack - (void *)&somevar, prefix, fullMethodName);
      rst->maxStack = (void *)&somevar;
    }
# endif
  }
}
#else
# define CheckCStack(interp, prefix, methodName)
#endif

/*
 *----------------------------------------------------------------------
 * MethodDispatchCsc --
 *
 *    Dispatches a scripted or command method in the given call-stack context.
 *    Calls ProcMethodDispatch() for scripted methods, and CmdMethodDispatch()
 *    otherwise.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */
static int MethodDispatchCsc(
    ClientData clientData, Tcl_Interp *interp,
    int objc, Tcl_Obj *const objv[],
    Tcl_Command cmd,
    NsfCallStackContent *cscPtr,
    const char *methodName,
    bool *validCscPtr
) nonnull(1) nonnull(2) nonnull(4) nonnull(5) nonnull(6) nonnull(7) nonnull(8);

static int
MethodDispatchCsc(
    ClientData clientData, Tcl_Interp *interp,
    int objc, Tcl_Obj *const objv[],
    Tcl_Command cmd,
    NsfCallStackContent *cscPtr,
    const char *methodName,
    bool *validCscPtr
) {
  NsfObject           *object;
  ClientData           cp;
  Tcl_ObjCmdProc      *proc;
  NsfCallStackContent *cscPtr1;

  nonnull_assert(clientData != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);
  nonnull_assert(cmd != NULL);
  nonnull_assert(cscPtr != NULL);
  nonnull_assert(methodName != NULL);
  nonnull_assert(validCscPtr != NULL);

  cp = Tcl_Command_objClientData(cmd);
  proc = Tcl_Command_objProc(cmd);
  object = cscPtr->self;

  /*
   * Provide calling info for DTrace.
   */
  if (NSF_DTRACE_METHOD_ENTRY_ENABLED()) {
    NSF_DTRACE_METHOD_ENTRY(ObjectName(object), (cscPtr->cl != NULL) ? ClassName(cscPtr->cl) : ObjectName(object),
                            (char *)methodName,
                            objc-1, (Tcl_Obj **)objv+1);
  }
  if (unlikely(((unsigned int)Tcl_Command_flags(cmd) & NSF_CMD_DEPRECATED_METHOD) != 0u)) {
    NsfProfileDeprecatedCall(interp, object, cscPtr->cl, methodName, "");
  }
  if (unlikely(((unsigned int)Tcl_Command_flags(cmd) & NSF_CMD_DEBUG_METHOD) != 0u)) {
    NsfProfileDebugCall(interp, object, cscPtr->cl, methodName, objc-1, (Tcl_Obj **)objv+1);
  }

  /*fprintf(stderr, "MethodDispatch method '%s' cmd %p %s clientData %p cp=%p objc=%d cscPtr %p csc->flags %.6x \n",
          methodName, cmd, Tcl_GetCommandName(interp, cmd), clientData,
          cp, objc, cscPtr, cscPtr->flags);*/
  /*fprintf(stderr, "MethodDispatch method '%s' cmd %p cp=%p objc=%d cscPtr %p csc->flags %.6x "
          "obj->flags %.6x teardown %p\n",
          methodName, cmd, cp, objc, cscPtr, cscPtr->flags, object->flags, object->teardown);*/
  assert(object->teardown != NULL);

  /*
   * By default, assumpe that CscPtr is valid after this function finishes.
   */

  if (likely(proc == TclObjInterpProc)) {
    int           result;
#if defined(NRE)
    NRE_callback *rootPtr = TOP_CB(interp);
    int           isImmediate = (cscPtr->flags & NSF_CSC_IMMEDIATE);
# if defined(NRE_CALLBACK_TRACE)
    NsfClass     *class = cscPtr->cl;
# endif
#endif
    /*
     * cmd is a scripted method.
     */

    result = ProcMethodDispatch(cp, interp, objc, objv, methodName,
                                object, cscPtr->cl, cmd, cscPtr);
#if defined(NRE)
    /*
     * In the NRE case the call stack context might already be gone.
     */
    *validCscPtr = NSF_FALSE;

    if (unlikely(isImmediate)) {
# if defined(NRE_CALLBACK_TRACE)
      fprintf(stderr, ".... manual run callbacks rootPtr = %p, result %d methodName %s.%s\n",
              rootPtr, result, ClassName(class), methodName);
# endif
      result = NsfNRRunCallbacks(interp, result, rootPtr);
    } else {
# if defined(NRE_CALLBACK_TRACE)
      fprintf(stderr, ".... don't run callbacks rootPtr = %p, result %d methodName %s.%s\n",
              rootPtr, result, ClassName(class), methodName);
# endif
    }
#endif
    /*
     * Scripted method done.
     */
    return result;

  } else if (proc == NsfObjDispatch) {

    assert(cp != NULL);
    return ObjectCmdMethodDispatch((NsfObject *)cp, interp, objc, objv,
                                   methodName, object, cscPtr);

  } else if (cp != NULL) {

    cscPtr1 = cscPtr;

    /*fprintf(stderr, "cscPtr %p cmd %p %s want to stack cmd %p %s cp %p no-leaf %d force frame %d\n",
            cscPtr, cmd, Tcl_GetCommandName(interp, cmd),
            cmd, Tcl_GetCommandName(interp, cmd),
            cp,
            (Tcl_Command_flags(cmd) & NSF_CMD_NONLEAF_METHOD),
            (cscPtr->flags & NSF_CSC_FORCE_FRAME));*/
    /*
     * There is clientData. Check this structure for required updates.
     */

    if (proc == NsfForwardMethod ||
        proc == NsfObjscopedMethod ||
        proc == NsfSetterMethod ||
        proc == NsfAsmProc
        ) {
      TclCmdClientData *tcd = (TclCmdClientData *)cp;

      assert(tcd != NULL);
      tcd->object = object;
      assert(!CmdIsProc(cmd));

    } else if (cp == (ClientData)NSF_CMD_NONLEAF_METHOD) {
      cp = clientData;
      assert(!CmdIsProc(cmd));

    }
#if !defined(NDEBUG)
    else if (proc == NsfProcAliasMethod) {
      /*
       * This should never happen!
       */
      Tcl_Panic("Alias invoked in unexpected way");
    }
#endif


  } else if (((unsigned int)Tcl_Command_flags(cmd) & NSF_CMD_NONLEAF_METHOD) != 0u
             || ((cscPtr->flags & NSF_CSC_FORCE_FRAME) != 0u)) {
    /*
     * A frame would be required to execute the cmd, but the user might want it
     * for other reasons, e.g.  to call "next" to or to the keep proc-level
     * variables.  In such cases clientData is typically NULL.
     */
    /*fprintf(stderr, "FORCE_FRAME\n");*/
    cscPtr1 = cscPtr;

  } else {
    /*
     * There is no need to pass a frame. Use the original clientData.
     */
    cscPtr1 = NULL;
  }

  if (cscPtr1 != NULL) {
    /*
     * Call with a stack frame.
     */

    /*fprintf(stderr, "cmdMethodDispatch %s.%s, cscPtr %p objflags %.6x\n",
      ObjectName(object), methodName, cscPtr, object->flags); */

    return CmdMethodDispatch(cp, interp, objc, objv, object, cmd, cscPtr1);
  } else {
    /*
     * Call without a stack frame.
     */
    CscListAdd(interp, cscPtr);

    /*fprintf(stderr, "cmdMethodDispatch %p %s.%s, nothing stacked, objflags %.6x\n",
      cmd, ObjectName(object), methodName, object->flags); */

    return CmdMethodDispatch(clientData, interp, objc, objv, object, cmd, NULL);
  }
}

/*
 *----------------------------------------------------------------------
 * MethodDispatch --
 *
 *    Convenience wrapper for MethodDispatchCsc(). Allocates call
 *    stack content and invokes MethodDispatchCsc.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */
static int
MethodDispatch(Tcl_Interp *interp, int objc, Tcl_Obj *const objv[],
               Tcl_Command cmd, NsfObject *object, NsfClass *class,
               const char *methodName, unsigned short frameType, unsigned int flags) {
  NsfCallStackContent csc, *cscPtr;
  bool                isValidCsc = NSF_TRUE;
  Tcl_Command         resolvedCmd;
  int                 result;

  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);
  nonnull_assert(cmd != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodName != NULL);

  assert(object->teardown != NULL);

  CheckCStack(interp, "method", methodName);

  /*fprintf(stderr, "MethodDispatch method '%s.%s' objc %d flags %.6x\n",
    ObjectName(object), methodName, objc, flags); */

  resolvedCmd = AliasDereference(interp, object, methodName, cmd);
  if (unlikely(resolvedCmd == NULL)) {
    return TCL_ERROR;
  }

  /*
   * cscAlloc uses resolvedCmd for allocating the call stack content, and
   * sets the IS_NRE flag based on it. Use the original cmd in the call-stack
   * content structure for introspection.
   */
  cscPtr = CscAlloc(interp, &csc, resolvedCmd);

  /*
   * CscInit would would not be needed when cp (clientData) == NULL &&
   * !(Tcl_Command_flags(cmd) & NSF_CMD_NONLEAF_METHOD) TODO: Maybe pass cmd ==
   * NULL, but is this worth it?
   */
  CscInit(cscPtr, object, class, cmd, frameType, flags, methodName);

  result = MethodDispatchCsc(object, interp, objc, objv,
                             resolvedCmd, cscPtr, methodName, &isValidCsc);

#if defined(NRE)
  if (isValidCsc) {
    CscListRemove(interp, cscPtr, NULL);
    CscFinish(interp, cscPtr, result, "csc cleanup");
  }
#else
  CscListRemove(interp, cscPtr, NULL);
  CscFinish(interp, cscPtr, result, "csc cleanup");
#endif

  return result;
}

/*
 *----------------------------------------------------------------------
 * ObjectDispatchFinalize --
 *
 *    Called by ObjectDispatch() to look up and call all kinds of methods.
 *    Calls the unknown handler if necessary, and resets the filter and mixin
 *    stacks.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary due to ParameterCheck() and DispatchUnknownMethod().
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static int ObjectDispatchFinalize(Tcl_Interp *interp, NsfCallStackContent *cscPtr,
                                             int result /*, char *msg, const char *methodName*/)
  nonnull(1) nonnull(2);

NSF_INLINE static int
ObjectDispatchFinalize(Tcl_Interp *interp, NsfCallStackContent *cscPtr,
                       int result /*, char *msg, const char *methodName*/) {
  const NsfRuntimeState *rst;
  NsfObject             *object;
  unsigned int           flags;

  nonnull_assert(interp != NULL);
  nonnull_assert(cscPtr != NULL);

  object = cscPtr->self;
  assert(object != NULL);
  assert(object->id != NULL);

  flags = cscPtr->flags;
  rst = RUNTIME_STATE(interp);

  /*fprintf(stderr, "ObjectDispatchFinalize %p %s flags %.6x (%d) frame %.6x unk %d m %s\n",
          (void*)cscPtr, ObjectName(object), flags,
          result, cscPtr->frameType, RUNTIME_STATE(interp)->unknown,
          (cscPtr->cmdPtr != NULL) ? Tcl_GetCommandName(interp, cscPtr->cmdPtr) : "");*/

  /*
   * Check the return value if wanted.
   */
  if (likely((result == TCL_OK)
             && (cscPtr->cmdPtr != NULL)
             && (Tcl_Command_cmdEpoch(cscPtr->cmdPtr) == 0))) {
    Tcl_Obj *returnsObj = ParamDefsGetReturns(cscPtr->cmdPtr);

    if (returnsObj != NULL) {
      NsfObject     *ctxObject = (cscPtr->cl != NULL) ? (NsfObject *)cscPtr->cl : object;
      Tcl_Namespace *nsPtr = Tcl_Command_nsPtr(ctxObject->id);
      Tcl_Obj       *valueObj = Tcl_GetObjResult(interp);

      result = ParameterCheck(interp, returnsObj, valueObj, "return-value:",
                              rst->doCheckResults, NSF_FALSE, NSF_FALSE, NULL,
                              nsPtr != NULL ? nsPtr->fullName : NULL);
    }
  } else {
    /*fprintf(stderr, "We have no cmdPtr in cscPtr %p %s",  cscPtr, ObjectName(object));
    fprintf(stderr, "... cannot check return values!\n");*/
  }


  /*
   * On success, i.e no error occurred, check for unknown cases.
   */
  if (likely(result == TCL_OK)) {

    /*
     * When triggered via filter there might be NRE cases where the filter is
     * called from a filter, leading to an unknown cscPtr->objv.  However,
     * there is no need to dispatch the unknown method.
     */
    if (unlikely(((flags & NSF_CSC_METHOD_IS_UNKNOWN) != 0u)
                 || ((cscPtr->frameType == NSF_CSC_TYPE_ACTIVE_FILTER) && rst->unknown && (cscPtr->objv != NULL))
                 )) {
      result = DispatchUnknownMethod(interp, object,
                                     cscPtr->objc, cscPtr->objv, NULL, cscPtr->objv[0],
                                     (cscPtr->flags & NSF_CSC_CALL_NO_UNKNOWN)|NSF_CSC_IMMEDIATE);
    }
  }

  /*
   * Resetting mixin and filter stacks.
   */

  if (unlikely((flags & NSF_CSC_MIXIN_STACK_PUSHED) && object->mixinStack != NULL) != 0u) {
    /* fprintf(stderr, "MixinStackPop %s.%s %p %s\n",
       ObjectName(object), methodName, object->mixinStack, msg);*/
    MixinStackPop(object);
  }
  if (unlikely((flags & NSF_CSC_FILTER_STACK_PUSHED) && object->filterStack) != 0u) {
    /* fprintf(stderr, "FilterStackPop %s.%s %p %s\n",
       ObjectName(object), methodName, object->filterStack, msg);*/
    FilterStackPop(object);
  }

  return result;
}

/*#define INHERIT_CLASS_METHODS 1*/

#if defined(INHERIT_CLASS_METHODS)
static Tcl_Command NsfFindClassMethod(Tcl_Interp *interp, NsfClass *class, const char *methodName)
  nonnull(1) nonnull(2) nonnull(3);

static Tcl_Command
NsfFindClassMethod(Tcl_Interp *interp, NsfClass *class, const char *methodName) {
  Tcl_Command  cmd;
  NsfClasses  *p;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(methodName != NULL);

  /*fprintf(stderr, "NsfFindClassMethod %s %s\n", ClassName(class), methodName);*/
  for(p = PrecedenceOrder(class); p != NULL; p = p->nextPtr) {
    NsfClass      *currentClass = p->cl;
    Tcl_Namespace *nsPtr = currentClass->object.nsPtr;

    /*fprintf(stderr, "1 check for obj ns in class %s => %p\n",
      ClassName(currentClass), nsPtr);*/
    if (nsPtr != NULL) {
      cmd = FindMethod(nsPtr, methodName);
      /*fprintf(stderr, "1 lookup for method %s in class %s => %p\n",
        methodName, ClassName(currentClass), cmd);*/
      if (cmd != NULL) {
        return cmd;
      }
    }
  }
  return NULL;
}
#endif


/*
 *----------------------------------------------------------------------
 * CmdObjProcName --
 *
 *    Retursn the symbolic name for the objCmdProc of a Tcl_command, or
 *    "other".
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static const char *CmdObjProcName(
    Tcl_Command cmd
) nonnull(1) NSF_pure;

static const char *
CmdObjProcName(
    Tcl_Command cmd
) {
  const char     *result;
  Tcl_ObjCmdProc *proc;

  nonnull_assert(cmd != NULL);

  proc = Tcl_Command_objProc(cmd);
  if (CmdIsNsfObject(cmd)) {
    result = "object";
  } else if (CmdIsProc(cmd)) {
    result = "proc";
  } else if (proc == NsfForwardMethod) {
    result = "forward";
  } else if (proc == NsfProcAliasMethod) {
    result = "alias";
  } else if (proc == NsfODestroyMethodStub) {
    result = "destroy";
  } else if (proc == NsfCCreateMethodStub) {
    result = "create";
  } else if (proc == NsfCNewMethodStub) {
    result = "new";
  } else if (proc == NsfOConfigureMethodStub) {
    result = "configure";
  } else if (proc == NsfOVolatileMethodStub) {
    result = "volatile";
  } else if (proc == NsfOVolatile1MethodStub) {
    result = "volatile";
  } else if (proc == NsfOAutonameMethodStub) {
    result = "autoname";
  } else if (proc == NsfOUplevelMethodStub) {
    result = "uplevel";
  } else if (proc == NsfOUpvarMethodStub) {
    result = "upvar";
  } else if (proc == NsfObjscopedMethod) {
    result = "objscoped";
  } else if (proc == NsfProcStub) {
    result = "nsfproc";
  } else if (proc == NsfSetterMethod) {
    result = "setter";
  } else if (proc == NsfAsmProc) {
    result = "asm";
  } else if (proc == TclObjInterpProc) {
    result = "alt proc";
#if 0
  } else if (proc == Tcl_ApplyObjCmd) {
    result = "apply";
  } else if (proc == Tcl_EvalObjCmd) {
    result = "eval";
#endif
  } else {
    result = "unknown";
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * ColonCmdCacheSet --
 *
 *    Fills out an ColonCmdCacheSet entry.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

NSF_INLINE static void
ColonCmdCacheSet(
    NsfColonCmdContext *ccCtxPtr,
    NsfClass           *currentClass,
    unsigned int        methodEpoch,
    Tcl_Command         cmd,
    NsfClass           *class,
    unsigned int        flags
) {
  ccCtxPtr->context = currentClass;
  ccCtxPtr->methodEpoch = methodEpoch;
  ccCtxPtr->cmd = cmd;
  ccCtxPtr->class = class;
  ccCtxPtr->flags = flags;
}

#if defined(COLON_CMD_STATS)
static void ColonCmdCacheNew(NsfColonCmdContext *ccCtxPtr, Tcl_Obj *obj) {
  ccCtxPtr->hits = 0u;
  ccCtxPtr->invalidates = 0u;
  ccCtxPtr->requiredRefetches = 0u;
  ccCtxPtr->obj = obj;
  INCR_REF_COUNT(obj);
}
static void ColonCmdCacheInvalidate(NsfColonCmdContext *ccCtxPtr) {
  ccCtxPtr->invalidates ++;
}
static void ColonCmdCacheRequiredRefetch(NsfColonCmdContext *ccCtxPtr) {
  ccCtxPtr->requiredRefetches ++;
}
static void ColonCmdCacheHit(NsfColonCmdContext *ccCtxPtr) {
  ccCtxPtr->hits ++;
}
#else
#define ColonCmdCacheNew(ccCtxPtr, obj)
#define ColonCmdCacheInvalidate(ccCtxPtr)
#define ColonCmdCacheRequiredRefetch(ccCtxPtr)
#define ColonCmdCacheHit(ccCtxPtr)
#endif


#ifdef DO_CLEANUP
/*
 *----------------------------------------------------------------------
 * NsfColonCmdContextFree --
 *
 *    FreeProc for NsfColonCmdContext.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Frees memory.
 *
 *----------------------------------------------------------------------
 */
static void
NsfColonCmdContextFree(void *clientData) {
#if defined(COLON_CMD_STATS)
  NsfColonCmdContext *ccCtxPtr = clientData;

  fprintf(stderr, "### free colonCmdContext for %s: hits %lu invalidates %lu required-refetches %lu\n",
          ObjStr(ccCtxPtr->obj), (unsigned long)ccCtxPtr->hits,
          (unsigned long)ccCtxPtr->invalidates, (unsigned long)ccCtxPtr->requiredRefetches);
  DECR_REF_COUNT(ccCtxPtr->obj);
#endif
  FREE(NsfColonCmdContext, clientData);
}
#endif

/*
 *----------------------------------------------------------------------
 * CacheCmd --
 *
 *     Caches a Tcl_Command element in a Tcl_Obj, using either the Nsf-specific
 *     object types, or the colon cmd cache for Tcl cmd types.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Adda a cache entry.
 *
 *----------------------------------------------------------------------
 */
static void CacheCmd(
    Tcl_Interp        *interp,
    Tcl_Command        cmd,
    Tcl_Obj           *methodObj,
    const Tcl_ObjType *nsfObjTypePtr,
    void              *context,
    unsigned int       methodEpoch,
    NsfClass          *class,
    unsigned int       flags,
    bool               isColonCmd
) {
  const Tcl_ObjType *methodObjTypePtr = methodObj->typePtr;

  if (((methodObjTypePtr != Nsf_OT_tclCmdNameType))
      && (methodObjTypePtr != Nsf_OT_parsedVarNameType)
     ) {
    /*fprintf(stderr, "==== SET OBJ TYPE for %s.%s to NsfInstanceMethodObjType cmd %p\n",
      ObjectName(object), calledName, (void*)cmd);*/
    NsfMethodObjSet(interp, methodObj, nsfObjTypePtr,
                    context, methodEpoch, cmd, class, flags);

  } else if (isColonCmd && (methodObj->refCount > 1)) {
    /*
     * If the refCount <= 1, the object is a temporary object for which caching
     * is not useful. The following types could also be cached, but the benefit
     * is not clear.
     *
     *     (methodObjTypePtr != Nsf_OT_tclCmdNameType)
     *     || (Tcl_Command_objProc(cmd) == NsfProcAliasMethod)
     *
     */
    NsfColonCmdContext *ccCtxPtr = methodObj->internalRep.twoPtrValue.ptr2;

    if (ccCtxPtr != NULL) {
      /*
       * There is a ccCtxPtr already so the value was invalidated before.
       */
      ColonCmdCacheInvalidate(ccCtxPtr);

      if (ccCtxPtr->cmd != cmd) {
        /*
         * The cached cmd differs from actual one so this was a required
         * refetch operation where the invalidation was truly necessary.
         */
        ColonCmdCacheRequiredRefetch(ccCtxPtr);
      }
      ColonCmdCacheSet(ccCtxPtr, context, methodEpoch, cmd, class, flags);

    } else {
      NsfRuntimeState *rst = RUNTIME_STATE(interp);

      /*fprintf(stderr, "======== new entry for %p %s type %s refCount %d ccCtxPtr %p flags %.6x context %s\n",
              (void*)methodObj, ObjStr(methodObj), ObjTypeStr(methodObj),
              methodObj->refCount, (void*)ccCtxPtr, flags, ObjectName((NsfObject*)context));*/

      /*
       * Create an NsfColonCmdContext and supply it with data, primarily the
       * cmd.  The other data is for validation.
       */
      ccCtxPtr = NEW(NsfColonCmdContext);
      ColonCmdCacheNew(ccCtxPtr, methodObj);
      ColonCmdCacheSet(ccCtxPtr, context, methodEpoch, cmd, class, flags);

      /*
       * Save the NsfColonCmdContext in the proc context for memory management
       * and also for reuse in twoPtrValue.ptr2.
       */
      /* rst->freeListPtr = NsfListCons(ccCtxPtr, rst->freeListPtr); */
      NsfDListAppend(&rst->freeDList, ccCtxPtr);
      methodObj->internalRep.twoPtrValue.ptr2 = ccCtxPtr;

      /*fprintf(stderr, "==== ptr2 of %s empty, is set %p for obj %p %p %s target proc ctx %p ccCtx %p\n",
        ObjStr(methodObj),
        (void*)cmd, (void*)object, (void*)methodObj, ObjStr(methodObj),
        (void*)pCtxPtr, (void*)pCtxPtr->freeListObj);*/
    }
  } else {
    /*
     * Found a command, but do not cache it...
     */
    /* fprintf(stderr, "... found cmd '%s' type of methodObj '%s' type %s, procType %s but we do not cache\n",
       Tcl_GetCommandName(NULL, cmd), ObjStr(methodObj),
       methodObjTypePtr ? methodObjTypePtr->name : "NONE",
       CmdObjProcName(cmd));*/
  }
}

/*
 *----------------------------------------------------------------------
 * ObjectDispatch --
 *
 *    Resolves and calls all kinds of methods, applying filters and/or mixins
 *    as required.  For filters and mixins "next" effectively resolves and
 *    calls the method.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary due to ParameterCheck() or DispatchUnknownMethod().
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static int ObjectDispatch(ClientData clientData, Tcl_Interp *interp,
                                     int objc, Tcl_Obj *const objv[],
                                     unsigned int flags)
  nonnull(1) nonnull(2) nonnull(4);

NSF_INLINE static int
ObjectDispatch(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *const objv[],
    unsigned int flags
) {
  int                    result = TCL_OK, shift;
  bool                   isValidCsc = NSF_TRUE;
  unsigned int           objflags;
  unsigned short         frameType = NSF_CSC_TYPE_PLAIN;
  register NsfObject    *object;
  const char            *methodName, *calledName;
  NsfObject             *calledObject;
  NsfClass              *class = NULL;
  Tcl_Obj               *cmdName, *methodObj;
  const Tcl_ObjType     *methodObjTypePtr;
  NsfColonCmdContext    *ccCtxPtr;
  const NsfRuntimeState *rst;
  NsfCallStackContent    csc, *cscPtr = NULL;
  Tcl_Command            cmd = NULL;

  nonnull_assert(clientData != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);

  object = (NsfObject *)clientData;
  cmdName = object->cmdName;
  rst = RUNTIME_STATE(interp);

  /*
   * Don't pass any of the higher copy flags.
   */
  assert((flags & (NSF_CSC_COPY_FLAGS & 0x000FFF000U)) == 0u);

  /*
   * Shift the arguments?
   */
  if (unlikely((flags & NSF_CM_NO_SHIFT) != 0u)) {
    shift = 0;
    methodObj = objv[0];
    methodName = MethodName(methodObj);
    calledName =  ObjStr(methodObj);;

  } else {
    assert(objc > 1);
    shift = 1;
    methodObj = objv[1];
    methodName = ObjStr(methodObj);
    calledName = methodName;
    if (unlikely(FOR_COLON_RESOLVER(methodName))) {
      return NsfPrintError(interp, "%s: method name '%s' must not start with a colon",
                           ObjectName_(object), methodName);
    }
  }
  methodObjTypePtr = methodObj->typePtr;
  ccCtxPtr = methodObj->internalRep.twoPtrValue.ptr2;


  assert(object->teardown != NULL);

#if defined(METHOD_OBJECT_TRACE)
  fprintf(stderr, "method %p/%d '%s' type %p <%s>\n",
          methodObj, methodObj->refCount, methodName, methodObjTypePtr,
          (methodObjTypePtr != NULL) ? methodObjTypePtr->name : "");
#endif
  /*fprintf(stderr, "==== ObjectDispatch obj = %s objc = %d 0=%s methodName=%s method-obj-type %s cmd %p shift %d\n",
          (object != NULL) ? ObjectName(object) : NULL,
          objc, objv[0] ? ObjStr(objv[0]) : NULL,
          methodName, methodObjTypePtr ? methodObjTypePtr->name : "NONE",
          (void*)cmd, shift);*/

  objflags = object->flags; /* avoid stalling */

  /*
   * Preserve cmdName and obj until the end of this function.
   */
  INCR_REF_COUNT(cmdName);
  NsfObjectRefCountIncr(object);

  /*fprintf(stderr, "obj refCount of %p after incr %d (ObjectDispatch) %s\n",
    object, object->refCount, methodName);*/

  if (unlikely((objflags & NSF_FILTER_ORDER_VALID) == 0u)) {
    FilterComputeDefined(interp, object);
    objflags = object->flags;
  }

  if (unlikely((objflags & NSF_MIXIN_ORDER_VALID) == 0u)) {
    MixinComputeDefined(interp, object);
    objflags = object->flags;
  }

  /*
   * Only start a new filter chain if
   *   (a) filters are defined and
   *   (b) the toplevel csc entry is not a filter on self
   */

  /*fprintf(stderr, "call %s, objflags %.6x, defined and valid %.6x doFilters %d guard count %d\n",
          methodName, objflags, NSF_FILTER_ORDER_DEFINED_AND_VALID,
          rst->doFilters, rst->guardCount);*/

  assert((flags & (NSF_CSC_MIXIN_STACK_PUSHED|NSF_CSC_FILTER_STACK_PUSHED)) == 0u);

  if (unlikely((objflags & NSF_FILTER_ORDER_DEFINED_AND_VALID) == NSF_FILTER_ORDER_DEFINED_AND_VALID)) {
    if (rst->doFilters && !rst->guardCount) {
      const NsfCallStackContent *cscPtr1 = CallStackGetTopFrame0(interp);

      if ((cscPtr1 == NULL)
          || (object != cscPtr1->self)
          || (cscPtr1->frameType != NSF_CSC_TYPE_ACTIVE_FILTER)
         ) {
        FilterStackPush(object, methodObj);
        flags |= NSF_CSC_FILTER_STACK_PUSHED;

        cmd = FilterSearchProc(interp, object, &object->filterStack->currentCmdPtr, &class);
        if (cmd != NULL) {
          /*fprintf(stderr, "*** filterSearchProc returned cmd %p\n", cmd);*/
          frameType = NSF_CSC_TYPE_ACTIVE_FILTER;
          methodName = (char *)Tcl_GetCommandName(interp, cmd);
          flags |= NSF_CM_IGNORE_PERMISSIONS;
        }
      }
    }
  }

  if (unlikely(cmd == NULL && ((flags & NSF_CM_LOCAL_METHOD) != 0u))) {
    /*
     * A local method is required. If the local method is found, set the
     * command and also set the class if the method is class-specific.
     */
    const NsfCallStackContent *cscPtr1 = CallStackGetTopFrame0(interp);

    if (unlikely(cscPtr1 == NULL)) {
      return NsfPrintError(interp, "flag '-local' only allowed when called from a method body");
    }
    if (cscPtr1->cl != NULL) {
      cmd = FindMethod(cscPtr1->cl->nsPtr, methodName);
      if (cmd != NULL) {
        class = cscPtr1->cl;
      }
    } else if (object->nsPtr != NULL) {
      cmd = FindMethod(object->nsPtr, methodName);
    }

    /*fprintf(stderr, "ObjectDispatch NSF_CM_LOCAL_METHOD obj %s methodName %s => cl %p %s cmd %p \n",
            (object != NULL) ? ObjectName(object) : NULL,
            methodName, (void*)class, (class != NULL) ? ClassName(class) : "NONE", (void*)cmd);*/

  } else if (unlikely(*methodName == ':')) {
    NsfObject *regObject;
    bool       fromClassNS = NSF_FALSE;

    /*
     * The name is fully-qualified.  Determine the class and/or
     * object on which the method is registered.
     */

    INCR_REF_COUNT(methodObj);
    cmd = ResolveMethodName(interp, NULL, methodObj,
                            NULL, &regObject, NULL, NULL, &fromClassNS);
    DECR_REF_COUNT(methodObj);

    if (likely(cmd != NULL)) {
      if (CmdIsNsfObject(cmd)) {
        /*
	 * Don't allow calling a method directly via fully-qualified name. If
	 * allowed, then in line [2] below ::State or any child of it, e.g.
	 * ::Slot::child, is interpreted as a method candidate, resulting in
	 * dispatch chaining, with ::State or ::State::child receiving the
	 * method call "-parameter" instead of Class receiving it. In such
	 * dispatch chaining the method "unknown" isn't called on Class as it
	 * normally would be in XOTcl, effectively bypassing any indirection
	 * mechanism based on "unknown", e.g. XOTcl's short-cutting of
	 * object/class creations.
         *
         *  [1] Class ::State; Class ::State::child
         *  [2] Class ::State -parameter x; Class ::State::child -parameter x
         */
        NsfLog(interp, NSF_LOG_NOTICE,
               "Don't invoke object %s this way. Register object via alias ...",
               methodName);
        cmd = NULL;
      } else {
        if (regObject != NULL) {
          if (NsfObjectIsClass(regObject)) {
            class = (NsfClass *)regObject;
          }
        }
        /* fprintf(stderr, "fully qualified lookup of %s returned %p\n", ObjStr(methodObj), cmd); */
        /*
         * Ignore permissions for fully-qualified method names.
         */
        flags |= NSF_CM_IGNORE_PERMISSIONS;
      }
      /*fprintf(stderr, "ObjectDispatch fully qualified obj %s methodName %s => cl %p cmd %p \n",
              (object != NULL) ? ObjectName(object) : NULL,
              methodName, (void*)cl, (void*)cmd);*/
    }
  }

  /*fprintf(stderr, "MixinStackPush check for %p %s.%s objflags %.6x == %d\n",
    object, ObjectName(object), methodName, objflags & NSF_MIXIN_ORDER_DEFINED_AND_VALID,
    (objflags & NSF_MIXIN_ORDER_DEFINED_AND_VALID) == NSF_MIXIN_ORDER_DEFINED_AND_VALID);*/
  /*
   * Is it necessary to call a mixed-in method? Check even if cmd is already
   * determined.
   */
  if (unlikely((objflags & NSF_MIXIN_ORDER_DEFINED_AND_VALID) == NSF_MIXIN_ORDER_DEFINED_AND_VALID
               && (flags & (NSF_CM_SYSTEM_METHOD|NSF_CM_INTRINSIC_METHOD)) == 0u
               && ((flags & NSF_CM_LOCAL_METHOD) == 0u || class != NULL))
     ) {
    /*
     * The current logic first allocates an entry on the per-object stack and
     * then searches for a mixin. This could be improved by allocating a stack
     * entry only when a mixin is found. The same holds for the filters above,
     * but there the hit-rate is much larger.
     */

    MixinStackPush(object);
    flags |= NSF_CSC_MIXIN_STACK_PUSHED;

    if (frameType != NSF_CSC_TYPE_ACTIVE_FILTER) {
      Tcl_Command cmd1 = cmd;
      /*
       * If there is no filter the entry is searched and pushed onto the stack.
       * If there is a filter the search happens in [next].
       */
      result = MixinSearchProc(interp, object, methodName, &class,
                               &object->mixinStack->currentCmdPtr, &cmd1);
      if (unlikely(result != TCL_OK)) {
        /*fprintf(stderr, "mixinsearch returned an error for %p %s.%s\n",
          object, ObjectName(object), methodName);*/
        isValidCsc = NSF_FALSE;
        goto exit_object_dispatch;
      }
      if (cmd1 != NULL) {
        frameType = NSF_CSC_TYPE_ACTIVE_MIXIN;
        cmd = cmd1;
      }
    }
  }

  /*fprintf(stderr, "ObjectDispatch ordinary lookup %s.%s cmd %p\n",
    ObjectName(object), ObjStr(methodObj), (void*)cmd);*/

  /*
   * If no fully-qualified method name/filter/mixin was found, perform ordinary
   * method resolution, attempting first to resolve the name as a per-object
   * method.
   */

  if (likely(cmd == NULL)) {
    NsfMethodContext *mcPtr = methodObj->internalRep.twoPtrValue.ptr1;
    unsigned int      nsfObjectMethodEpoch = rst->objectMethodEpoch;

    if (methodObjTypePtr == &NsfObjectMethodObjType
        && mcPtr->context == object
        && mcPtr->methodEpoch == nsfObjectMethodEpoch
        && mcPtr->flags == flags
        ) {
      cmd = mcPtr->cmd;

#if defined(METHOD_OBJECT_TRACE)
      fprintf(stderr, "... use internal rep method %p %s cmd %p (objProc %p) cl %p %s\n",
              (void*)methodObj, ObjStr(methodObj),
              (void*)cmd, (cmd != NULL) ? (void*)((Command *)cmd)->objProc : 0,
              (void*)cl, (class != NULL) ? ClassName(class) : ObjectName(object));
#endif

      assert((cmd != NULL) ? ((Command *)cmd)->objProc != NULL : 1);

    } else if (methodObjTypePtr == Nsf_OT_tclCmdNameType
               && ccCtxPtr != NULL
               && ccCtxPtr->context == object
               && ccCtxPtr->methodEpoch == nsfObjectMethodEpoch
               && ccCtxPtr->flags == flags
               ) {
      cmd = ccCtxPtr->cmd;
      class = ccCtxPtr ->class;
      ColonCmdCacheHit(ccCtxPtr);

    } else {
      /*
       * Attempt to resolve the name to an object-specific method.
       */
      if (unlikely((object->nsPtr != NULL)
                   && (flags & (NSF_CM_NO_OBJECT_METHOD|NSF_CM_SYSTEM_METHOD)) == 0u)) {
        cmd = FindMethod(object->nsPtr, methodName);
        /*fprintf(stderr, "ObjectDispatch lookup for per-object method in obj %p method %s nsPtr %p"
                " => %p objProc %p\n",
                (void*)object, methodName, (void*)object->nsPtr, (void*)cmd,
                (cmd != NULL) ? (void*)((Command *)cmd)->objProc : NULL);*/

        if (cmd != NULL) {
          /*
           * Reject the resolved command when
           * a) trying to call a private method without the local flag or ignore permissions, or
           * b) trying to call an object with no method interface
           */
          if (((flags & (NSF_CM_LOCAL_METHOD|NSF_CM_IGNORE_PERMISSIONS)) == 0u
               && ((unsigned int)Tcl_Command_flags(cmd) & NSF_CMD_CALL_PRIVATE_METHOD) != 0u)
              ) {
            cmd = NULL;
          } else {
            CacheCmd(interp,
                     cmd, methodObj, &NsfObjectMethodObjType,
                     object, nsfObjectMethodEpoch, NULL, flags,
                     (*calledName == ':'));
          }
        }
      }
    }
#if defined(INHERIT_CLASS_METHODS)
    /*
     * The current class might be checked twice but this non-optimized operation
     * is easier to maintain.
     */
    if ((flags & NSF_CM_NO_OBJECT_METHOD) == 0u && cmd == NULL && NsfObjectIsClass(object)) {
      cmd = NsfFindClassMethod(interp, (NsfClass *)object, methodName);
    }
#endif

    if (likely(cmd == NULL)) {
      /*
       * Is the method an object method?
       */
      NsfClass           *currentClass = object->cl;
      NsfMethodContext   *mcPtr0 = methodObj->internalRep.twoPtrValue.ptr1;
      unsigned int        nsfInstanceMethodEpoch = rst->instanceMethodEpoch;

#if defined(METHOD_OBJECT_TRACE)
      fprintf(stderr, "... method %p/%d '%s' type? %d context? %d nsfMethodEpoch %d => %d\n",
              methodObj, methodObj->refCount, ObjStr(methodObj),
              methodObjTypePtr == &NsfInstanceMethodObjType,
              methodObjTypePtr == &NsfInstanceMethodObjType ? mcPtr0->context == currentClass : 0,
              methodObjTypePtr == &NsfInstanceMethodObjType ? mcPtr0->methodEpoch : 0,
              nsfInstanceMethodEpoch );
#endif

      if (methodObjTypePtr == &NsfInstanceMethodObjType
          && mcPtr0->context == currentClass
          && mcPtr0->methodEpoch == nsfInstanceMethodEpoch
          && mcPtr0->flags == flags
          ) {
        cmd = mcPtr0->cmd;
        class = mcPtr0->cl;

#if defined(METHOD_OBJECT_TRACE)
        fprintf(stderr, "... use internal rep method %p %s cmd %p (objProc %p) cl %p %s\n",
                (void*)methodObj, ObjStr(methodObj),
                (void*)cmd, (cmd != NULL) ? (void*)((Command *)cmd)->objProc : NULL,
                (void*)class, (class != NULL) ? ClassName(class) : ObjectName(object));
#endif
        assert((cmd != NULL) ? ((Command *)cmd)->objProc != NULL : 1);

      } else if (methodObjTypePtr == Nsf_OT_tclCmdNameType
                 && ccCtxPtr != NULL
                 && ccCtxPtr->context == currentClass
                 && ccCtxPtr->methodEpoch == nsfInstanceMethodEpoch
                 && ccCtxPtr->flags == flags
          ) {
        cmd = ccCtxPtr->cmd;
        class = ccCtxPtr ->class;
        ColonCmdCacheHit(ccCtxPtr);

#if defined(METHOD_OBJECT_TRACE)
        fprintf(stderr, "... use internal rep ptr2 method %p %s cmd %p (objProc %p) cl %p %s\n",
                (void*)methodObj, ObjStr(methodObj),
                (void*)cmd, (cmd != NULL) ? (void*)((Command *)cmd)->objProc : NULL,
                (void*)class, (class != NULL) ? ClassName(class) : ObjectName(object));
#endif
      } else {

        /*
         * No need to PrecedenceOrder(currentClass) to recompute
         * currentClass->order because it is already constructed correctly
         * here.
         */
        assert(currentClass->order);

        if (unlikely((flags & NSF_CM_SYSTEM_METHOD) != 0u)) {
          NsfClasses *classListPtr = currentClass->order;

          /*
           * Skip to the first base class.
           */
          do {
            if (IsBaseClass(&classListPtr->cl->object)) {
              break;
            }
            classListPtr = classListPtr->nextPtr;
          } while (classListPtr->nextPtr != NULL);

          class = SearchPLMethod(classListPtr, methodName, &cmd, NSF_CMD_CALL_PRIVATE_METHOD);
        } else {
          class = SearchPLMethod(currentClass->order, methodName, &cmd, NSF_CMD_CALL_PRIVATE_METHOD);
        }

        /*fprintf(stderr, "... check type of methodObj %s type %s check %d\n",
                calledName, methodObjTypePtr ? methodObjTypePtr->name : "NONE",
                (((methodObjTypePtr != Nsf_OT_tclCmdNameType) || *calledName == ':')
                 && methodObjTypePtr != Nsf_OT_parsedVarNameType
                 && likely(cmd != NULL)  )
                 );*/
        if (likely(cmd != NULL)) {
          CacheCmd(interp,
                   cmd, methodObj, &NsfInstanceMethodObjType,
                   currentClass, nsfInstanceMethodEpoch, class, flags,
                   (*calledName == ':'));
        }
      }
    }
  }
  calledObject = object;

  /*
   * If the command exists and NSF_CM_IGNORE_PERMISSIONS is not set, check the
   * permissions. NSF_CM_IGNORE_PERMISSIONS is currently set for
   * fully-qualified cmd names, and also in nsf::object::dispatch.
   */

  if (likely((cmd != NULL) && (flags & NSF_CM_IGNORE_PERMISSIONS) == 0u)) {
    const unsigned int cmdFlags = (unsigned int)Tcl_Command_flags(cmd);

#if !defined(NDEBUG)
    if (unlikely(((cmdFlags & NSF_CMD_CALL_PRIVATE_METHOD) != 0u)
                 && ((flags & NSF_CM_LOCAL_METHOD) == 0u))
        ) {
      /*
       * Private methods can only be called with the "-local" flag, and all
       * cases handling private methods should be covered above, e.g. by
       * setting NSF_CM_IGNORE_PERMISSIONS or by filtering private during
       * method search, so this branch should never be executed.
       */

      Tcl_Panic("Unexpected handling of private method; most likely a caching bug");
      cmd = NULL;

    } else
#endif
    if (unlikely((cmdFlags & NSF_CMD_CALL_PROTECTED_METHOD) != 0u)) {
      const NsfObject *lastSelf = GetSelfObj(interp);

      /*
       * Allow a call to a protected method only if calling object == called
       * object.
       */

      if (unlikely(object != lastSelf)) {
        NsfLog(interp, NSF_LOG_WARN, "'%s %s' fails since method %s.%s is protected",
               ObjectName(object), methodName,
               (class != NULL) ? ClassName(class) : ObjectName(object),
               methodName);
        /*
         * Reset cmd since it is still unknown.
         */
        cmd = NULL;
      }
    }
  }

  assert(result == TCL_OK);

  if (likely(cmd != NULL)) {
    /*
     * There is a method to dispatch.
     */
    const Tcl_Command resolvedCmd = AliasDereference(interp, object, methodName, cmd);
    if (unlikely(resolvedCmd == NULL)) {
      isValidCsc = NSF_FALSE;
      goto exit_object_dispatch;
    }

    /*
     * cscAlloc uses resolvedCmd to allocate a stack frame, and sets the IS_NRE
     * flag based on it. The original command is stored in the stack frame for
     * introspection.
     */

    cscPtr = CscAlloc(interp, &csc, resolvedCmd);
    CscInit(cscPtr, calledObject, class, cmd, frameType, flags, methodName);

    if (unlikely(cscPtr->frameType == NSF_CSC_TYPE_ACTIVE_FILTER)) {
      /*
       * filter execution is not NRE-enabled.
       */
      cscPtr->flags |= NSF_CSC_IMMEDIATE;
      /*
       * set cscPtr->objc and cscPtr->objv to allow invoking UNKNOWN from
       * ProcMethodDispatchFinalize()
       */
      cscPtr->objc = objc - shift;
      cscPtr->objv = objv + shift;
    }

    /* fprintf(stderr, "MethodDispatchCsc %s.%s %p flags %.6x cscPtr %p method-obj-type %s\n",
            ObjectName(object), methodName, (void*)object->mixinStack, cscPtr->flags,
            (void*)cscPtr, methodObj->typePtr ? methodObj->typePtr->name : "NONE");*/

    result = MethodDispatchCsc(clientData, interp, objc - shift, objv + shift,
                               resolvedCmd, cscPtr, methodName, &isValidCsc);
    /* fprintf(stderr, "MethodDispatchCsc %s.%s %p flags %.6x cscPtr %p method-obj-type %s DONE\n",
            ObjectName(object), methodName, (void*)object->mixinStack, cscPtr->flags,
            (void*)cscPtr, methodObj->typePtr ? methodObj->typePtr->name : "NONE"); */

    if (unlikely(result == TCL_ERROR)) {
      /*fprintf(stderr, "Call ErrInProc cl = %p, cmd %p, methodName %s flags %.6x\n",
              class, (class != NULL) ? class->object.id : NULL, methodName, (class != NULL) ? class->object.flags : 0);*/

      result = NsfErrInProc(interp, cmdName,
                            (class != NULL && class->object.teardown) ? class->object.cmdName : NULL,
                            methodName);
    }
  } else {
    /*
     * The method to be dispatched is unknown.
     */
    cscPtr = CscAlloc(interp, &csc, cmd);
    CscInit(cscPtr, object, class, cmd, frameType, flags, methodName);
    cscPtr->flags |= NSF_CSC_METHOD_IS_UNKNOWN;
    if ((flags & NSF_CM_NO_UNKNOWN) != 0u) {
      cscPtr->flags |= NSF_CSC_CALL_NO_UNKNOWN;
    }
    cscPtr->objc = objc - shift;
    cscPtr->objv = objv + shift;
  }

 exit_object_dispatch:
  if (likely(isValidCsc)) {
    /*
     * There is now a cscPtr containing context information.
     */
    assert(cscPtr != NULL);

    result = ObjectDispatchFinalize(interp, cscPtr, result /*, "immediate" , methodName*/);
    CscListRemove(interp, cscPtr, NULL);
    CscFinish(interp, cscPtr, result, "non-scripted finalize");
  }

  /*fprintf(stderr, "ObjectDispatch %s.%s returns %d\n",
    ObjectName(object), methodName, result);*/

  NsfCleanupObject(object, "ObjectDispatch");
  /*fprintf(stderr, "ObjectDispatch call NsfCleanupObject %p DONE\n", object);*/
  DECR_REF_COUNT(cmdName); /* must be after last dereferencing of obj */

  return result;
}

/*
 *----------------------------------------------------------------------
 * DispatchDefaultMethod --
 *
 *    Dispatches the default method, if there is one, when object is called
 *    without arguments.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */
static int
DispatchDefaultMethod(Tcl_Interp *interp, NsfObject *object,
                      Tcl_Obj *obj, unsigned int flags) {
  int result;
  Tcl_Obj *methodObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(obj != NULL);

  if (CallDirectly(interp, object, NSF_o_defaultmethod_idx, &methodObj)) {

    Tcl_SetObjResult(interp, object->cmdName);
    result = TCL_OK;

  } else {
    Tcl_Obj *tov[2];

    tov[0] = obj;
    tov[1] = methodObj;
    result = ObjectDispatch(object, interp, 2, tov,
                            flags|NSF_CM_NO_UNKNOWN|NSF_CM_IGNORE_PERMISSIONS);
  }

  return result;
}


/*
 *----------------------------------------------------------------------
 * DispatchDestroyMethod --
 *
 *    Dispatches the destructor if there is one.  Object.destroy() normally
 *    calls dealloc, which is responsible for the physical deallocation, but
 *    during final cleanup of the object system the destructor is called
 *    separately from deallocation.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */

static int
DispatchDestroyMethod(Tcl_Interp *interp, NsfObject *object, unsigned int flags) {
  int              result;
  NsfRuntimeState *rst;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  rst = RUNTIME_STATE(interp);
  if (unlikely(rst == NULL)) {

    /*
     * There is no runtime state in this interpreter.
     */
    if ((Tcl_Interp_flags(interp) & DELETED)) {

      /*
       * The interpreter is already deleted.  Ignore this call.
       */
      result = TCL_OK;
    } else {
      /*
       * If there is no runtime state, there is a substantial error.  Panic.
       */

      Tcl_Panic("Runtime state is lost");
      result = TCL_OK;
    }

  } else {

    /*
     * Don't dispatch the destructor if it has already been dispatched, or
     * after the exit handler has started physical destruction.
     */
    if (rst->exitHandlerDestroyRound == NSF_EXITHANDLER_ON_PHYSICAL_DESTROY
        || (object->flags & NSF_DESTROY_CALLED) != 0u
       ) {
      result = TCL_OK;

    } else {
      Tcl_Obj *methodObj;

      /*
       * Now call the destructor.
       */

      /*fprintf(stderr, "    DispatchDestroyMethod obj %p flags %.6x active %d\n",
        object, object->flags,  object->activationCount); */

      PRINTOBJ("DispatchDestroyMethod", object);

      /*
       * Flag that destruction has begun and call the destructor.
       */
      object->flags |= NSF_DESTROY_CALLED;

      if (CallDirectly(interp, object, NSF_o_destroy_idx, &methodObj)) {
        NSF_PROFILE_TIME_DATA;
        NSF_PROFILE_CALL(interp, object, Nsf_SystemMethodOpts[NSF_o_destroy_idx]);
        result = NsfODestroyMethod(interp, object);
        NSF_PROFILE_EXIT(interp, object, Nsf_SystemMethodOpts[NSF_o_destroy_idx]);

      } else {
        result = CallMethod(object, interp, methodObj, 2, NULL,
                            NSF_CM_IGNORE_PERMISSIONS|NSF_CSC_IMMEDIATE|flags);
      }
      if (unlikely(result != TCL_OK)) {
        /*
         * The object might already be gone since there is no stack frame, so
         * even [nsf::current object] can't be used safely.
         */
        NsfErrorContext(interp, "method destroy");

        if (++rst->errorCount > 20) {
          Tcl_Panic("too many destroy errors occurred. Endless loop?");
        }
      } else if (rst->errorCount > 0) {
        rst->errorCount--;
      }

#ifdef OBJDELETION_TRACE
      fprintf(stderr, "DispatchDestroyMethod for %p exit\n", object);
#endif
    }
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * DispatchInitMethod --
 *
 *    Dispatch the initializer if there is one and it has not already been
 *    dispatched.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */
static int DispatchInitMethod(Tcl_Interp *interp, NsfObject *object,
                   int objc, Tcl_Obj *const objv[], unsigned int flags)
  nonnull(1) nonnull(2);

static int
DispatchInitMethod(Tcl_Interp *interp, NsfObject *object,
                   int objc, Tcl_Obj *const objv[], unsigned int flags) {
  int result;
  Tcl_Obj *methodObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  /*
   * Was init called already?
   */
  if ((object->flags & (NSF_INIT_CALLED|NSF_DESTROY_CALLED)) == 0u) {

    /*
     * Flag "init" as called so that that a call to "configure" does not clear
     * any existing instance variables.
     */

    object->flags |= NSF_INIT_CALLED;

    if (CallDirectly(interp, object, NSF_o_init_idx, &methodObj)) {
      /*fprintf(stderr, "%s init directly\n", ObjectName(object));*/
      /*
       * Nothing to do.
       */
      result = TCL_OK;
    } else {
      result = CallMethod(object, interp, methodObj, objc+2, objv,
                          flags|NSF_CM_IGNORE_PERMISSIONS|NSF_CSC_IMMEDIATE);
    }

  } else {
    result = TCL_OK;
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * DispatchUnknownMethod --
 *
 *    Dispatches the "unknown" method if there is one: "unknown" in case the
 *    object system has it defined and the application program contains an
 *    unknown handler.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.  Resets the interp's unknown-state.
 *
 *----------------------------------------------------------------------
 */

static int
DispatchUnknownMethod(Tcl_Interp *interp, NsfObject *object,
                      int objc, Tcl_Obj *const objv[],
                      Tcl_Obj *callInfoObj, Tcl_Obj *methodObj, unsigned int flags) {
  int result;
  Tcl_Obj         *unknownObj;
  const char      *methodName;
  NsfRuntimeState *rst;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(objv != NULL);
  nonnull_assert(methodObj != NULL);

  rst = RUNTIME_STATE(interp);
  methodName = MethodName(methodObj);
  unknownObj = NsfMethodObj(object, NSF_o_unknown_idx);

  /*fprintf(stderr, "compare unknownObj %p with methodObj %p '%s' %p %p %s -- %s\n",
    unknownObj, methodObj, ObjStr(methodObj), callInfoObj, (callInfoObj != NULL) ?objv[1]:NULL, (callInfoObj != NULL) ?ObjStr(objv[1]) : NULL,
    methodName);*/

  if ((unknownObj != NULL)
      && (methodObj != unknownObj)
      && (flags & NSF_CSC_CALL_NO_UNKNOWN) == 0u
     ) {
    /*
     * Back off and try unknown.
     */
    bool mustCopy = (*(ObjStr(methodObj)) == ':');
    ALLOC_ON_STACK(Tcl_Obj*, objc+3, tov);

    if (callInfoObj == NULL) {
      callInfoObj = (mustCopy ? Tcl_NewStringObj(methodName, -1) : methodObj);
    }
    INCR_REF_COUNT(callInfoObj);

    /*fprintf(stderr, "calling unknown for %s %s, flags=%.6x,%.6x/%.6x isClass=%d %p %s objc %d\n",
      ObjectName(object), ObjStr(methodObj), flags, NSF_CM_NO_UNKNOWN, NSF_CSC_CALL_NO_UNKNOWN,
      NsfObjectIsClass(object), object, ObjectName(object), objc);*/

    tov[0] = object->cmdName;
    tov[1] = unknownObj;
    tov[2] = callInfoObj;
    if (objc > 1) {
      memcpy(tov + 3, objv + 1, sizeof(Tcl_Obj *) * ((size_t)objc - 1u));
    }

    flags &= ~NSF_CM_NO_SHIFT;

    /*fprintf(stderr, "call unknown via dispatch mustCopy %d delegator %p method %s (%s)\n",
      mustCopy, delegator, ObjStr(tov[offset]), ObjStr(methodObj));*/

    result = ObjectDispatch(object, interp, objc+2, tov,
                            flags|NSF_CM_NO_UNKNOWN|NSF_CM_IGNORE_PERMISSIONS);

    DECR_REF_COUNT(callInfoObj);
    FREE_ON_STACK(Tcl_Obj*, tov);

  } else {
    Tcl_Obj *tailMethodObj = NULL;

    /*
     * No unknown called. This is the built-in unknown handler.
     */

    if (objc > 1 && ((*methodName) == '-' || (unknownObj && objv[0] == unknownObj))) {
      int length;

      tailMethodObj = objv[1];
      if ((((object->flags & NSF_KEEP_CALLER_SELF) != 0u) ||
           ((object->flags & NSF_PER_OBJECT_DISPATCH) != 0u)) &&
          Tcl_ListObjLength(interp, objv[1], &length) == TCL_OK) {
        if (length > 1) {
          Tcl_ListObjIndex(interp, objv[1], length - 1, &tailMethodObj);
        }
      }
    }
    result = NsfPrintError(interp, "%s: unable to dispatch method '%s'",
                           ObjectName_(object),
                           (tailMethodObj != NULL) ? MethodName(tailMethodObj) : methodName);
  }

  /*
   * Unknown has fired. Reset interp state.
   */
  rst->unknown = 0;

  return result;
}

/*
 *----------------------------------------------------------------------
 * NsfObjDispatch --
 *
 *    Called on every object dispatch.  Either calls the passed method or
 *    dispatches some default method.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary due to ParameterCheck() and DispatchUnknownMethod()
 *
 *----------------------------------------------------------------------
 */
#if defined(NRE)
Tcl_ObjCmdProc NsfObjDispatchNRE;
int
NsfObjDispatch(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {

  nonnull_assert(clientData != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);

  return Tcl_NRCallObjProc(interp, NsfObjDispatchNRE, clientData, objc, objv);
}
int NsfObjDispatchNRE(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])
  nonnull(1) nonnull(2) nonnull(4);

int
NsfObjDispatchNRE(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])

#else

EXTERN int
NsfObjDispatch(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])

#endif
{
  int result;
#ifdef STACK_TRACE
  NsfStackDump(interp);
#endif

  nonnull_assert(clientData != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);

  if (likely(objc > 1)) {
    /*
     * Normal dispatch.  Don't use NSF_CSC_IMMEDIATE because it defeats
     * coroutines.
     */
    result = ObjectDispatch(clientData, interp, objc, objv, 0u);
  } else {
    result = DispatchDefaultMethod(interp, (NsfObject *)clientData, objv[0], NSF_CSC_IMMEDIATE);
  }
  return result;
}

/*
 *  Proc-Creation
 */

/*
 *----------------------------------------------------------------------
 * AddPrefixToBody --
 *
 *    Returns a new fresh Tcl_Obj, owned by the caller, that contains the given
 *    body, possibly prefixed with "::nsf::__unset_unknown_args\n".
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static Tcl_Obj * AddPrefixToBody(Tcl_Obj *body, bool useParamDefs, NsfParsedParam *paramPtr)
  nonnull(1) nonnull(3);

static Tcl_Obj *
AddPrefixToBody(Tcl_Obj *body, bool useParamDefs, NsfParsedParam *paramPtr) {
  Tcl_Obj *resultBody = Tcl_NewObj();

  nonnull_assert(body != NULL);
  nonnull_assert(paramPtr != NULL);

  INCR_REF_COUNT2("resultBody", resultBody);

  if (useParamDefs && paramPtr->possibleUnknowns > 0) {
    Tcl_AppendStringsToObj(resultBody, "::nsf::__unset_unknown_args\n", (char *) NULL);
  }

  Tcl_AppendStringsToObj(resultBody, ObjStr(body), (char *) NULL);
  return resultBody;
}

/*
 *----------------------------------------------------------------------
 * NoMetaChars --
 *
 *    Returns true if the given value contains metacharacters,
 *    i.e. "*", "?", or "[".
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static bool NoMetaChars(const char *pattern)
  nonnull(1) NSF_pure;

NSF_INLINE static bool
NoMetaChars(const char *pattern) {
  register char c;
  bool          result = NSF_TRUE;

  nonnull_assert(pattern != NULL);

  for (c = *pattern; c; c = *++pattern) {
    if (c == '*' || c == '?' || c == '[') {
      result = NSF_FALSE;
      break;
    }
  }
  return result;
}

/***********************************************************************
 * Nsf_TypeConverter
 ***********************************************************************/

/*
 *----------------------------------------------------------------------
 * Nsf_ConvertToString --
 *
 *    A minimal Nsf_TypeConverter that stores the string representation of
 *    objPtr in clientData, which is passed to C functions.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

int Nsf_ConvertToString(Tcl_Interp *UNUSED(interp), Tcl_Obj *objPtr, const Nsf_Param *UNUSED(pPtr),
                        ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr))
  nonnull(2) nonnull(4);

int
Nsf_ConvertToString(Tcl_Interp *UNUSED(interp), Tcl_Obj *objPtr, const Nsf_Param *UNUSED(pPtr),
                    ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr)) {

  nonnull_assert(objPtr != NULL);
  nonnull_assert(clientData != NULL);

  *clientData = (char *)ObjStr(objPtr);

  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 * ConvertToNothing --
 *
 *    A no-op Nsf_TypeConverter that stores objptr in *outObjPtr.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static int ConvertToNothing(Tcl_Interp *UNUSED(interp), Tcl_Obj *objPtr,  const Nsf_Param *UNUSED(pPtr),
                            ClientData *UNUSED(clientData), Tcl_Obj **outObjPtr)
  nonnull(2) nonnull(5) NSF_pure;

static int
ConvertToNothing(Tcl_Interp *UNUSED(interp), Tcl_Obj *objPtr,  const Nsf_Param *UNUSED(pPtr),
                 ClientData *UNUSED(clientData), Tcl_Obj **outObjPtr) {

  nonnull_assert(objPtr != NULL);
  nonnull_assert(outObjPtr != NULL);
  assert(*outObjPtr == objPtr);

  *outObjPtr = objPtr;
  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 * ConvertToTclObjType --
 *
 *    A minimalistic Nsf_TypeConverter that converts objPtr to the type
 *    indicated by the given parameter definition without storing anything in
 *    clientData, and then stores objPtr in *outObjPtr.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

#ifdef NSF_WITH_TCL_OBJ_TYPES_AS_CONVERTER
int Nsf_ConvertToTclObjType(Tcl_Interp *interp, Tcl_Obj *objPtr,  const Nsf_Param *pPtr,
                        ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr))
  nonnull(1) nonnull(2) nonnull(3) nonnull(4) nonnull(5);

int
Nsf_ConvertToTclObjType(Tcl_Interp *interp, Tcl_Obj *objPtr,  const Nsf_Param *pPtr,
                    ClientData *clientData, Tcl_Obj **outObjPtr) {
  int result = TCL_OK;

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(pPtr != NULL);
  nonnull_assert(clientData != NULL);

  fprintf(stderr, "Nsf_ConvertToTclObjType: converterArg %p\n", (void*)pPtr->converterArg);
  if (unlikely(pPtr->converterArg != NULL)) {
    const Tcl_ObjType *tclObjType = pPtr->converterArg->internalRep.twoPtrValue.ptr1;

    if (tclObjType != NULL) {
      result = Tcl_ConvertToType(interp, objPtr, tclObjType);
      fprintf(stderr, "Nsf_ConvertToTclObjType:type  %p -> %d\n", (void*)tclObjType, result);

      if (result != TCL_OK) {
        Tcl_ResetResult(interp);
        result = NsfObjErrType(interp, NULL, objPtr, tclObjType->name, (Nsf_Param *)pPtr);
      }
    }
  }
  *outObjPtr = objPtr;
  /*
    nsf::proc foo {a:ns:mem_unit} {return $a}
    nsf::proc bar {a:ns:mem_unit} {return [expr {$a + 1}]}
    foo 1kB
    foo xxx
    bar 1kB
   */
  return result;
}
#endif

/*
 *----------------------------------------------------------------------
 * Nsf_ConvertToTclobj --
 *
 *    An Nsf_TypeConverter that verifies objPtr according to the given
 *    parameter definition and then stores objPtr in clientData, which is
 *    passed to C functions.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
enum stringTypeIdx {StringTypeAlnum, StringTypeAlpha, StringTypeAscii, StringTypeBoolean, StringTypeControl,
                    StringTypeDigit, StringTypeDouble, StringTypeFalse, StringTypeGraph, StringTypeInteger,
                    StringTypeLower, StringTypePrint, StringTypePunct, StringTypeSpace, StringTypeTrue,
                    StringTypeUpper, StringTypeWideinteger, StringTypeWordchar, StringTypeXdigit };
static const char *stringTypeOpts[] = {"alnum", "alpha", "ascii", "boolean", "control",
                                       "digit", "double", "false", "graph", "integer",
                                       "lower", "print", "punct", "space",  "true",
                                       "upper", "wideinteger", "wordchar", "xdigit",
                                       NULL};

int Nsf_ConvertToTclobj(Tcl_Interp *interp, Tcl_Obj *objPtr,  const Nsf_Param *pPtr,
                        ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr))
  nonnull(1) nonnull(2) nonnull(3) nonnull(4) nonnull(5);

int
Nsf_ConvertToTclobj(Tcl_Interp *interp, Tcl_Obj *objPtr,  const Nsf_Param *pPtr,
                    ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr)) {
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(pPtr != NULL);
  nonnull_assert(clientData != NULL);

  if (unlikely(pPtr->converterArg != NULL)) {
    Tcl_Obj *objv[4];
    /*fprintf(stderr, "ConvertToTclobj %s (must be %s)\n", ObjStr(objPtr), ObjStr(pPtr->converterArg));*/

    objv[0] = NULL;
    objv[1] = pPtr->converterArg;
    objv[2] = NsfGlobalObjs[NSF_OPTION_STRICT];
    objv[3] = objPtr;

    result = NsfCallCommand(interp, NSF_STRING_IS, 4, objv);
    if (likely(result == TCL_OK)) {
      int success;
      Tcl_GetIntFromObj(interp, Tcl_GetObjResult(interp), &success);
      if (success == 1) {
        *clientData = objPtr;
      } else {
        Tcl_ResetResult(interp);
        result = NsfObjErrType(interp, NULL, objPtr, ObjStr(pPtr->converterArg), (Nsf_Param *)pPtr);
      }
    }
  } else {
    result = TCL_OK;

#if defined(NSF_WITH_VALUE_WARNINGS)
    if (RUNTIME_STATE(interp)->logSeverity == NSF_LOG_DEBUG) {
      const char *value = ObjStr(objPtr);

      if (unlikely(*value == '-'
                   && (pPtr->flags & NSF_ARG_CHECK_NONPOS) != 0u
                   && isalpha(*(value+1))
                   && strchr(value+1, ' ') == NULL)
          ) {
        /*
         * In order to flag a warning, set the error message and return
         * TCL_CONTINUE.
         */
        (void)NsfPrintError(interp, "value '%s' of parameter '%s' could be a non-positional argument",
                      value, pPtr->name);
        result = TCL_CONTINUE;
      }
    }
#endif
    *clientData = objPtr;
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * Nsf_ConvertToBoolean --
 *
 *    An Nsf_TypeConverter that stores the internal representation of the
 *    boolean value of objPtr in the client data, which is passed to C
 *    functions.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

int Nsf_ConvertToBoolean(Tcl_Interp *interp, Tcl_Obj *objPtr,  const Nsf_Param *pPtr,
                         ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr))
  nonnull(1) nonnull(2) nonnull(3) nonnull(4) nonnull(5);

int
Nsf_ConvertToBoolean(Tcl_Interp *interp, Tcl_Obj *objPtr,  const Nsf_Param *pPtr,
                     ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr)) {
  int result, boolVal;

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(pPtr != NULL);
  nonnull_assert(clientData != NULL);

  result = Tcl_GetBooleanFromObj(interp, objPtr, &boolVal);
  if (likely(result == TCL_OK)) {
    *clientData = (ClientData)INT2PTR(boolVal);
  } else {
    Tcl_ResetResult(interp);
    NsfObjErrType(interp, NULL, objPtr, "boolean", pPtr);
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * Nsf_ConvertToInt32 --
 *
 *    An Nsf_TypeConverter that stores the internal integer representation of
 *    objPtr in client data, which is passed to C functions.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
int Nsf_ConvertToInt32(Tcl_Interp *interp, Tcl_Obj *objPtr,  const Nsf_Param *pPtr,
                       ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr))
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

int
Nsf_ConvertToInt32(Tcl_Interp *interp, Tcl_Obj *objPtr,  const Nsf_Param *pPtr,
                   ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr)) {
  int result, i;

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(pPtr != NULL);
  nonnull_assert(clientData != NULL);

  result = Tcl_GetIntFromObj(interp, objPtr, &i);

  if (likely(result == TCL_OK)) {
    *clientData = (ClientData)INT2PTR(i);
  } else {
    Tcl_ResetResult(interp);
    NsfObjErrType(interp, NULL, objPtr, "int32", (Nsf_Param *)pPtr);
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * Nsf_ConvertToInteger --
 *
 *    An Nsf_TypeConverter that stores the internal bignum representation of
 *    objPtr in the client data, which is passed C functions.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

#if TCL_MAJOR_VERSION > 8 || TCL_MINOR_VERSION > 6
/*
 * Starting with Tcl 8.7a4 and TIP 538, Nsf might end up built against Tcl
 * linking against a system-wide/external libtommath rather than against an
 * embedded libtommath.  In any case, Tcl does not ship tommat.h anymore. This
 * leaves Nsf without the necessary build-time definitions for mp_int and
 * mp_clear (see below). For the time being, rely on a hot fix by the TIP 538
 * author that provides compat definitions if TCL_NO_TOMMATH_H is set before
 * tclTomMath.h is included.
 *
 * See https://core.tcl-lang.org/tcl/tktview?name=4663e0636f, which also
 * suggests other mid-term options.
 */
//#define TCL_NO_TOMMATH_H 1
# ifndef MP_INT_DECLARED
typedef size_t mp_int[4];
# endif
#else
# include <tclTomMath.h>
#endif


int Nsf_ConvertToInteger(Tcl_Interp *interp, Tcl_Obj *objPtr,  const Nsf_Param *pPtr,
                     ClientData *clientData, Tcl_Obj **outObjPtr)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4) nonnull(5);

int
Nsf_ConvertToInteger(Tcl_Interp *interp, Tcl_Obj *objPtr,  const Nsf_Param *pPtr,
                     ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr)) {
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(pPtr != NULL);
  nonnull_assert(clientData != NULL);

  /*
   * Try a shortcut in common cases to avoid conversion to bignums since
   * Tcl_GetBignumFromObj returns a value which has to be freed.
   */
  if (objPtr->typePtr == Nsf_OT_intType || objPtr->typePtr == Nsf_OT_bignumType) {
    /*
     * The value is an int.
     */
    result = TCL_OK;
  } else if (objPtr->typePtr == Nsf_OT_doubleType) {
    /*
     * The value is not an int.
     */
    result = TCL_ERROR;
  } else {
    long         longValue;
    Tcl_WideInt  wideIntValue;
    mp_int       bignumValue;

    /*
     * To determine whether the value is an int, use Tcl_GetBignumFromObj(),
     * which keeps the type small if possible, returning e.g. an type "int" or
     * "float" when appropriate.
     */

    /*if (objPtr->typePtr != NULL) {
      fprintf(stderr, "### type is on call %p %s value %s \n",
              objPtr->typePtr, ObjTypeStr(objPtr), ObjStr(objPtr));
              }*/

    if ((result = Tcl_GetLongFromObj(interp, objPtr, &longValue)) == TCL_OK) {

    } else if ((result = Tcl_GetWideIntFromObj(interp, objPtr, &wideIntValue)) == TCL_OK) {

    } else if ((result = Tcl_GetBignumFromObj(interp, objPtr, &bignumValue)) == TCL_OK) {
      Tcl_Obj *bigNumObj = Tcl_NewBignumObj(&bignumValue);

      Tcl_DecrRefCount(bigNumObj);
      /* fprintf(stderr, "### IS BIG %s\n", objPtr->typePtr->name); */
    }
  }

  if (likely(result == TCL_OK)) {
    *clientData = (ClientData)objPtr;
  } else {
    Tcl_ResetResult(interp);
    NsfObjErrType(interp, NULL, objPtr, "integer", (Nsf_Param *)pPtr);
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * Nsf_ConvertToSwitch --
 *
 *    An Nsf_TypeConverter that stores the internal boolean representation of
 *    objPtr in client data, which is passed to C functions.  The distinction
 *    between "switch" and boolean is made on the semantics of which
 *    arguments/defaults are passed to the real converter.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

int Nsf_ConvertToSwitch(Tcl_Interp *interp, Tcl_Obj *objPtr, const Nsf_Param *pPtr,
                        ClientData *clientData, Tcl_Obj **outObjPtr)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4) nonnull(5);

int
Nsf_ConvertToSwitch(Tcl_Interp *interp, Tcl_Obj *objPtr, const Nsf_Param *pPtr,
                    ClientData *clientData, Tcl_Obj **outObjPtr) {
  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(pPtr != NULL);
  nonnull_assert(clientData != NULL);
  nonnull_assert(outObjPtr != NULL);

  return Nsf_ConvertToBoolean(interp, objPtr, pPtr, clientData, outObjPtr);
}

/*
 *----------------------------------------------------------------------
 * Nsf_ConvertToObject --
 *
 *    An Nsf_TypeConverter that stores the Nsf object internal representation
 *    of objPtr in client data, which is passed to C functions.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

int Nsf_ConvertToObject(Tcl_Interp *interp, Tcl_Obj *objPtr, const Nsf_Param *pPtr,
                        ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr))
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

int
Nsf_ConvertToObject(Tcl_Interp *interp, Tcl_Obj *objPtr, const Nsf_Param *pPtr,
                    ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr)) {
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(pPtr != NULL);
  nonnull_assert(clientData != NULL);

  if (likely(GetObjectFromObj(interp, objPtr, (NsfObject **)clientData) == TCL_OK)) {
    result = IsObjectOfType(interp, (NsfObject *)*clientData, "object", objPtr, pPtr);
  } else {
    result = NsfObjErrType(interp, NULL, objPtr, "object", (Nsf_Param *)pPtr);
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * Nsf_ConvertToClass --
 *
 *    An Nsf_TypeConverter that stores the Nsf Class internal representation of
 *    objPtr in client data, which is passed to C functions.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

int Nsf_ConvertToClass(Tcl_Interp *interp, Tcl_Obj *objPtr,  const Nsf_Param *pPtr,
                       ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr))
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

int
Nsf_ConvertToClass(Tcl_Interp *interp, Tcl_Obj *objPtr,  const Nsf_Param *pPtr,
                   ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr)) {
  bool withUnknown;
  int  result;

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(pPtr != NULL);
  nonnull_assert(clientData != NULL);

  withUnknown = (RUNTIME_STATE(interp)->doClassConverterOmitUnknown == 0);

  if (likely(GetClassFromObj(interp, objPtr, (NsfClass **)clientData, withUnknown) == TCL_OK)) {
    result = IsObjectOfType(interp, (NsfObject *)*clientData, "class", objPtr, pPtr);
  } else {
    result = NsfObjErrType(interp, NULL, objPtr, "class", (Nsf_Param *)pPtr);
  }
  return result;
}



/*
 *----------------------------------------------------------------------
 * Nsf_ConvertToFilterreg --
 *
 *    An Nsf_TypeConverter that stores the Nsf filter internal representation
 *    of objPtr in client data, which is passed to C functions.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

int Nsf_ConvertToFilterreg(Tcl_Interp *interp, Tcl_Obj *objPtr,  const Nsf_Param *pPtr,
                           ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr))
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

int
Nsf_ConvertToFilterreg(Tcl_Interp *interp, Tcl_Obj *objPtr,  const Nsf_Param *pPtr,
                       ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr)) {
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(pPtr != NULL);
  nonnull_assert(clientData != NULL);

  result = Tcl_ConvertToType(interp, objPtr, &NsfFilterregObjType);
  if (likely(result == TCL_OK)) {
    *clientData = objPtr;
  } else {
    result = NsfObjErrType(interp, NULL, objPtr, "filterreg", (Nsf_Param *)pPtr);
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * Nsf_ConvertToMixinreg --
 *
 *    An Nsf_TypeConverter that stores the Nsf Mixinreg internal representation
 *    of objPtr in client data, which is passed to C functions.
 *
 * Results:
 *    Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

int Nsf_ConvertToMixinreg(Tcl_Interp *interp, Tcl_Obj *objPtr,  const Nsf_Param *pPtr,
                          ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr))
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

int
Nsf_ConvertToMixinreg(Tcl_Interp *interp, Tcl_Obj *objPtr,  const Nsf_Param *pPtr,
                      ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr)) {
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(pPtr != NULL);
  nonnull_assert(clientData != NULL);

  result = Tcl_ConvertToType(interp, objPtr, &NsfMixinregObjType);
  if (likely(result == TCL_OK)) {
    *clientData = objPtr;
  } else {
    result = NsfObjErrType(interp, NULL, objPtr, "mixinreg", (Nsf_Param *)pPtr);
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * Nsf_ConvertToParameter --
 *
 *    An Nsf_TypeConverter that performs a rough syntactic check to verify that
 *    objPtr might be a valid parameter spec, i.e. does not start with ":", is
 *    not an unnamed spec "-:int", and stores the string value of objPtr in
 *    client data, which is passed to C functions.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

int Nsf_ConvertToParameter(Tcl_Interp *interp, Tcl_Obj *objPtr, const Nsf_Param *pPtr,
                           ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr))
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

int
Nsf_ConvertToParameter(Tcl_Interp *interp, Tcl_Obj *objPtr, const Nsf_Param *pPtr,
                       ClientData *clientData, Tcl_Obj **UNUSED(outObjPtr)) {
  const char *value;
  int         result;

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(pPtr != NULL);
  nonnull_assert(clientData != NULL);

  value = ObjStr(objPtr);
  /*fprintf(stderr, "convert to parameter '%s' t '%s'\n", value, pPtr->type);*/
  if (*value == ':' ||  (*value == '-' && *(value + 1) == ':')) {
    result = NsfPrintError(interp, "leading colon in '%s' not allowed in parameter specification '%s'",
                           ObjStr(objPtr), pPtr->name);
  } else {
    *clientData = (char *)ObjStr(objPtr);
    result = TCL_OK;
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * ConvertViaCmd --
 *
 *    An Nsf_TypeConverter that calls a user-defined checking/conversion
 *    routine and stores a pointer to *outObjPtr in clientData.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static int ConvertViaCmd(
  Tcl_Interp *interp,
  Tcl_Obj *objPtr,
  const Nsf_Param *pPtr,
  ClientData *clientData,
  Tcl_Obj **outObjPtr)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4) nonnull(5);

static int
ConvertViaCmd(
  Tcl_Interp *interp,
  Tcl_Obj *objPtr,
  const Nsf_Param *pPtr,
  ClientData *clientData,
  Tcl_Obj **outObjPtr
) {
  Tcl_Obj *ov[5], *savedResult;
  NsfObject *object;
  int result, oc;

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(pPtr != NULL);
  nonnull_assert(clientData != NULL);
  nonnull_assert(outObjPtr != NULL);

  /*
   * If the converter is just used to check the result, save the old result and
   * restore restore it before returning if there is no error.
   */
  if (unlikely((pPtr->flags & NSF_ARG_IS_CONVERTER) == 0u)) {
    savedResult = Tcl_GetObjResult(interp); /* save the result */
    INCR_REF_COUNT(savedResult);
  } else {
    savedResult = NULL;
  }

  ov[0] = (pPtr->slotObj != NULL) ? pPtr->slotObj : NsfGlobalObjs[NSF_METHOD_PARAMETER_SLOT_OBJ];
  ov[1] = pPtr->converterName;
  ov[2] = pPtr->nameObj;
  ov[3] = objPtr;

  oc = 4;
  if (pPtr->converterArg != NULL) {
    ov[4] = pPtr->converterArg;
    oc++;
  }

  /*fprintf(stderr, "ConvertViaCmd call converter %s (refCount %d) on %s paramPtr %p arg %p oc %d\n",
          ObjStr(pPtr->converterName), pPtr->converterName->refCount, ObjStr(ov[0]),
          pPtr, pPtr->converterArg, oc);*/

  INCR_REF_COUNT(ov[1]);
  INCR_REF_COUNT(ov[2]);

  /* result = Tcl_EvalObjv(interp, oc, ov, 0); */
  result = GetObjectFromObj(interp, ov[0], &object);
  if(likely(result == TCL_OK)) {
    result = ObjectDispatch(object, interp, oc, ov, NSF_CSC_IMMEDIATE|NSF_CM_IGNORE_PERMISSIONS);
  }

  DECR_REF_COUNT(ov[1]);
  DECR_REF_COUNT(ov[2]);

  /*
   * By default the input arg is the output arg.
   */
  assert(*outObjPtr == objPtr);

  if (likely(result == TCL_OK)) {
    /*fprintf(stderr, "ConvertViaCmd could convert %s to '%s' paramPtr %p, is_converter %d\n",
            ObjStr(objPtr), ObjStr(Tcl_GetObjResult(interp)), pPtr,
            pPtr->flags & NSF_ARG_IS_CONVERTER);*/
    if ((pPtr->flags & NSF_ARG_IS_CONVERTER) != 0u) {
      Tcl_Obj *resultObj;

      /* The result of the conversion. */
      resultObj = Tcl_GetObjResult(interp);

      if (*outObjPtr != resultObj) {
        /*
         * The conversion is different from the input value. Store it in
         * outObjPtr and increment the reference count, which is necessary, e.g. for
         *     return [expr {$value + 1}]
         */
        INCR_REF_COUNT2("valueObj", resultObj);
        *outObjPtr = resultObj;
      }
      /*fprintf(stderr, "**** NSF_ARG_IS_CONVERTER %p\n", *outObjPtr);*/
    }
    *clientData = (ClientData) *outObjPtr;

    if (savedResult != NULL) {
      /*fprintf(stderr, "restore savedResult %p\n", savedResult);*/
      Tcl_SetObjResult(interp, savedResult);  /* restore the result */
    }
  }

  if (savedResult != NULL) {
    DECR_REF_COUNT(savedResult);
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * ConvertToObjpattern --
 *
 *    Uses objPtr to store in clientData a Tcl_Obj*, with its reference count
 *    incremented, whose value matches the pattern of a Next Scripting Object.
 *    If objPtr contains no meta characters and the named object exists, the
 *    resulting object is converted to a cmd. If the named object does not
 *    exist, the function using this pattern will fail. If the pattern contains
 *    meta characters, prepend "::" to the pattern, if necessary, to avoid
 *    errors. In this case, the patternObj is of plain type.  The owner of
 *    clientData must decrement the reference count of the Tcl_Obj when
 *    finished with it.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *----------------------------------------------------------------------
 */
static int ConvertToObjpattern(Tcl_Interp *interp, Tcl_Obj *objPtr, const Nsf_Param *UNUSED(pPtr),
                    ClientData *clientData, Tcl_Obj **outObjPtr)
  nonnull(1) nonnull(2) nonnull(4) nonnull(5);

static int
ConvertToObjpattern(Tcl_Interp *interp, Tcl_Obj *objPtr, const Nsf_Param *UNUSED(pPtr),
                    ClientData *clientData, Tcl_Obj **outObjPtr) {
  Tcl_Obj    *patternObj;
  const char *pattern;

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(clientData != NULL);
  nonnull_assert(outObjPtr != NULL);

  patternObj = objPtr;
  pattern = ObjStr(objPtr);
  if (NoMetaChars(pattern)) {
    /*
     * There are no metacharacters. Check for an existing object.
     */
    NsfObject *object = NULL;

    if (GetObjectFromObj(interp, objPtr, &object) == TCL_OK && object != NULL) {
      patternObj = object->cmdName;
    }
  } else {
    /*
     * There is a pattern containing meta characters.  Ensure that, like all
     * objects,  it starts with "::".
     */
    if (*pattern != ':' && *pattern+1 != ':') {
      patternObj = Tcl_NewStringObj("::", 2);
      Tcl_AppendLimitedToObj(patternObj, pattern, -1, INT_MAX, NULL);
    }
  }
  if (patternObj != NULL) {
    INCR_REF_COUNT2("patternObj", patternObj);
  }
  *clientData = (ClientData)patternObj;
  /* Assertion does not hold since the converter is called directly.
     assert(*outObjPtr == objPtr); */

  *outObjPtr = objPtr;
  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 * ParamCheckObj --
 *
 *    Returns a new Tcl_Obj containing a parameter checker value consisting of
 *    the given name.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static Tcl_Obj *ParamCheckObj(const char *start, size_t len)
  nonnull(1) returns_nonnull;

static Tcl_Obj *
ParamCheckObj(const char *start, size_t len) {
  Tcl_Obj *checker = Tcl_NewStringObj("type=", 5);

  nonnull_assert(start != NULL);

  Tcl_AppendLimitedToObj(checker, start, (int)len, INT_MAX, NULL);
  return checker;
}

/*
 *----------------------------------------------------------------------
 * ParamOptionSetConverter --
 *
 *    Adds the given typeName and converter to paramPtr after making sure a
 *    converter isn't already assigned.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int ParamOptionSetConverter(Tcl_Interp *interp, Nsf_Param *paramPtr,
                        const char *typeName, Nsf_TypeConverter *converter)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static int
ParamOptionSetConverter(Tcl_Interp *interp, Nsf_Param *paramPtr,
                        const char *typeName, Nsf_TypeConverter *converter) {
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(paramPtr != NULL);
  nonnull_assert(typeName != NULL);
  nonnull_assert(converter != NULL);

  if (paramPtr->converter != NULL) {
    result = NsfPrintError(interp, "refuse to redefine parameter type of '%s' from type '%s' to type '%s'",
                           paramPtr->name, paramPtr->type, typeName);
  } else {
    paramPtr->converter = converter;
    paramPtr->nrArgs = 1;
    paramPtr->type = typeName;
    result = TCL_OK;
  }
  return result;
}


/*
 *----------------------------------------------------------------------
 * Unescape --
 *
 *    Unescapes double commas in the given unshared value.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static void Unescape(Tcl_Obj *objPtr)
  nonnull(1);

static void
Unescape(Tcl_Obj *objPtr) {
  int i, j, l;
  char *string;

  nonnull_assert(objPtr != NULL);

  l = Tcl_GetCharLength(objPtr);
  string = ObjStr(objPtr);

  for (i = 0; i < l; i++) {
    if (string[i] == ',' && string[i+1] == ',') {
      for (j = i+1; j < l; j++) {
        string[j] = string[j+1];
      }
      l--;
      i++;
    }
  }
  Tcl_SetObjLength(objPtr, l);
}

/*
 *----------------------------------------------------------------------
 * ParamOptionParse --
 *
 *    Parses the parameter option having the given length at the given start
 *    point in the given argument string and updates the fields of the given
 *    paramPtr accordingly.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static int ParamOptionParse(Tcl_Interp *interp, const char *argString,
                            size_t start, size_t optionLength,
                            unsigned int disallowedOptions, Nsf_Param *paramPtr,
                            bool unescape, const char *qualifier)
  nonnull(1) nonnull(2) nonnull(6);

static int
ParamOptionParse(Tcl_Interp *interp, const char *argString,
                 size_t start, size_t optionLength,
                 unsigned int disallowedOptions, Nsf_Param *paramPtr,
                 bool unescape, const char *qualifier) {
  const char *dotdot, *option;
  char        firstChar;
  int         result = TCL_OK;

  nonnull_assert(interp != NULL);
  nonnull_assert(argString != NULL);
  nonnull_assert(paramPtr != NULL);

  option = argString + start;
  firstChar = *option;

  /*fprintf(stderr, "ParamOptionParse name %s, option '%s' (%ld) disallowed %.6x\n",
    paramPtr->name, option, start, disallowedOptions);*/

  if (firstChar == 'r' && strncmp(option, "required", NsfMax(3, optionLength)) == 0) {
    paramPtr->flags |= NSF_ARG_REQUIRED;

  } else if (firstChar == 'o' && strncmp(option, "optional",  NsfMax(3, optionLength)) == 0) {
    paramPtr->flags &= ~NSF_ARG_REQUIRED;

  } else if (firstChar == 's'
             && strncmp(option, "substdefault", 12) == 0
             ) {
    int  substDefaultFlags = 0;
    char trailingChar = *(option+12);

    if (trailingChar == '=') {
      Tcl_Obj *ov[2];

      ov[0] = NULL;
      ov[1] = Tcl_NewStringObj(option + 13, (int)optionLength - 13);
      INCR_REF_COUNT(ov[1]);
      result = Nsf_ExprObjCmd(NULL, interp, 2, ov);
      DECR_REF_COUNT(ov[1]);

      if (result == TCL_OK) {
        Tcl_Obj *resultObj = Tcl_GetObjResult(interp);

        if ((Tcl_GetIntFromObj(interp, resultObj, &substDefaultFlags) != TCL_OK)
            || (substDefaultFlags < 0) || (substDefaultFlags > 7)
            ) {
          return NsfPrintError(interp,
                               "parameter option 'substdefault=' must be a value between 0b000 and 0b111: %s",
                               option);
        }
      } else {
        return NsfPrintError(interp, "substdefault expression failed: %s", ObjStr(Tcl_GetObjResult(interp)));
      }
    } else if (trailingChar == '\0' || trailingChar == ',') {
      substDefaultFlags = 7;
    } else {
      return NsfPrintError(interp, "unexpected character %c (%d) after 'substdefault'", trailingChar, trailingChar);
    }
    paramPtr->flags |= NSF_ARG_SUBST_DEFAULT;
    paramPtr->flags |= ((unsigned int)substDefaultFlags << 28);

  } else if (firstChar == 'c' && strncmp(option, "convert", 7) == 0) {
    paramPtr->flags |= NSF_ARG_IS_CONVERTER;

  } else if (firstChar == 'i' && strncmp(option, "initcmd", 7) == 0) {
    if (unlikely((paramPtr->flags & (NSF_ARG_CMD|NSF_ARG_ALIAS|NSF_ARG_FORWARD)) != 0u)) {
      return NsfPrintError(interp, "parameter option 'initcmd' not valid in this option combination");
    }
    paramPtr->flags |= NSF_ARG_INITCMD;

  } else if (firstChar == 'c' && strncmp(option, "cmd", 3) == 0) {
    if (unlikely((paramPtr->flags & (NSF_ARG_INITCMD|NSF_ARG_ALIAS|NSF_ARG_FORWARD)) != 0u)) {
      return NsfPrintError(interp, "parameter option 'cmd' not valid in this option combination");
    }
    paramPtr->flags |= NSF_ARG_CMD;

  } else if (firstChar == 'a' && strncmp(option, "alias", 5) == 0) {
    if (unlikely((paramPtr->flags & (NSF_ARG_INITCMD|NSF_ARG_CMD|NSF_ARG_FORWARD)) != 0u)) {
      return NsfPrintError(interp, "parameter option 'alias' not valid in this option combination");
    }
    paramPtr->flags |= NSF_ARG_ALIAS;

  } else if (firstChar == 'f' && strncmp(option, "forward", 7) == 0) {
    if (unlikely((paramPtr->flags & (NSF_ARG_INITCMD|NSF_ARG_CMD|NSF_ARG_ALIAS)) != 0u)) {
      return NsfPrintError(interp, "parameter option 'forward' not valid in this option combination");
    }
    paramPtr->flags |= NSF_ARG_FORWARD;

  } else if (firstChar == 's' && strncmp(option, "slotset", 7) == 0) {
    if (unlikely(paramPtr->slotObj == NULL)) {
      return NsfPrintError(interp, "parameter option 'slotset' must follow 'slot='");
    }
    paramPtr->flags |= NSF_ARG_SLOTSET;

  } else if (firstChar == 's' && strncmp(option, "slotinitialize", 14) == 0) {
    if (unlikely(paramPtr->slotObj == NULL)) {
      return NsfPrintError(interp, "parameter option 'slotinit' must follow 'slot='");
    }
    paramPtr->flags |= NSF_ARG_SLOTINITIALIZE;

  } else if ((dotdot = strnstr(option, "..", optionLength-1))) {
    /*
     * Check lower bound.
     */
    if (*option == '0') {
      paramPtr->flags |= NSF_ARG_ALLOW_EMPTY;
    } else if (unlikely(*option != '1')) {
      return NsfPrintError(interp, "lower bound of multiplicity in %s not supported", argString);
    }
    /*
     * Check upper bound.
     */
    option = dotdot + 2;
    if (*option == '*' || *option == 'n') {
      if (unlikely((paramPtr->flags & (NSF_ARG_SWITCH)) != 0u)) {
        return NsfPrintError(interp,
                             "upper bound of multiplicity of '%c' not allowed for \"switch\"\n", *option);
      }
      paramPtr->flags |= NSF_ARG_MULTIVALUED;
    } else if (*option != '1') {
      return NsfPrintError(interp, "upper bound of multiplicity in %s not supported", argString);
    }

  } else if (firstChar == 'n' && strncmp(option, "noarg", 5) == 0) {
    if ((paramPtr->flags & NSF_ARG_ALIAS) == 0u) {
      return NsfPrintError(interp, "parameter option \"noarg\" only allowed for parameter type \"alias\"");
    }
    paramPtr->flags |= NSF_ARG_NOARG;
    paramPtr->nrArgs = 0;

  } else if (firstChar == 'n' && strncmp(option, "nodashalnum", 11) == 0) {
    if (*paramPtr->name == '-') {
      return NsfPrintError(interp, "parameter option 'nodashalnum' only allowed for positional parameters");
    }
    paramPtr->flags |= NSF_ARG_NODASHALNUM;

  } else if (firstChar == 'n' && strncmp(option, "noconfig", 8) == 0) {
    if (disallowedOptions != NSF_DISALLOWED_ARG_OBJECT_PARAMETER) {
      return NsfPrintError(interp, "parameter option 'noconfig' only allowed for object parameters");
    }
    paramPtr->flags |= NSF_ARG_NOCONFIG;

  } else if (firstChar == 'a' && strncmp(option, "args", 4) == 0) {
    if ((paramPtr->flags & NSF_ARG_ALIAS) == 0u) {
      return NsfPrintError(interp, "parameter option \"args\" only allowed for parameter type \"alias\"");
    }
    result = ParamOptionSetConverter(interp, paramPtr, "args", ConvertToNothing);

  } else if (firstChar == 'a' && optionLength >= 4 && strncmp(option, "arg=", 4) == 0) {
    if (paramPtr->converter != ConvertViaCmd) {
      return NsfPrintError(interp,
                           "parameter option 'arg=' only allowed for user-defined converter");
    }
    if (paramPtr->converterArg != NULL) {
      DECR_REF_COUNT(paramPtr->converterArg);
    }
    paramPtr->converterArg = Tcl_NewStringObj(option + 4, (int)optionLength - 4);
    /*
     * Unescape double commas if necessary.
     */
    if (unlikely(unescape)) {
      Unescape(paramPtr->converterArg);
    }
    INCR_REF_COUNT(paramPtr->converterArg);

  } else if (firstChar == 's' && strncmp(option, "switch", 6) == 0) {
    if (*paramPtr->name != '-') {
      return NsfPrintError(interp,
                           "invalid parameter type \"switch\" for argument \"%s\"; "
                           "type \"switch\" only allowed for non-positional arguments",
                           paramPtr->name);
    } else if ((paramPtr->flags & NSF_ARG_METHOD_INVOCATION) != 0u) {
      return NsfPrintError(interp, "parameter invocation types cannot be used with option 'switch'");
    }
    result = ParamOptionSetConverter(interp, paramPtr, "switch", Nsf_ConvertToSwitch);
    paramPtr->flags |= NSF_ARG_SWITCH;
    paramPtr->nrArgs = 0;
    assert(paramPtr->defaultValue == NULL);
    paramPtr->defaultValue = Tcl_NewBooleanObj(0);
    INCR_REF_COUNT(paramPtr->defaultValue);

  } else if (firstChar == 'i' && strncmp(option, "integer", NsfMax(3, optionLength)) == 0) {
    result = ParamOptionSetConverter(interp, paramPtr, "integer", Nsf_ConvertToInteger);

  } else if (firstChar == 'i' && strncmp(option, "int32", 5) == 0) {
    result = ParamOptionSetConverter(interp, paramPtr, "int32", Nsf_ConvertToInt32);

  } else if (firstChar == 'b' && strncmp(option, "boolean", 7) == 0) {
    result = ParamOptionSetConverter(interp, paramPtr, "boolean", Nsf_ConvertToBoolean);

  } else if (firstChar == 'o' && strncmp(option, "object", 6) == 0) {
    result = ParamOptionSetConverter(interp, paramPtr, "object", Nsf_ConvertToObject);

  } else if (firstChar == 'c' && strncmp(option, "class", 5) == 0) {
    result = ParamOptionSetConverter(interp, paramPtr, "class", Nsf_ConvertToClass);

  } else if (firstChar == 'm' && strncmp(option, "metaclass", 9) == 0) {
    result = ParamOptionSetConverter(interp, paramPtr, "class", Nsf_ConvertToClass);
    paramPtr->flags |= NSF_ARG_METACLASS;

  } else if (firstChar == 'b' && strncmp(option, "baseclass", 9) == 0) {
    result = ParamOptionSetConverter(interp, paramPtr, "class", Nsf_ConvertToClass);
    paramPtr->flags |= NSF_ARG_BASECLASS;

  } else if (firstChar == 'm' && strncmp(option, "mixinreg", 8) == 0) {
    result = ParamOptionSetConverter(interp, paramPtr, "mixinreg", Nsf_ConvertToMixinreg);

  } else if (firstChar == 'f' && strncmp(option, "filterreg", 9) == 0) {
    result = ParamOptionSetConverter(interp, paramPtr, "filterreg", Nsf_ConvertToFilterreg);

  } else if (firstChar == 'p' && strncmp(option, "parameter", 9) == 0) {
    result = ParamOptionSetConverter(interp, paramPtr, "parameter", Nsf_ConvertToParameter);

  } else if (firstChar == 't' && optionLength >= 6 && strncmp(option, "type=", 5) == 0) {
    const char* typeValue = option + 5;
    int         typeValueLength = (int)optionLength - 5;

    if (paramPtr->converter != Nsf_ConvertToObject
        && paramPtr->converter != Nsf_ConvertToClass ) {
      return NsfPrintError(interp, "parameter option 'type=' only allowed for parameter types 'object' and 'class'");
    }
    if (paramPtr->converterArg != NULL) {
      DECR_REF_COUNT(paramPtr->converterArg);
    }

    if (qualifier != NULL && !isAbsolutePath(typeValue) &&
        isAbsolutePath(qualifier)) {
      Tcl_DString ds, *dsPtr = &ds;
      Tcl_DStringInit(dsPtr);
      Tcl_DStringAppend(dsPtr, qualifier, -1);
      if (Tcl_DStringLength(dsPtr) > 2) {
        Tcl_DStringAppend(dsPtr, "::", 2);
      }
      Tcl_DStringAppend(dsPtr, typeValue, typeValueLength);
      paramPtr->converterArg = Tcl_NewStringObj(Tcl_DStringValue(dsPtr), Tcl_DStringLength(dsPtr));
      Tcl_DStringFree(dsPtr);
    } else {
      paramPtr->converterArg = Tcl_NewStringObj(typeValue, typeValueLength);
    }

    if (unlikely(unescape)) {
      Unescape(paramPtr->converterArg);
    }
    INCR_REF_COUNT(paramPtr->converterArg);

  } else if (firstChar == 's' && optionLength >= 6 && strncmp(option, "slot=", 5) == 0) {
    if (paramPtr->slotObj != NULL) {
      DECR_REF_COUNT(paramPtr->slotObj);
    }
    paramPtr->slotObj = Tcl_NewStringObj(option + 5,  (int)optionLength - 5);
    if (unlikely(unescape)) {
      Unescape(paramPtr->slotObj);
    }
    INCR_REF_COUNT(paramPtr->slotObj);

  } else if (firstChar == 'm' && optionLength >= 6 && strncmp(option, "method=", 7) == 0) {
    if ((paramPtr->flags & (NSF_ARG_ALIAS|NSF_ARG_FORWARD|NSF_ARG_SLOTSET)) == 0u) {
      return NsfPrintError(interp, "parameter option 'method=' only allowed for parameter "
                           "types 'alias', 'forward' and 'slotset'");
    }
    if (paramPtr->method != NULL) {
      DECR_REF_COUNT(paramPtr->method);
    }
    paramPtr->method = Tcl_NewStringObj(option + 7,  (int)optionLength - 7);
    if (unlikely(unescape)) {
      Unescape(paramPtr->method);
    }
    INCR_REF_COUNT(paramPtr->method);

  } else if ((firstChar == 'v') &&
             ((strncmp(option, "virtualobjectargs", 17) == 0) ||
              (strncmp(option, "virtualclassargs", 16) == 0))) {
    result = ParamOptionSetConverter(interp, paramPtr, option, ConvertToNothing);
  } else {
    Tcl_DString ds, *dsPtr = &ds;
#ifdef  NSF_WITH_TCL_OBJ_TYPES_AS_CONVERTER
    const Tcl_ObjType *tclObjType;
#endif

    if (option[0] == '\0') {
      NsfLog(interp, NSF_LOG_WARN, "empty parameter option ignored");
      return TCL_OK;
    }

    Tcl_DStringInit(dsPtr);
    Tcl_DStringAppend(dsPtr, option,  (int)optionLength);

    if (unlikely(paramPtr->converter != NULL)) {
      NsfPrintError(interp, "parameter option '%s' unknown for parameter type '%s'",
                    Tcl_DStringValue(dsPtr), paramPtr->type);
      Tcl_DStringFree(dsPtr);
      return TCL_ERROR;
    }

    /*fprintf(stderr, "HAV TYPE converter for <%s> ?\n", option);*/

    if (Nsf_PointerTypeLookup(Tcl_DStringValue(dsPtr))) {
      /*
       * Does the option refer to a pointer converter?
       */
      ParamOptionSetConverter(interp, paramPtr,  Tcl_DStringValue(dsPtr), Nsf_ConvertToPointer);
      Tcl_DStringFree(dsPtr);

#ifdef NSF_WITH_TCL_OBJ_TYPES_AS_CONVERTER
    } else if ((tclObjType = Tcl_GetObjType(option)) != NULL) {
      /*fprintf(stderr, "SET TYPE converter for <%s>\n", option);*/
      result = ParamOptionSetConverter(interp, paramPtr,  Tcl_DStringValue(dsPtr), Nsf_ConvertToTclObjType);
      if (paramPtr->converterArg != NULL) {
          DECR_REF_COUNT(paramPtr->converterArg);
        }
        paramPtr->converterArg = Tcl_NewObj();
        paramPtr->converterArg->internalRep.twoPtrValue.ptr1 = (void *)tclObjType;
        INCR_REF_COUNT(paramPtr->converterArg);
#endif
    } else {
      int i, found = -1;

      /*
       * The option is still unknown.
       */
      Tcl_DStringFree(dsPtr);

      for (i = 0; stringTypeOpts[i]; i++) {
        /*
         * Do not allow abbreviations. The additional strlen() verifies a full
         * match.
         */
        if (strncmp(option, stringTypeOpts[i], optionLength) == 0
            && strlen(stringTypeOpts[i]) == optionLength) {
          found = i;
          break;
        }
      }

      if (found > -1) {
        /*
         * Converter is stringType.
         */
        result = ParamOptionSetConverter(interp, paramPtr, "stringtype", Nsf_ConvertToTclobj);
        if (paramPtr->converterArg != NULL) {
          DECR_REF_COUNT(paramPtr->converterArg);
        }
        paramPtr->converterArg = Tcl_NewStringObj(stringTypeOpts[i], -1);
        INCR_REF_COUNT(paramPtr->converterArg);
      } else {

        /*
	 * The parameter option is still unknown. Assume that it identifies a
	 * method provided by the user as an argument checker.
         */
        if (paramPtr->converterName != NULL) {
          DECR_REF_COUNT2("converterNameObj", paramPtr->converterName);
        }
        paramPtr->converterName = ParamCheckObj(option, optionLength);
        INCR_REF_COUNT2("converterNameObj", paramPtr->converterName);
        result = ParamOptionSetConverter(interp, paramPtr, ObjStr(paramPtr->converterName), ConvertViaCmd);
      }
    }
  }

  if ((paramPtr->flags & disallowedOptions) != 0u) {
    return NsfPrintError(interp, "parameter option '%s' not allowed", option);
  }

  if (unlikely(((paramPtr->flags & NSF_ARG_METHOD_INVOCATION) != 0u)
               && ((paramPtr->flags & NSF_ARG_NOCONFIG)) != 0u)) {
    return NsfPrintError(interp, "parameter option 'noconfig' cannot used together with this type of object parameter");
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * ParamDefinitionParse --
 *
 *    Parses a single parameter definition, which may have a default value.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static int ParamDefinitionParse(Tcl_Interp *interp, Tcl_Obj *procNameObj, Tcl_Obj *arg,
                                unsigned int disallowedFlags,
                                Nsf_Param *paramPtr, int *possibleUnknowns, int *plainParams,
                                int *nrNonposArgs, const char *qualifier)
  nonnull(1) nonnull(3) nonnull(5) nonnull(6) nonnull(7) nonnull(8);

static int
ParamDefinitionParse(Tcl_Interp *interp, Tcl_Obj *procNameObj, Tcl_Obj *arg, unsigned int disallowedFlags,
                     Nsf_Param *paramPtr, int *possibleUnknowns, int *plainParams, int *nrNonposArgs,
                     const char *qualifier) {
  const char  *argString, *argName;
  int          result, npac, isNonposArgument, parensCount;
  size_t       length, j;
  Tcl_Obj    **npav;

  nonnull_assert(interp != NULL);
  nonnull_assert(arg != NULL);
  nonnull_assert(paramPtr != NULL);
  nonnull_assert(possibleUnknowns != NULL);
  nonnull_assert(plainParams != NULL);
  nonnull_assert(nrNonposArgs != NULL);

  paramPtr->paramObj = arg;
  INCR_REF_COUNT(paramPtr->paramObj);

  result = Tcl_ListObjGetElements(interp, paramPtr->paramObj, &npac, &npav);
  if (unlikely(result != TCL_OK || npac < 1 || npac > 2)) {
    if (procNameObj != NULL) {
      result = NsfPrintError(interp,
                             "wrong # of elements in parameter definition "
                             "of method '%s'. "
                             "Should be a list of 1 or 2 elements, but got: '$s'",
                             ObjStr(procNameObj), ObjStr(paramPtr->paramObj));
    } else {
      result = NsfPrintError(interp,
                             "wrong # of elements in parameter definition. "
                             "Should be a list of 1 or 2 elements, but got: '%s'",
                             ObjStr(paramPtr->paramObj));
    }
    DECR_REF_COUNT(paramPtr->paramObj);
    return result;
  }

  argString = ObjStr(npav[0]);
  length = strlen(argString);
  /*
     For whatever reason the snippet above seems to be faster than:

     argString = TclGetStringFromObj(npav[0], &result);
     length    = (size_t) result;
  */

  /*
   * By default, a parameter has exactly one argument.  nrArgs is explicitly
   * set for types without arguments, e.g. "switch".
   */
  paramPtr->nrArgs = 1;

  isNonposArgument = *argString == '-';
  if (isNonposArgument != 0) {
    argName = argString+1;
    (*nrNonposArgs) ++;
  } else {
    argName = argString;
    paramPtr->flags |= NSF_ARG_REQUIRED; /* positional arguments are required unless there is a default */
  }

  /*fprintf(stderr, "... parsing '%s', name '%s' argString '%s' \n",
    ObjStr(arg), argName, argString);*/

  /*
   * Find the first ':' outside parenthesis.  The name of the parameter
   * might be in array syntax, and the index might contain ":", "," etc.
   */
  parensCount = 0;
  for (j = 0; j < length; j++) {
    if (parensCount > 0 && argString[j] == ')') {
      parensCount --;
      continue;
    }
    if (argString[j] == '(') {
      parensCount ++;
      continue;
    }
    if (parensCount == 0 && argString[j] == ':') {
      break;
    }
  }

  if (argString[j] == ':') {
    size_t l, start, end;
    bool   unescape = NSF_FALSE;

    /*
     * Get parameter name.
     */
    STRING_NEW(paramPtr->name, argString, j);
    paramPtr->nameObj = Tcl_NewStringObj(argName, (isNonposArgument != 0) ? (int)j-1 : (int)j);
    INCR_REF_COUNT(paramPtr->nameObj);

    /*
     * Skip whitespace at the beginning.
     */
    for (start = j+1; start<length && isspace((int)argString[start]); start++) {
      ;
    }

    /*
     * Search for unescaped ",".
     */
    for (l = start; l < length; l++) {
      if (unlikely(argString[l] == ',')) {
        if (likely(argString[l+1]) == ',') {
          l++;
          unescape = NSF_TRUE;
          continue;
        }
        /*
         * Skip whitespace at the end.
         */
        for (end = l; end > 0 && isspace((int)argString[end-1]); end--);
        result = ParamOptionParse(interp, argString, start, end-start, disallowedFlags, paramPtr, unescape,
                                  qualifier);
        unescape = NSF_FALSE;
        if (unlikely(result != TCL_OK)) {
          goto param_error;
        }
        l++;
        /*
         * Skip whitespace at the beginning.
         */
        for (start = l; start<length && isspace((int)argString[start]); start++) {
          ;
        }
      }
    }
    /*
     * skip whitespace at the end.
     */
    for (end = l; end > 0 && isspace((int)argString[end-1]); end--);

    /*
     * Process the last option.
     */
    if (end-start > 0) {
      result = ParamOptionParse(interp, argString, start, end-start, disallowedFlags, paramPtr, unescape,
                                qualifier);
      if (unlikely(result != TCL_OK)) {
        goto param_error;
      }
    }

  } else {
    /*
     * No ":" character.  The entire argument is the name.
     */
    STRING_NEW(paramPtr->name, argString, length);
    if (isNonposArgument != 0) {
      paramPtr->nameObj = Tcl_NewStringObj(argName, (int)length-1);
    } else {
      (*plainParams) ++;
      paramPtr->nameObj = Tcl_NewStringObj(argName, (int)length);
    }
    INCR_REF_COUNT(paramPtr->nameObj);
  }

  /*
   * If there are two arguments, the second one is the default value.
   */
  if (npac == 2) {

    if ((disallowedFlags & NSF_ARG_HAS_DEFAULT) != 0u) {
      NsfPrintError(interp, "parameter specification for \"%s\" is not allowed to have default \"%s\"",
                    argString, ObjStr(npav[1]));
      goto param_error;
    }

    /*
     * If for some reason there is already a default value, free it.
     */
    if (paramPtr->defaultValue != NULL) {
      DECR_REF_COUNT(paramPtr->defaultValue);
    }
    paramPtr->defaultValue = Tcl_DuplicateObj(npav[1]);
    INCR_REF_COUNT(paramPtr->defaultValue);
    /*
     * Since there is a default value the argument is not required for an
     * invocation.
     */
    paramPtr->flags &= ~NSF_ARG_REQUIRED;
  } else if ((paramPtr->flags & NSF_ARG_SUBST_DEFAULT) != 0u) {
    NsfPrintError(interp,
                  "parameter option substdefault specified for parameter \"%s\""
                  " without default value", paramPtr->name);
    goto param_error;
  }

  /*
   * Post-process the parameter options.
   */

  if (paramPtr->converter == NULL) {
    /*
     * Use the default converter if no converter is set.
     */
    paramPtr->converter = Nsf_ConvertToTclobj;
  } else if (
      paramPtr->converter == ConvertToNothing
      && (paramPtr->flags & (NSF_ARG_ALLOW_EMPTY|NSF_ARG_MULTIVALUED)) != 0u
  ) {
      NsfPrintError(interp,
                    "multiplicity settings for variable argument parameter \"%s\" not allowed",
                    paramPtr->name);
      goto param_error;
  }

  /*
   * Process any application-specific value checkers or converter.
   */
  /*fprintf(stderr, "parm %s: slotObj %p viaCmd? %d\n",
          paramPtr->name, paramPtr->slotObj, paramPtr->converter == ConvertViaCmd);*/

  if ((paramPtr->slotObj || paramPtr->converter == ConvertViaCmd) && paramPtr->type) {
    const char *converterNameString;
    Tcl_Obj    *converterNameObj, *slotObj;
    NsfObject  *paramObject;
    Tcl_Command cmd;
    NsfClass   *paramClass = NULL;

    slotObj = (paramPtr->slotObj != NULL) ? paramPtr->slotObj : NsfGlobalObjs[NSF_METHOD_PARAMETER_SLOT_OBJ];
    result = GetObjectFromObj(interp, slotObj, &paramObject);
    if (unlikely(result != TCL_OK)) {
      NsfPrintError(interp, "non-existing slot object \"%s\"", ObjStr(slotObj));
      goto param_error;
    }
    if (paramPtr->converterName == NULL) {
      converterNameObj = ParamCheckObj(paramPtr->type, strlen(paramPtr->type));
      INCR_REF_COUNT2("converterNameObj", converterNameObj);
    } else {
      converterNameObj = paramPtr->converterName;
    }
    converterNameString = ObjStr(converterNameObj);

    cmd = ObjectFindMethod(interp, paramObject, converterNameObj, &paramClass);
    /*fprintf(stderr, "locating %s on %s returns %p (%s)\n",
      ObjStr(converterNameObj), ObjectName(paramObject), cmd, ClassName(paramClass));*/
    if (cmd == NULL) {
      if (paramPtr->converter == ConvertViaCmd) {

        NsfLog(interp, NSF_LOG_WARN, "Could not find value checker %s defined on %s",
               converterNameString, ObjectName(paramObject));

        paramPtr->flags |= NSF_ARG_CURRENTLY_UNKNOWN;
        /* TODO: For the time being, do not return an error here. */
      }
    } else if (paramPtr->converter != ConvertViaCmd &&
               paramPtr->slotObj &&
               strcmp(ObjStr(paramPtr->slotObj),
                      NsfGlobalStrings[NSF_METHOD_PARAMETER_SLOT_OBJ]) != 0) {

      NsfLog(interp, NSF_LOG_WARN, "Checker method %s defined on %s shadows built-in converter",
             converterNameString, ObjectName(paramObject));

      if (paramPtr->converterName == NULL) {
        paramPtr->converterName = converterNameObj;
        paramPtr->converter = NULL;
        result = ParamOptionSetConverter(interp, paramPtr, converterNameString, ConvertViaCmd);
        if (unlikely(result != TCL_OK)) {
          if (converterNameObj != paramPtr->converterName) {
            DECR_REF_COUNT2("converterNameObj", converterNameObj);
          }
          goto param_error;
        }
      }
    }
    if (((paramPtr->flags & NSF_ARG_IS_CONVERTER) != 0u)
        && paramPtr->converter != ConvertViaCmd) {
      NsfPrintError(interp, "option 'convert' only allowed for application-defined converters");
      if (converterNameObj != paramPtr->converterName) {
        DECR_REF_COUNT2("converterNameObj", converterNameObj);
      }
      goto param_error;
    }

    if (converterNameObj != paramPtr->converterName) {
      DECR_REF_COUNT2("converterNameObj", converterNameObj);
    }
  }

  if (paramPtr->nrArgs == 0
      /*
       * The argument has no arguments and is positional so it is not required.
       */
      && *paramPtr->name != '-'
      && (paramPtr->flags & NSF_ARG_REQUIRED) != 0u
      ) {
    paramPtr->flags &= ~NSF_ARG_REQUIRED;
  }

  /*
   * If the argument is not required and no default value is specified, the
   * unknown value, e.g. on set/unset variable, must be handled in the client
   * code, e.g. in the canonical argument handlers for scripted methods.
   */
  if ((paramPtr->flags & NSF_ARG_REQUIRED) == 0u && paramPtr->defaultValue == NULL) {
    (*possibleUnknowns)++;
  }
  return TCL_OK;

 param_error:
  ParamFree(paramPtr);
  paramPtr->name = NULL;

#if !defined(NDEBUG)
  /*
   * There should be an error message if TCL_ERROR is returned.
   */
  {
    const char *errStr = ObjStr(Tcl_GetObjResult(interp));
    assert(*errStr != '\0');
  }
#endif

  return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 * ParamDefsParse --
 *
 *    Parses the given list of parameters and updates the given parsedParamPtr.
 *    allowedOptions indicates which parameter options, typically different for
 *    methods and objects are generally allowed.  Unless forceParamdefs is set,
 *    the parsed parameter structure is only returned when needed, i.e. when
 *    not all parameters are plain parameters.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static int ParamDefsParse(Tcl_Interp *interp, Tcl_Obj *procNameObj, Tcl_Obj *paramSpecObjs,
                          unsigned int allowedOptions, bool forceParamdefs, NsfParsedParam *parsedParamPtr,
                          const char *qualifier)
  nonnull(1) nonnull(3) nonnull(6);

static int ParamDefsParse(Tcl_Interp *interp, Tcl_Obj *procNameObj, Tcl_Obj *paramSpecObjs,
                          unsigned int allowedOptions, bool forceParamdefs, NsfParsedParam *parsedParamPtr,
                          const char *qualifier) {
  Tcl_Obj **argsv;
  int result, argsc;

  nonnull_assert(interp != NULL);
  nonnull_assert(paramSpecObjs != NULL);
  nonnull_assert(parsedParamPtr != NULL);

  parsedParamPtr->paramDefs = NULL;
  parsedParamPtr->possibleUnknowns = 0;

  result = Tcl_ListObjGetElements(interp, paramSpecObjs, &argsc, &argsv);
  if (unlikely(result != TCL_OK)) {
    return NsfPrintError(interp, "cannot break down non-positional args: %s", ObjStr(paramSpecObjs));
  }

  if (argsc > 0) {
    Nsf_Param *paramsPtr, *paramPtr, *lastParamPtr;
    int i, possibleUnknowns = 0, plainParams = 0, nrNonposArgs = 0;
    NsfParamDefs *paramDefs;

    paramPtr = paramsPtr = ParamsNew((size_t)argsc);

    for (i = 0; i < argsc; i++, paramPtr++) {
      result = ParamDefinitionParse(interp, procNameObj, argsv[i], allowedOptions,
                                    paramPtr, &possibleUnknowns, &plainParams, &nrNonposArgs,
                                    qualifier);

      if (result == TCL_OK) {
        if (paramPtr->converter == ConvertToNothing && i < argsc-1) {
          result = NsfPrintError(interp,
                                 "parameter option \"args\" invalid for parameter \"%s\"; only allowed for last parameter",
                                 paramPtr->name);
        }

        /* fprintf(stderr, "qual %s\n", qualifier);
           if (qualifier != NULL &&
           (paramPtr->converter == Nsf_ConvertToObject ||
           paramPtr->converter == Nsf_ConvertToClass) &&
           paramPtr->converterArg != NULL) {
           fprintf(stderr, "qual %s\n", qualifier);
           const char *carg = ObjStr(paramPtr->converterArg);
           if (*carg != ':') {
           Tcl_Obj *qualifiedConverterArg = Tcl_NewStringObj(qualifier, -1);
           Tcl_AppendToObj(qualifiedConverterArg, "::", 2);
           Tcl_AppendObjToObj(qualifiedConverterArg, paramPtr->converterArg);
           DECR_REF_COUNT(paramPtr->converterArg);
           paramPtr->converterArg = qualifiedConverterArg;
           INCR_REF_COUNT(qualifiedConverterArg);
           fprintf(stderr, ">>> converterArg %s qualifier %s\n", ObjStr(paramPtr->converterArg), qualifier);
           }
           }*/
      }
      if (unlikely(result != TCL_OK)) {
        ParamsFree(paramsPtr);
        return result;
      }
      /*
       * Every parameter must at least have a name set.
       */
      assert(paramPtr->name);
    }
#if defined(NSF_WITH_VALUE_WARNINGS)
    if (nrNonposArgs > 0 && argsc > 1) {
      for (i = 0; i < argsc; i++) {
        (paramsPtr + i)->flags |= NSF_ARG_CHECK_NONPOS;
      }
    }
#endif

    /*
     * If all arguments are good ol' Tcl arguments, don't use the parameter
     * definition structure unless it is forced.
     */
    if (plainParams == argsc && !forceParamdefs) {
      ParamsFree(paramsPtr);
      return TCL_OK;
    }

    /*fprintf(stderr, "we need param definition structure for {%s}, argsc %d plain %d\n",
      ObjStr(paramSpecObjs), argsc, plainParams);*/

    /*
     * If the last argument is named 'args', set the appropriate converter and
     * make it optional.
     */
    lastParamPtr = paramPtr - 1;
    if (isArgsString(lastParamPtr->name)) {
      lastParamPtr->converter = ConvertToNothing;
      lastParamPtr->flags &= ~NSF_ARG_REQUIRED;
    }

    paramDefs = ParamDefsNew();
    paramDefs->paramsPtr = paramsPtr;
    paramDefs->nrParams = (int)(paramPtr - paramsPtr);
    /*fprintf(stderr, "method %s serial %d paramDefs %p ifsize %ld, possible unknowns = %d,\n",
      ObjStr(procNameObj), paramDefs->serial,
      paramDefs, paramPtr-paramsPtr, possibleUnknowns);*/
    parsedParamPtr->paramDefs = paramDefs;
    parsedParamPtr->possibleUnknowns = possibleUnknowns;
  }
  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 * ParameterMethodForwardDispatch --
 *
 *    Dispatches a forwarded method indicated by the given parameter
 *    definition.
 *
 *    For each object parameter, performs the following:
 *
 *       Splits the forward specification.
 *
 *       Converts it to the client data structure,
 *
 *       Calls forward.
 *
 *       Frees clientData.
 *
 *    In the future this routine should convert to clientData structure just
 *    once, and free it with the disposal of the parameter.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */
static int ParameterMethodForwardDispatch(Tcl_Interp *interp, NsfObject *object,
                                          const Nsf_Param *paramPtr, Tcl_Obj *newValue,
                                          NsfCallStackContent *cscPtr)
  nonnull(1) nonnull(2) nonnull(3);

static int
ParameterMethodForwardDispatch(Tcl_Interp *interp, NsfObject *object,
                               const Nsf_Param *paramPtr, Tcl_Obj *newValue,
                               NsfCallStackContent *cscPtr) {
  Tcl_Obj **nobjv, *ov[3], *methodObj, *forwardSpec;
  ForwardCmdClientData *tcd = NULL;
  int result, oc, nobjc;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(paramPtr != NULL);
  assert((paramPtr->flags & NSF_ARG_FORWARD) != 0u);

  forwardSpec = (paramPtr->method != NULL) ? paramPtr->method : NULL; /* different default? */
  if (forwardSpec == NULL) {
    return NsfPrintError(interp, "forward: no spec available\n");
  }

  result = Tcl_ListObjGetElements(interp, forwardSpec, &nobjc, &nobjv);
  if (unlikely(result != TCL_OK)) {
    return result;
  }

  methodObj = paramPtr->nameObj;
  result = ForwardProcessOptions(interp, methodObj,
                                 NULL /*withDefault*/,
                                 0 /*withEarlybinding*/,
                                 NULL /*withOnerror*/,
                                 NULL /*withMethodprefix*/,
                                 0 /*withFrame*/,
                                 NSF_FALSE /*withVerbose*/,
                                 nobjv[0], nobjc-1, nobjv+1, &tcd);
  if (unlikely(result != TCL_OK)) {
    if (tcd != NULL) {
      ForwardCmdDeleteProc(tcd);
    }
    return result;
  }

  /*fprintf(stderr, "parameter %s forward spec <%s> After Options obj %s method %s\n",
          ObjStr(paramPtr->nameObj), ObjStr(forwardSpec),
          ObjectName(object), ObjStr(methodObj));*/

  tcd->object = object;
  oc = 1;
  ov[0] = methodObj;
  if (paramPtr->nrArgs == 1 && newValue) {
    ov[oc] = newValue;
    oc ++;
  }

  /*
   * Mark the intermittent CSC frame as INACTIVE so that, e.g.,
   * call-stack traversals seeking active frames ignore it.
   */
  if (cscPtr != NULL) {
    cscPtr->frameType = NSF_CSC_TYPE_INACTIVE;
  }

  result = NsfForwardMethod(tcd, interp, oc, ov);
  ForwardCmdDeleteProc(tcd);

  return result;
}


/*
 *----------------------------------------------------------------------
 * ParameterMethodDispatch --
 *
 *    Dispatches the method provided by the given parameter definition:  Checks
 *    the parameter definition, builds an argument list for the function call
 *    and finally calls configured cmd.  Typically called from configure.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */
static int ParameterMethodDispatch(
    Tcl_Interp *interp, NsfObject *object,
    Nsf_Param *paramPtr, Tcl_Obj *newValue,
    CallFrame *uplevelVarFramePtr,
    const char *initString,
    Tcl_Obj **nextObjPtr,
    int nrRemainingArgs
) nonnull(1) nonnull(2) nonnull(3) nonnull(4) nonnull(6) nonnull(7);

static int
ParameterMethodDispatch(
    Tcl_Interp *interp, NsfObject *object,
    Nsf_Param *paramPtr, Tcl_Obj *newValue,
    CallFrame *uplevelVarFramePtr,
    const char *initString,
    Tcl_Obj **nextObjPtr,
    int nrRemainingArgs
) {
  CallFrame           *varFramePtr;
  NsfCallStackContent  csc, *cscPtr = &csc;
  CallFrame            frame2, *framePtr2 = &frame2;
  int                  result = TCL_OK;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(paramPtr != NULL);
  nonnull_assert(newValue != NULL);
  nonnull_assert(initString != NULL);
  nonnull_assert(nextObjPtr != NULL);

#if 0
  {int i;
  fprintf(stderr, "ParameterMethodDispatch %s flags %06x nrRemainingArgs %d ",
          paramPtr->name, paramPtr->flags, nrRemainingArgs);
  for(i = 0; i < nrRemainingArgs; i++) {
    fprintf(stderr, " [%d]=%p %s,", i, &nextObjPtr[i], ObjStr(nextObjPtr[i]));
  }
  fprintf(stderr, "\n");
  }
#endif

  /*
   * The call frame of configure uses an object frame such that, e.g.  setvar
   * can access variables like "a" as a local variable.  However, this
   * behaviour isn't wanted for the init block which should behave like a proc
   * body.  Push a call frame without providing the var frame.
   *
   * To avoid the current object frame, the new frame has the namespace of the
   * caller.  Nsf_PushFrameCsc() establishes a CMETHOD frame.
   */
  varFramePtr = Tcl_Interp_varFramePtr(interp);
  Tcl_Interp_varFramePtr(interp) = varFramePtr->callerVarPtr;

  cscPtr->flags = 0;
  CscInit(cscPtr, object, object->cl /*cl*/, NULL /*cmd*/,
          NSF_CSC_TYPE_PLAIN, 0, NsfGlobalStrings[NSF_CONFIGURE]);
  Nsf_PushFrameCsc(interp, cscPtr, framePtr2);

  if ((paramPtr->flags & (NSF_ARG_INITCMD|NSF_ARG_CMD)) != 0u) {
    /* cscPtr->cmdPtr = NSFindCommand(interp, "::eval"); */
    result = Tcl_EvalObjEx(interp, newValue, TCL_EVAL_DIRECT);

  } else if ((paramPtr->flags & NSF_ARG_ALIAS) != 0u) {
    Tcl_Obj *methodObj, **ovPtr, *ov0;
    static Tcl_Obj *constantObj = NULL;
    const char *methodString;
    int oc = 0;

    /*
     * Restore the variable frame context as found at the original call site of
     * configure(). It is not necessary to revert this context change when
     * leaving this configure() context because a surrounding [uplevel]
     * corrects the call-stack context.
     */
    if (uplevelVarFramePtr != NULL) {
      Tcl_Interp_varFramePtr(interp) = uplevelVarFramePtr;
    }

    /*
     * Mark the intermittent CSC frame as INACTIVE so that, e.g.  call-stack
     * traversals seeking active frames ignore it.
     */
    cscPtr->frameType = NSF_CSC_TYPE_INACTIVE;

    /*
     * Use parameter option "method=" as a method name, if given.
     */
    methodObj = (paramPtr->method != NULL) ? paramPtr->method : paramPtr->nameObj;
    methodString = ObjStr(methodObj);

    /*fprintf(stderr, "ALIAS %s, nrargs %d converter %p ConvertToNothing %d oc %d\n",
            paramPtr->name, paramPtr->nrArgs, paramPtr->converter,
            paramPtr->converter == ConvertToNothing,
            oc);*/

    if (paramPtr->converter == ConvertToNothing) {
      /*
       * Use the varargs interface, passing remaining args to the called
       * method.
       */
      if (newValue == paramPtr->defaultValue) {
        /*
         * Use the default.
         */
        if (Tcl_ListObjGetElements(interp, paramPtr->defaultValue, &oc, &ovPtr) != TCL_OK) {
          goto method_arg_done;
        }
        ov0 = *ovPtr;
        ovPtr ++;
      } else {
        /*
         * Use the actual args.
         */
        ov0 = *nextObjPtr;
        /*fprintf(stderr, "ALIAS use actual args oc %d ov0 <%s> nextObjPtr %p %p\n",
          nrRemainingArgs, ObjStr(ov0), nextObjPtr, nextObjPtr+1);*/
        ovPtr = nextObjPtr+1;
        oc = nrRemainingArgs;
      }
    } else {
      /*
       * A simple alias, receives a single argument which might be the default
       * value, or receives no arg if noarg was specified.
       */
      int       moc = 1;
      Tcl_Obj **movPtr = NULL;

      ov0 = NULL;
      ovPtr = &constantObj;

      if (Tcl_ListObjGetElements(interp, methodObj, &moc, &movPtr) == TCL_OK) {
        if (moc != 2) {
          oc = 0;
          if (unlikely(moc > 2)) {
            NsfLog(interp, NSF_LOG_WARN, "max 2 words are currently allowed in methodName <%s>", methodString);
          }
        } else {
          oc = 1;
          methodObj = movPtr[0];
          ov0 = movPtr[1];
        }
      }
      if (paramPtr->nrArgs == 1) {
        oc++;
        if (oc == 1) {
          ov0 = newValue;
        } else {
          ovPtr = &newValue;
        }
      }
    }

    /*
     * Determine whether there is an object parameter alias for the
     * constructor.  Since the object system for the current object is required
     * to determine its object system configuration, this can't be done at
     * parameter compile time.
     */
    if (*initString == *methodString && strcmp(initString, methodString) == 0) {
      result = DispatchInitMethod(interp, object, oc, &ov0, 0u);
    } else {

      /*fprintf(stderr, "... call alias %s with methodObj %s.%s oc %d, nrArgs %d '%s'\n",
              paramPtr->name, ObjectName(object), ObjStr(methodObj), oc,
              paramPtr->nrArgs, ObjStr(newValue));*/
#if !defined(NDEBUG)
      if (oc > 2) {
        assert(ovPtr != NULL);
        assert(ovPtr != &constantObj);
        assert(ISOBJ(ovPtr[oc-2]));
      }
#endif
      Tcl_ResetResult(interp);
      result = NsfCallMethodWithArgs(interp, (Nsf_Object*)object, methodObj,
                                     ov0, oc, ovPtr,
                                     NSF_CSC_IMMEDIATE|NSF_CM_IGNORE_PERMISSIONS);
    }
  } else {
    /*
     * Must be NSF_ARG_FORWARD.
     */
    assert((paramPtr->flags & NSF_ARG_FORWARD) != 0u);

    result = ParameterMethodForwardDispatch(interp, object,
                                            paramPtr, newValue, cscPtr);
  }
 method_arg_done:
  /*
   * Pop the frame previously-stacked for eval context and set the varFramePtr
   * to the previous value.
   */
  Nsf_PopFrameCsc(interp, framePtr2);
  CscListRemove(interp, cscPtr, NULL);
  CscFinish(interp, cscPtr, result, "converter object frame");
  Tcl_Interp_varFramePtr(interp) = varFramePtr;

  /* fprintf(stderr, "NsfOConfigureMethod_ attribute %s evaluated %s => (%d)\n",
     ObjStr(paramPtr->nameObj), ObjStr(newValue), result);*/

  if (likely(result == TCL_OK)) {
    if ((paramPtr->flags & NSF_ARG_CMD) != 0u
        && RUNTIME_STATE(interp)->doKeepcmds
        ) {
      Tcl_Obj *resultObj;

      resultObj = Tcl_ObjSetVar2(interp, NsfGlobalObjs[NSF_ARRAY_CMD], paramPtr->nameObj, newValue, TCL_LEAVE_ERR_MSG);
      if (unlikely(resultObj == NULL)) {
        result = TCL_ERROR;
      }
    }
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * MakeProc --
 *
 *    Creates a new scripted routine via the "proc" ObjCmd.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description. Sets the interpreter result.
 *
 *----------------------------------------------------------------------
 */
static int MakeProc(Tcl_Namespace *nsPtr, NsfAssertionStore *aStore, Tcl_Interp *interp,
    Tcl_Obj *nameObj, Tcl_Obj *args, Tcl_Obj *body, Tcl_Obj *precondition,
    Tcl_Obj *postcondition, NsfObject *defObject, NsfObject *regObject,
    int withPer_object, int withInner_namespace, unsigned int checkAlwaysFlag
) nonnull(1) nonnull(3) nonnull(4) nonnull(5) nonnull(6) nonnull(9);

static int
MakeProc(
    Tcl_Namespace *nsPtr, NsfAssertionStore *aStore, Tcl_Interp *interp,
    Tcl_Obj *nameObj, Tcl_Obj *args, Tcl_Obj *body, Tcl_Obj *precondition,
    Tcl_Obj *postcondition, NsfObject *defObject, NsfObject *regObject,
    int withPer_object, int withInner_namespace, unsigned int checkAlwaysFlag
) {
  const char     *methodName;
  NsfParsedParam  parsedParam;
  Tcl_Obj        *ov[4], *fullyQualifiedNameObj;
  int             result;

  nonnull_assert(nsPtr != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(nameObj != NULL);
  nonnull_assert(args != NULL);
  nonnull_assert(body != NULL);
  nonnull_assert(defObject != NULL);

  methodName = ObjStr(nameObj);

  /*
   * Tcl, at least in newer versions, raises an error if the methodName starts
   * with a colon.
   */
  if (regObject == NULL) {
    regObject = defObject;
  }

  result = CanRedefineCmd(interp, nsPtr, defObject, methodName, 0u);
  if (likely(result == TCL_OK)) {
    /*
     * Redefining the method is allowed.  Obtain the method parameter
     * definition.
     */
    Tcl_Namespace *nsPtr1 = Tcl_Command_nsPtr(defObject->id);

    result = ParamDefsParse(interp, nameObj, args,
                            NSF_DISALLOWED_ARG_METHOD_PARAMETER, NSF_FALSE,
                            &parsedParam,
                            nsPtr1 != NULL ? nsPtr1->fullName : NULL);
  }

  if (unlikely(result != TCL_OK)) {
    return result;
  }

  if (isAbsolutePath(methodName)) {
    fullyQualifiedNameObj = nameObj;
  } else {
    fullyQualifiedNameObj = NameInNamespaceObj(methodName, nsPtr);
    INCR_REF_COUNT2("fullyQualifiedName", fullyQualifiedNameObj);
  }

  ov[0] = NULL;
  ov[1] = fullyQualifiedNameObj;

  if (parsedParam.paramDefs != NULL) {
    Nsf_Param *pPtr;
    Tcl_Obj *argList = Tcl_NewListObj(0, NULL);

    for (pPtr = parsedParam.paramDefs->paramsPtr; pPtr->name != NULL; pPtr++) {
      if (*pPtr->name == '-') {
        Tcl_ListObjAppendElement(interp, argList, Tcl_NewStringObj(pPtr->name+1, -1));
      } else {
        Tcl_ListObjAppendElement(interp, argList, Tcl_NewStringObj(pPtr->name, -1));
      }
    }
    ov[2] = argList;
    INCR_REF_COUNT(ov[2]);
    /*fprintf(stderr, "final arglist = <%s>\n", ObjStr(argList)); */
    ov[3] = AddPrefixToBody(body, NSF_TRUE, &parsedParam);
  } else { /* no parameter handling needed */
    ov[2] = args;
    ov[3] = AddPrefixToBody(body, NSF_FALSE, &parsedParam);
  }

  /*
   * If the cmd already exists in the namespace, delete it.
   */
  {
    Tcl_Command cmdPtr = FindMethod(nsPtr, methodName);
    if (cmdPtr != NULL) {
      Tcl_DeleteCommandFromToken(interp, cmdPtr);
    }
  }

  /*
   * Create the method in the provided namespace.
   */

  result = Tcl_ProcObjCmd(NULL, interp, 4, ov);

  if (likely(result == TCL_OK)) {
    /*
     * Retrieve the newly-defined proc.
     */
    Proc *procPtr = FindProcMethod(nsPtr, methodName);

    if (procPtr != NULL) {
      Namespace *execNsPtr;

      if (withInner_namespace == 1) {
        /*
	 * Set the execution namespace to the registration object, e.g. same as
	 * the class.
         */
        if (regObject->nsPtr == NULL) {
          MakeObjNamespace(interp, regObject);
        }
        /*fprintf(stderr, "obj %s\n", ObjectName(defObject));
        fprintf(stderr, "ns %p defObject->ns %p\n", nsPtr, defObject->nsPtr);
        fprintf(stderr, "ns %s defObject->ns %s\n", nsPtr->fullName, defObject->nsPtr->fullName);
        fprintf(stderr, "old %s\n", procPtr->cmdPtr->nsPtr->fullName);*/
        execNsPtr =  (Namespace *)regObject->nsPtr;
      } else {
        /*
	 * Set the execution namespace of the method to the namespace of the
	 * cmd of the defObject.
         */
        execNsPtr = ((Command *)regObject->id)->nsPtr;
      }

      ParamDefsStore((Tcl_Command)procPtr->cmdPtr, parsedParam.paramDefs, checkAlwaysFlag,
                     (Tcl_Namespace *)execNsPtr);
      Tcl_SetObjResult(interp, MethodHandleObj(defObject, withPer_object, methodName));
      result = TCL_OK;

    } else {
      result = TCL_ERROR;
      NsfLog(interp, NSF_LOG_WARN,
             "cannot retrieve newly defined method %s from namespace %s",
             methodName, nsPtr->fullName);
      if (*methodName == ':') {
        NsfPrintError(interp, "can't create procedure \"%s\" in non-global namespace"
                      " with name starting with \":\"",
                      methodName);
      } else {
        NsfPrintError(interp, "can't create procedure \"%s\" in non-global namespace",
                      methodName);
      }
    }
  }

#if defined(NSF_WITH_ASSERTIONS)
  if (result == TCL_OK && aStore != NULL /* (precondition || postcondition)*/) {
    AssertionAddProc(interp, methodName, aStore, precondition, postcondition);
  }
#endif

  if (parsedParam.paramDefs != NULL) {
    DECR_REF_COUNT(ov[2]);
  }
  DECR_REF_COUNT2("resultBody", ov[3]);
  if (fullyQualifiedNameObj != nameObj) {
    DECR_REF_COUNT2("fullyQualifiedName", fullyQualifiedNameObj);
  }


  return result;
}

/*
 *----------------------------------------------------------------------
 * MakeMethod --
 *
 *    Defines a scripted method to be defined on defObject and registered on
 *    regObject, if given. Also handles assertions.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Defined method or exception.
 *
 *----------------------------------------------------------------------
 */
static int MakeMethod(Tcl_Interp *interp, NsfObject *defObject, NsfObject *regObject,
                      NsfClass *class, Tcl_Obj *nameObj, Tcl_Obj *args, Tcl_Obj *body,
                      Tcl_Obj *precondition, Tcl_Obj *postcondition,
                      int withInner_namespace, unsigned int checkAlwaysFlag)
  nonnull(1) nonnull(2) nonnull(5) nonnull(6) nonnull(7);

static int
MakeMethod(Tcl_Interp *interp, NsfObject *defObject, NsfObject *regObject,
           NsfClass *class, Tcl_Obj *nameObj, Tcl_Obj *args, Tcl_Obj *body,
           Tcl_Obj *precondition, Tcl_Obj *postcondition,
           int withInner_namespace, unsigned int checkAlwaysFlag) {
  const char *argsStr, *bodyStr, *nameStr;
  int   result;

  nonnull_assert(interp != NULL);
  nonnull_assert(defObject != NULL);
  nonnull_assert(nameObj != NULL);
  nonnull_assert(args != NULL);
  nonnull_assert(body != NULL);

  nameStr = ObjStr(nameObj);

  if (*nameStr == '\0' || NsfHasTclSpace(nameStr)) {
    return NsfPrintError(interp, "invalid method name '%s'", nameStr);
  }

  if (precondition != NULL && postcondition == NULL) {
    return NsfPrintError(interp, "%s method '%s'; when specifying a precondition (%s)"
                         " a postcondition must be specified as well",
                         ClassName(class), nameStr, ObjStr(precondition));
  }

  argsStr = ObjStr(args);
  bodyStr = ObjStr(body);
  if (*argsStr == 0 && *bodyStr == 0) {
    /*
     * Both args and body are empty strings. The method should be deleted.
     */
    if (RUNTIME_STATE(interp)->exitHandlerDestroyRound == NSF_EXITHANDLER_OFF) {
      /*
       * Don't delete methods via scripting during shutdown.
       */
      result = (class != NULL) ?
        NsfRemoveClassMethod(interp, (Nsf_Class *)class, nameStr) :
        NsfRemoveObjectMethod(interp, (Nsf_Object *)defObject, nameStr);
    } else {
      /* fprintf(stderr, "don't delete method %s during shutdown\n", nameStr); */
      result = TCL_OK;
    }

  } else {
#if defined(NSF_WITH_ASSERTIONS)
    NsfAssertionStore *aStore = NULL;

    if (precondition != NULL || postcondition != NULL) {
      if (class != NULL) {
        NsfClassOpt *opt = NsfRequireClassOpt(class);

        if (opt->assertions == NULL) {
          opt->assertions = AssertionCreateStore();
        }
        aStore = opt->assertions;
      } else {
        NsfObjectOpt *opt = NsfRequireObjectOpt(defObject);

        if (opt->assertions == NULL) {
          opt->assertions = AssertionCreateStore();
        }
        aStore = opt->assertions;
      }
    }
    result = MakeProc((class != NULL) ? class->nsPtr : defObject->nsPtr, aStore,
                      interp, nameObj, args, body, precondition, postcondition,
                      defObject, regObject, class == NULL, withInner_namespace,
                      checkAlwaysFlag);
#else
    if (precondition != NULL) {
      NsfLog(interp, NSF_LOG_WARN, "Precondition %s provided, but not compiled with assertion enabled",
             ObjStr(precondition));
    } else if (postcondition != NULL) {
      NsfLog(interp, NSF_LOG_WARN, "Postcondition %s provided, but not compiled with assertion enabled",
             ObjStr(postcondition));
    }
    result = MakeProc((class != NULL) ? class->nsPtr : defObject->nsPtr, NULL,
                      interp, nameObj, args, body, NULL, NULL,
                      defObject, regObject, class == NULL, withInner_namespace,
                      checkAlwaysFlag);
#endif
  }

  if (class != NULL) {
    NsfInstanceMethodEpochIncr("MakeMethod");
    /*
     * Could be a filter or filter inheritance ... update filter orders.
     */
    if (FilterIsActive(interp, nameStr)) {
      NsfClasses *subClasses = TransitiveSubClasses(class);
      if (subClasses != NULL) {
        FilterInvalidateObjOrders(interp, subClasses);
        NsfClassListFree(subClasses);
      }
    }
  } else {
    NsfObjectMethodEpochIncr("MakeMethod");
    /*
     * Could be a filter => recompute filter order.
     */
    FilterComputeDefined(interp, defObject);
  }

  return result;
}

/**************************************************************************
 * Begin Definition of nsf::proc (Tcl Procs with Parameter handling)
 **************************************************************************/
/*
 *----------------------------------------------------------------------
 * NsfProcStubDeleteProc --
 *
 *    Tcl_CmdDeleteProc for NsfProcStubs.  Called if a NsfProcStub is deleted,
 *    and frees the associated client data.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void
NsfProcStubDeleteProc(ClientData clientData) {
  NsfProcClientData *tcd = clientData;

  /* fprintf(stderr, "NsfProcStubDeleteProc received %p\n", clientData);
  fprintf(stderr, "... procName %s paramDefs %p\n", ObjStr(tcd->procName), tcd->paramDefs);*/

  DECR_REF_COUNT2("procNameObj", tcd->procName);
  if (tcd->cmd != NULL) {
    Tcl_DeleteCommandFromToken(tcd->interp, tcd->cmd);
    NsfCommandRelease(tcd->cmd);
  }
  /* tcd->paramDefs is freed by NsfProcDeleteProc() */
  FREE(NsfProcClientData, tcd);
}

/*
 *----------------------------------------------------------------------
 * InvokeShadowedProc --
 *
 *    Calls the proc given in objc/objv.  procNameObj is used for error
 *    messages.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int InvokeShadowedProc(Tcl_Interp *interp, Tcl_Obj *procNameObj,
                              Tcl_Command cmd, ParseContext *pcPtr,
                              struct Tcl_Time *trtPtr, unsigned int cmdFlags,
                              Tcl_Namespace *execNsPtr)
  nonnull(1) nonnull(2) nonnull(4) nonnull(3) nonnull(4) nonnull(5);

static int
InvokeShadowedProc(Tcl_Interp *interp, Tcl_Obj *procNameObj,
                   Tcl_Command cmd, ParseContext *pcPtr,
                   struct Tcl_Time  *trtPtr, unsigned int cmdFlags,
                   Tcl_Namespace *execNsPtr) {
  Tcl_Obj       *const *objv;
  int            objc, result, includeTiming;
  const char    *fullMethodName;
  Tcl_CallFrame *framePtr;
  Proc          *procPtr;
  Tcl_Time      *ttPtr;

  nonnull_assert(interp != NULL);
  nonnull_assert(procNameObj != NULL);
  nonnull_assert(cmd != NULL);
  nonnull_assert(pcPtr != NULL);
  nonnull_assert(trtPtr != NULL);

  objv = pcPtr->full_objv;
  objc = pcPtr->objc+1;

  fullMethodName = ObjStr(procNameObj);
  CheckCStack(interp, "nsfProc", fullMethodName);
  /* fprintf(stderr, "=== InvokeShadowedProc %s objc %d\n", fullMethodName, objc); */

  /*
   * The code below is derived from the scripted method dispatch and slightly
   * adapted to remove object dependencies.
   */

  procPtr = (Proc *)Tcl_Command_objClientData(cmd);
  result = TclPushStackFrame(interp, &framePtr,
                             execNsPtr /* procPtr->cmdPtr->nsPtr */,
                             (FRAME_IS_PROC));

  if (likely(result == TCL_OK)) {
    unsigned int dummy = 0;
    result = ByteCompiled(interp, &dummy, procPtr,  (Namespace *)execNsPtr,
                          fullMethodName);
  }
  if (unlikely(result != TCL_OK)) {
    /* todo: really? error msg? */
    return result;
  }

  includeTiming = ((cmdFlags & NSF_CMD_DEBUG_METHOD) != 0u);

#if defined(NSF_PROFILE)
  if (includeTiming == 0) {
    NsfRuntimeState *rst = RUNTIME_STATE(interp);

    /*fprintf(stderr, "InvokeShadowedProc %s cmdFlags %.6lx\n", fullMethodName, cmdFlags);*/
    includeTiming = rst->doProfile;
  }
#endif

  Tcl_CallFrame_objc(framePtr) = objc;
  Tcl_CallFrame_objv(framePtr) = objv;
  Tcl_CallFrame_procPtr(framePtr) = procPtr;

  if (includeTiming) {
    ttPtr = (Tcl_Time *) ckalloc(sizeof(Tcl_Time));
    memcpy(ttPtr, trtPtr, sizeof(Tcl_Time));
  } else {
    ttPtr = NULL;
  }

#if defined(NRE)
  /* fprintf(stderr, "CALL TclNRInterpProcCore proc '%s' %s nameObj %p %s\n",
     ObjStr(objv[0]), fullMethodName, procNameObj, ObjStr(procNameObj)); */

  Tcl_NRAddCallback(interp, ProcDispatchFinalize,
                    (ClientData)fullMethodName, pcPtr,
                    (ClientData)ttPtr,
                    (ClientData)UINT2PTR(cmdFlags)
                    );
  result = TclNRInterpProcCore(interp, procNameObj, 1, &MakeProcError);
#else
  {
  ClientData data[4] = {
    (ClientData)fullMethodName,
    pcPtr,
    (ClientData)ttPtr,
    (ClientData)UINT2PTR(cmdFlags)
  };
  result = TclObjInterpProcCore(interp, procNameObj, 1, &MakeProcError);
  result = ProcDispatchFinalize(data, interp, result);
  }
#endif
  return result;
}

/*
 *----------------------------------------------------------------------
 * NsfProcStub --
 *
 *    A Tcl_ObjCmdProc implementing Proc stubs.  Processes the argument list in
 *    accordance with the parameter definitions and if successful, calls the
 *    overridden proc.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

int
NsfProcStub(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  NsfProcClientData *tcd;
  int result;
  ParseContext *pcPtr;

  nonnull_assert(clientData != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);

  tcd = clientData;
  assert(tcd->cmd != NULL);

  /*fprintf(stderr, "NsfProcStub %s is called, tcd %p, paramDefs %p\n", ObjStr(objv[0]), tcd, tcd ? tcd->paramDefs : NULL);*/

  if ((((unsigned int)Tcl_Command_flags(tcd->cmd) & CMD_IS_DELETED) == 0u) ||
      Tcl_Command_cmdEpoch(tcd->cmd) != 0) {
    /*
     * The (cached) command appears to have been deleted (e.g., rename), or
     * someone messed around with the overridden proc.
     *
     * Refetch the command.
     */

    Tcl_Command newCmdPtr = Tcl_GetCommandFromObj(interp, tcd->procName);

    if (unlikely(newCmdPtr == NULL)) {
      return NsfPrintError(interp, "cannot lookup command '%s'",
                             ObjStr(tcd->procName));

    } else if (unlikely(!CmdIsProc(newCmdPtr))) {
      return NsfPrintError(interp, "command '%s' is not a proc",
                             ObjStr(tcd->procName));
    }

    /*
     * Update the refCounts and cmd in ClientData.
     */
    NsfCommandRelease(tcd->cmd);
    tcd->cmd = newCmdPtr;
    NsfCommandPreserve(tcd->cmd);
  }

  pcPtr = (ParseContext *) NsfTclStackAlloc(interp, sizeof(ParseContext),
                                            "parse context");

  if (likely(tcd->paramDefs != NULL && tcd->paramDefs->paramsPtr)) {
    /*
     * There is a parameter definition.  Parse objv using it.
     */
    result = ProcessMethodArguments(pcPtr, interp, NULL,
                                    (((tcd->flags & NSF_PROC_FLAG_CHECK_ALWAYS) != 0u) ?
                                     NSF_ARGPARSE_CHECK : 0u)
                                    |NSF_ARGPARSE_FORCE_REQUIRED,
                                    tcd->paramDefs, objv[0],
                                    objc, objv);
  } else {
    /*
     * No parameter definition, e.g. no arguments Pass objv along.
     */
    pcPtr->full_objv = (Tcl_Obj**)objv;
    pcPtr->objc = objc-1;
    pcPtr->status = 0;
    result = TCL_OK;
  }

  /*
   * Was argument parsing ok?
   */
  if (likely(result == TCL_OK)) {
    Tcl_Command     cmd = tcd->wrapperCmd;
    unsigned int    cmdFlags;
    struct Tcl_Time trt;

    assert(cmd != NULL);

    cmdFlags = (unsigned int)Tcl_Command_flags(cmd);

#if defined(NSF_PROFILE)
    Tcl_GetTime(&trt);

    if (RUNTIME_STATE(interp)->doTrace) {
      NsfProfileTraceCallAppend(interp, ObjStr(objv[0]));
    }
    if ((cmdFlags & NSF_CMD_DEBUG_METHOD) != 0u) {
      NsfProfileDebugCall(interp, NULL, NULL, ObjStr(objv[0]), objc-1, (Tcl_Obj **)objv+1);
    }
#else
    if ((cmdFlags & NSF_CMD_DEBUG_METHOD) != 0u) {
      Tcl_GetTime(&trt);

      NsfProfileDebugCall(interp, NULL, NULL, ObjStr(objv[0]), objc-1, (Tcl_Obj **)objv+1);
    } else {
      trt.sec = 0;
      trt.usec = 0;
    }
#endif

    if ((cmdFlags & NSF_CMD_DEPRECATED_METHOD) != 0u) {
      NsfDeprecatedCmd(interp, "proc", ObjStr(objv[0]), "");
    }

    result = InvokeShadowedProc(interp, tcd->procName, tcd->cmd, pcPtr, &trt,
                                cmdFlags, Tcl_Command_nsPtr(cmd));

  } else {
    /*
     * Result is already set to TCL_ERROR.  The error message should have
     * already been provided.
     */
    ParseContextRelease(pcPtr);
    NsfTclStackFree(interp, pcPtr, "release parse context");
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * NsfProcAdd --
 *
 *    Adds a command for implementing a Tcl proc with next scripting
 *    parameter handling.
 *
 *    For the time being, adds a Tcl cmd functioning as a stub for the argument
 *    processing, in accordance with the parameter definitions, and adds the
 *    overridden Tcl proc with a mutated name.
 *
 *    TODO: the current 1 cmd + 1 proc implementation is not robust against
 *    renaming and partial deletions, i.e. deletion of the stub.
 *
 * Results:
 *    Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static int NsfProcAdd(Tcl_Interp *interp, NsfParsedParam *parsedParamPtr,
                      const char *procName, Tcl_Obj *body,
                      int with_ad, int with_checkAlways, int with_Debug, int with_Deprecated)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static int
NsfProcAdd(Tcl_Interp *interp, NsfParsedParam *parsedParamPtr,
           const char *procName, Tcl_Obj *body,
           int with_ad, int with_checkAlways, int with_Debug, int with_Deprecated) {
  NsfParamDefs      *paramDefs;
  NsfProcClientData *tcd;
  Tcl_Namespace     *cmdNsPtr;
  Tcl_Obj           *argList, *procNameObj, *ov[4];
  Tcl_DString        ds, *dsPtr = &ds;
  int                result;
  unsigned int       checkAlwaysFlag;
  Tcl_Command        cmd;

  nonnull_assert(interp != NULL);
  nonnull_assert(parsedParamPtr != NULL);
  nonnull_assert(procName != NULL);
  nonnull_assert(body != NULL);

  Tcl_DStringInit(dsPtr);

  /*
   * Fully qualify procName.
   */
  if (*procName != ':') {
    DStringAppendQualName(dsPtr, Tcl_GetCurrentNamespace(interp), procName);
    procName = Tcl_DStringValue(dsPtr);
  }
  /*
   * Create the ProcStub in order to later obtain its namespace, which is
   * needed as the inner namespace of the overridden proc.
   */
  tcd = NEW(NsfProcClientData);
  cmd = Tcl_CreateObjCommand(interp, procName, NsfProcStub,
                             tcd, NsfProcStubDeleteProc);
  if (unlikely(cmd == NULL)) {
    /*
     * The command could not be created for some reason. Hopefully there is a
     * useful error message.
     */
    Tcl_DStringFree(dsPtr);
    FREE(NsfProcClientData, tcd);
    return TCL_ERROR;
  }

  checkAlwaysFlag = (with_checkAlways != 0) ? NSF_ARGPARSE_CHECK : 0u;
  cmdNsPtr = Tcl_Command_nsPtr(cmd);

  /*
   * Storing param definitions is not needed for running the proc since the
   * stub receives parameters + flag via client data, but it is needed for
   * introspection.
   *
   * TODO: For now, do not provide a to set the execNsPtr via the interface.
   */
  paramDefs = parsedParamPtr->paramDefs;
  ParamDefsStore(cmd, paramDefs, checkAlwaysFlag, NULL);

  /*fprintf(stderr, "NsfProcAdd procName '%s' define cmd '%s' %p in namespace %s\n",
    procName, Tcl_GetCommandName(interp, cmd), cmd, cmdNsPtr->fullName);*/

  /*
   * Create the overriden Tcl proc, which is stored under ::nsf::procs::*.
   * First, build the fully-qualified name procNameObj.
   */
  Tcl_DStringSetLength(dsPtr, 0);
  Tcl_DStringAppend(dsPtr, "::nsf::procs", -1);
  DStringAppendQualName(dsPtr, cmdNsPtr, Tcl_GetCommandName(interp, cmd));
  procNameObj = Tcl_NewStringObj(Tcl_DStringValue(dsPtr),
                                 Tcl_DStringLength(dsPtr));

  INCR_REF_COUNT2("procNameObj", procNameObj); /* freed when NsfProcStub is deleted */

  /*
   * Create the target namespace under "::nsf::procs::" if it does not exist.
   */
  {
    Namespace  *nsPtr, *dummy1Ptr, *dummy2Ptr;
    const char *dummy;

    /*
     * Create the target namespace if it does not exist.
     */
    TclGetNamespaceForQualName(interp, ObjStr(procNameObj), NULL, TCL_CREATE_NS_IF_UNKNOWN,
                               &nsPtr, &dummy1Ptr,
                               &dummy2Ptr, &dummy);
  }

  /*
   * Create the client data, which links the stub cmd with the proc.
   */
  tcd->procName = procNameObj;
  tcd->paramDefs = paramDefs;
  tcd->flags = (checkAlwaysFlag != 0u ? NSF_PROC_FLAG_CHECK_ALWAYS : 0u) | (with_ad != 0 ? NSF_PROC_FLAG_AD : 0u);
  tcd->cmd = NULL;
  tcd->wrapperCmd = cmd;  /* TODO Preserve it? */
  tcd->interp = interp; /* for deleting the overridden proc */

  /*fprintf(stderr, "NsfProcAdd %s tcd %p paramdefs %p\n",
    ObjStr(procNameObj), tcd, tcd->paramDefs);*/

  /*
   * Build an argument list for the shadowed proc.
   */
  argList = Tcl_NewListObj(0, NULL);
  INCR_REF_COUNT(argList);

  if (paramDefs != NULL) {
    Nsf_Param *paramPtr;

    for (paramPtr = paramDefs->paramsPtr; paramPtr->name != NULL; paramPtr++) {
      if (*paramPtr->name == '-') {
        Tcl_Obj *varNameObj = Tcl_NewStringObj(paramPtr->name+1, -1);

        /*
	 * If the -ad (for ars digita) flag set, provide OpenACS semantics: Use
	 * the name "boolean" for a switch, and name the automatic variable
	 * with the prefix "_p".
         */
        if (with_ad && paramPtr->converter == Nsf_ConvertToBoolean && paramPtr->nrArgs == 1) {
          /*fprintf(stderr, "... ad handling: proc %s param %s type %s nrargs %d default %p\n",
            procName, paramPtr->name, paramPtr->type, paramPtr->nrArgs, paramPtr->defaultValue);*/
          paramPtr->nrArgs = 0;
          /*paramPtr->converter = Nsf_ConvertToSwitch;*/
          Tcl_AppendToObj(varNameObj, "_p", 2);
          if (paramPtr->defaultValue == NULL) {
            paramPtr->defaultValue = Tcl_NewBooleanObj(0);
            INCR_REF_COUNT(paramPtr->defaultValue);
          }
        }
        Tcl_ListObjAppendElement(interp, argList, varNameObj);
      } else {
        Tcl_ListObjAppendElement(interp, argList, Tcl_NewStringObj(paramPtr->name, -1));
      }
    }
  }

  ov[0] = NULL;
  ov[1] = procNameObj;
  ov[2] = argList;
  ov[3] = AddPrefixToBody(body, NSF_TRUE, parsedParamPtr);

  /*fprintf(stderr, "NsfProcAdd define proc %s arglist '%s'\n",
    ObjStr(ov[1]), ObjStr(ov[2])); */

  result = Tcl_ProcObjCmd(0, interp, 4, ov);
  DECR_REF_COUNT(argList);
  DECR_REF_COUNT2("resultBody", ov[3]);

  if (likely(result == TCL_OK)) {
    /*
     * The overridden proc was created successfully. Retrieve the defined proc
     * and set its namespace to the namespace of the stub cmd.
     */
    Tcl_Command procCmd = Tcl_GetCommandFromObj(interp, procNameObj);

    assert(procCmd != NULL);

    tcd->cmd = procCmd;
    NsfCommandPreserve(tcd->cmd);

    if (with_Debug) {
      Tcl_Command_flags(cmd) |= NSF_CMD_DEBUG_METHOD;
    }
    if (with_Deprecated) {
      Tcl_Command_flags(cmd) |= NSF_CMD_DEPRECATED_METHOD;
    }


  } else {
    /*
     * Could not define the overrideen proc. Cleanup by removing the stub cmd.
     */
    Tcl_DeleteCommandFromToken(interp, cmd);
  }

  Tcl_DStringFree(dsPtr);
  return result;
}

/*
 *----------------------------------------------------------------------
 * ProcessMethodArguments --
 *
 *    Processes the arguments provided to a method call:  Parses objv,
 *    disallows certain parameter types and updates the parse context.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static int
ProcessMethodArguments(ParseContext *pcPtr, Tcl_Interp *interp,
                       NsfObject *object, unsigned int processFlags, NsfParamDefs *paramDefs,
                       Tcl_Obj *methodNameObj, int objc, Tcl_Obj *const objv[]) {
  int result;
  CallFrame frame, *framePtr = &frame;

  nonnull_assert(pcPtr != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(paramDefs != NULL);
  nonnull_assert(methodNameObj != NULL);
  nonnull_assert(objv != NULL);

  if (object != NULL && (processFlags & NSF_ARGPARSE_METHOD_PUSH) != 0u ) {
    Nsf_PushFrameObj(interp, object, framePtr);
  }

#if 0
  {int i;
    fprintf(stderr, "ProcessMethodArguments before ArgumentParse %s (flags %.6x objc %d): ", ObjStr(methodNameObj), processFlags, objc);
    for(i = 0; i < objc; i++) {fprintf(stderr, " [%d]=%s,", i, ObjStr(objv[i]));}
    fprintf(stderr, "\n");

    Tcl_Obj *listObj = ParamDefsList(interp, paramDefs->paramsPtr, NULL, NULL);
    fprintf(stderr, "... got params <%s>\n", ObjStr(listObj));
  }
#endif

  result = ArgumentParse(interp, objc, objv, object, methodNameObj,
                         paramDefs->paramsPtr, paramDefs->nrParams, paramDefs->serial,
                         processFlags|RUNTIME_STATE(interp)->doCheckArguments,
                         pcPtr);
#if 0
  {
    int i, fromArg, toArg;
    fprintf(stderr, "ProcessMethodArguments after ArgumentParse %s pcPtr->objc %d result %d\n",
            ObjStr(methodNameObj), pcPtr->objc, result);
    if (result == TCL_OK) {
      if ((processFlags & NSF_ARGPARSE_START_ZERO) != 0u) {
        fromArg = 0;
        toArg = pcPtr->objc;
      } else {
        fromArg = 1;
        toArg = pcPtr->objc;
      }
      for (i = fromArg; i < toArg; i++) {
        fprintf(stderr, "... pcPtr %p [%d] obj %p refCount %d (%s) flags %.6x & %p\n",
                (void*)pcPtr, i,
                pcPtr->objv[i] ? (void*)pcPtr->objv[i] : NULL,
                pcPtr->objv[i] ? pcPtr->objv[i]->refCount : -1,
                pcPtr->objv[i] ? ObjStr(pcPtr->objv[i]) : "(null)", pcPtr->flags[i],
                (void*)&(pcPtr->flags[i]));
      }
    }
  }
#endif

  if (object != NULL && ((processFlags & NSF_ARGPARSE_METHOD_PUSH) != 0u)) {
    Nsf_PopFrameObj(interp, framePtr);
  }

  /*
   * Set objc of the parse context to the number of defined parameters.
   * pcPtr->objc and paramDefs->nrParams are equivalent when argument values
   * are passed to the call in absence of var args ('args'). Treating "args is
   * more involved.  See below.
   */

  if (unlikely(result != TCL_OK)) {
    return result;
  }

  if (pcPtr->varArgs) {
    /*
     * The last argument was "args".
     */
    int elts = objc - pcPtr->lastObjc;

    if (elts == 0) {
      /*
       * No arguments were passed to "args".  Simply decrement objc.
       */
      pcPtr->objc--;
    } else if (elts > 1) {
      /*
       * Multiple arguments were passed to "args". The array pcPtr->objv is
       * pointing to the first of the var args. Copy the remaining actual
       * arguments in objv to the parse context.
       */

      /*NsfPrintObjv("actual:  ", objc, objv);*/
      ParseContextExtendObjv(pcPtr, (unsigned)paramDefs->nrParams, (unsigned)elts-1u, objv + 1u + pcPtr->lastObjc);
    } else {
      /*
       * A single argument was passed to "args". There is no need to mutate the
       * pcPtr->objv, because this was done in ArgumentParse, i.e.
       * pcPtr->objv[i] contains this element.
       */
    }
  }

  return TCL_OK;
}
/**************************************************************************
 * End Definition of nsf::proc  (Tcl Procs with Parameter handling)
 **************************************************************************/

/*
 *----------------------------------------------------------------------
 * ForwardCmdDeleteProc --
 *
 *    A Tcl_CmdDeleteProc routine.  Called when a forward method is deleted.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Frees client data of the setter command.
 *
 *----------------------------------------------------------------------
 */

static void
ForwardCmdDeleteProc(ClientData clientData) {
  ForwardCmdClientData *tcd;

  nonnull_assert(clientData != NULL);

  tcd = (ForwardCmdClientData *)clientData;
  if (tcd->cmdName != NULL)     {DECR_REF_COUNT(tcd->cmdName);}
  if (tcd->subcommands != NULL) {DECR_REF_COUNT(tcd->subcommands);}
#if defined(NSF_FORWARD_WITH_ONERROR)
  if (tcd->onerror != NULL)     {DECR_REF_COUNT(tcd->onerror);}
#endif
  if (tcd->prefix != NULL)      {DECR_REF_COUNT(tcd->prefix);}
  if (tcd->args != NULL)        {DECR_REF_COUNT(tcd->args);}
  FREE(ForwardCmdClientData, tcd);
}


/*
 *----------------------------------------------------------------------
 * SetterCmdDeleteProc --
 *
 *    A Tcl_CmdDeleteProc. Called when a setter method is deleted.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Frees client data of the setter command.
 *
 *----------------------------------------------------------------------
 */
static void SetterCmdDeleteProc(ClientData clientData)
  nonnull(1);

static void
SetterCmdDeleteProc(ClientData clientData) {
  SetterCmdClientData *setterClientData;

  nonnull_assert(clientData != NULL);

  setterClientData = (SetterCmdClientData *)clientData;
  if (setterClientData->paramsPtr != NULL) {
    ParamsFree(setterClientData->paramsPtr);
  }
  FREE(SetterCmdClientData, setterClientData);
}


/*
 *----------------------------------------------------------------------
 * AliasCmdDeleteProc --
 *
 *    A Tcl_CmdDeleteProc. Called when an alias method is deleted.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Frees client data of the setter command.
 *
 *----------------------------------------------------------------------
 */
static void AliasCmdDeleteProc(ClientData clientData)
  nonnull(1);

static void
AliasCmdDeleteProc(ClientData clientData) {
  AliasCmdClientData *tcd;

  nonnull_assert(clientData != NULL);

  /*
   * Since only clientData is provided, obtain interp, object, methodName and
   * per-object from tcd. the object might be deleted already. At least the
   * global namespace, is also needed.
   */
  tcd = (AliasCmdClientData *)clientData;
  if ((tcd->interp != NULL)
      && (((Interp *)(tcd->interp))->globalNsPtr != NULL)
      && RUNTIME_STATE(tcd->interp)->exitHandlerDestroyRound != NSF_EXITHANDLER_ON_PHYSICAL_DESTROY
     ) {
    const char *methodName = Tcl_GetCommandName(tcd->interp, tcd->aliasCmd);

    AliasDelete(tcd->interp, tcd->cmdName, methodName, tcd->class == NULL);
  }

  /*fprintf(stderr, "AliasCmdDeleteProc aliasedCmd %p\n", tcd->aliasedCmd);*/
  if (tcd->cmdName != NULL) {
    DECR_REF_COUNT(tcd->cmdName);
  }
  if (tcd->aliasedCmd != NULL) {

#if defined(WITH_IMPORT_REFS)
    ImportRef *refPtr, *prevPtr = NULL;
    Command *aliasedCmd = (Command *)(tcd->aliasedCmd);

    /*fprintf(stderr, "AliasCmdDeleteProc aliasedCmd %p epoch %d refCount %d\n",
      aliasedCmd, Tcl_Command_cmdEpoch(tcd->aliasedCmd), aliasedCmd->refCount);*/
    /*
     * Clear aliasCmd from the imported-ref chain of the aliased/real cmd.
     * This generally resembles what happens in DeleteImportedCmd() in
     * tclNamesp.c, it doesn't provide ImportedCmdData client data etc., so it
     * cannot be directly used.
     */
    for (refPtr = aliasedCmd->importRefPtr; refPtr != NULL; refPtr = refPtr->nextPtr) {
      if (refPtr->importedCmdPtr == (Command *) tcd->aliasCmd) {
        if (prevPtr == NULL) {
          aliasedCmd->importRefPtr = refPtr->nextPtr;
        } else {
          prevPtr->nextPtr = refPtr->nextPtr;
        }
        ckfree((char *) refPtr);
        break;
      }
      prevPtr = refPtr;
    }
#endif
    NsfCommandRelease(tcd->aliasedCmd);
  }
  FREE(AliasCmdClientData, tcd);
}

/*
 *----------------------------------------------------------------------
 * GetMatchObject --
 *
 *    Helper method used by nsfAPI.h and the info methods to determine whether
 *    the Tcl_Obj patternObj was provided and can be looked up. If so, wildcard
 *    matching etc. does not have to be performed, and the properties of the
 *    object just need to be tested.
 *
 * Results:
 *    0 or 1 or -1
 *        the matchObject when 0 is returned
 *    0
 *        There are wild-card characters.  Iterate to get matches.
 *    1
 *        There is an an existing object.
 *   -1
 *        There are wild-card characters and no such object.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static int
GetMatchObject(Tcl_Interp *interp, Tcl_Obj *patternObj, Tcl_Obj *origObj,
                NsfObject **matchObjectPtr, const char **patternPtr) {

  nonnull_assert(interp != NULL);
  nonnull_assert(matchObjectPtr != NULL);
  nonnull_assert(patternPtr != NULL);

  if (patternObj != NULL) {
    *patternPtr = ObjStr(patternObj);
    if (TclObjIsNsfObject(interp, patternObj, matchObjectPtr)) {
      return 1;
    }
    if (patternObj == origObj && **patternPtr != ':') {
      return -1;
    }
  }

  return 0;
}


/*
 *----------------------------------------------------------------------
 * ForwardProcessOptions --
 *
 *    Creates a ForwardCmdClientData structure based on the given options and
 *    forward method.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static int
ForwardProcessOptions(Tcl_Interp *interp, Tcl_Obj *nameObj,
                      Tcl_Obj *withDefault,
                      int withEarlybinding,
                      Tcl_Obj *withOnerror,
                      Tcl_Obj *withMethodprefix,
                      int withFrame,
                      bool withVerbose,
                      Tcl_Obj *target, int objc, Tcl_Obj * const objv[],
                       ForwardCmdClientData **tcdPtr) {
  ForwardCmdClientData *tcd;
  int i, result = 0;

  nonnull_assert(interp != NULL);
  nonnull_assert(nameObj != NULL);
  nonnull_assert(objv != NULL);

  tcd = NEW(ForwardCmdClientData);
  memset(tcd, 0, sizeof(ForwardCmdClientData));

  if (withDefault != 0) {
    Tcl_DString ds, *dsPtr = &ds;
    DSTRING_INIT(dsPtr);
    Tcl_DStringAppend(dsPtr, "%1 {", 4);
    Tcl_DStringAppend(dsPtr, ObjStr(withDefault), -1);
    Tcl_DStringAppend(dsPtr, "}", 1);
    NsfDeprecatedCmd(interp, "forward option", "-default ...", Tcl_DStringValue(dsPtr));
    DSTRING_FREE(dsPtr);

    tcd->subcommands = withDefault;
    result = Tcl_ListObjLength(interp, withDefault, &tcd->nr_subcommands);
    INCR_REF_COUNT(tcd->subcommands);
  }
  if (withMethodprefix != 0) {
    tcd->prefix = withMethodprefix;
    INCR_REF_COUNT(tcd->prefix);
  }
#if defined(NSF_FORWARD_WITH_ONERROR)
  if (withOnerror != 0) {
    tcd->onerror = withOnerror;
    INCR_REF_COUNT(tcd->onerror);
  }
#endif
  tcd->frame = withFrame;
  tcd->verbose = withVerbose;
  tcd->needobjmap = NSF_FALSE;
  tcd->cmdName = target;
  /*fprintf(stderr, "...forwardprocess objc %d, cmdName %p %s\n", objc, target, ObjStr(target));*/

  for (i = 0; i < objc; i++) {
    const char *element = ObjStr(objv[i]);
    /*fprintf(stderr, "... [%d] forwardprocess element '%s'\n", i, element);*/
    tcd->needobjmap = (tcd->needobjmap || (*element == '%' && *(element+1) == '@'));
    tcd->hasNonposArgs = (tcd->hasNonposArgs || (*element == '%' && *(element+1) == '-'));
    if (tcd->args == NULL) {
      tcd->args = Tcl_NewListObj(1, &objv[i]);
      tcd->nr_args++;
      INCR_REF_COUNT(tcd->args);
    } else {
      Tcl_ListObjAppendElement(interp, tcd->args, objv[i]);
      tcd->nr_args++;
    }
  }

  if (tcd->cmdName == NULL) {
    tcd->cmdName = nameObj;
  }

  /*fprintf(stderr, "+++ cmdName = %s, args = %s, # = %d\n",
    ObjStr(tcd->cmdName), (tcd->args != NULL) ?ObjStr(tcd->args):"NULL", tcd->nr_args);*/

  if (tcd->frame == FrameObjectIdx) {
    /*
     * When evaluating objscope, and define ...
     *     o forward append -frame object append
     *  a call to
     *     o append ...
     *  would lead to a recursive call; so add the appropriate namespace.
     */
    const char *nameString = ObjStr(tcd->cmdName);

    if (!isAbsolutePath(nameString)) {
      tcd->cmdName = NameInNamespaceObj(nameString, CallingNameSpace(interp));
      /*fprintf(stderr, "+++ name %s not absolute, therefore, qualifying %s\n", nameString,
        ObjStr(tcd->cmdName));*/
    }
  }
  INCR_REF_COUNT(tcd->cmdName);

  if (withEarlybinding != 0) {
    Tcl_Command cmd = Tcl_GetCommandFromObj(interp, tcd->cmdName);
    if (cmd == NULL) {
      result = NsfPrintError(interp, "cannot lookup command '%s'", ObjStr(tcd->cmdName));
      goto forward_process_options_exit;
    }
    if (CmdIsNsfObject(cmd)     /* don't do direct invoke on nsf objects */
        || Tcl_Command_objProc(cmd) == TclObjInterpProc  /* don't do direct invoke on Tcl procs */
        ) {
      /*
       * Silently ignore earlybinding flag
       */
      tcd->objProc = NULL;
    } else {
      tcd->objProc = Tcl_Command_objProc(cmd);
      tcd->clientData = Tcl_Command_objClientData(cmd);
    }
  }

  tcd->passthrough = (tcd->args == NULL && *(ObjStr(tcd->cmdName)) != '%' && tcd->objProc);

 forward_process_options_exit:
  /*fprintf(stderr, "forward args = %p, name = '%s'\n", tcd->args, ObjStr(tcd->cmdName));*/
  if (likely(result == TCL_OK)) {
    *tcdPtr = tcd;
  } else {
    ForwardCmdDeleteProc(tcd);
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * StripBodyPrefix --
 *
 *    Strips the prefix which might have been added by Nsf from the body.
 *
 * Results:
 *    The body without the prefix.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static const char * StripBodyPrefix(const char *body)
  nonnull(1) NSF_pure;

static const char *
StripBodyPrefix(const char *body) {

  nonnull_assert(body != NULL);

  if (strncmp(body, "::nsf::__unset_unknown_args\n", 28) == 0) {
    body += 28;
  }
  return body;
}


/*
 *----------------------------------------------------------------------
 * AddSlotObjects --
 *
 *    Appends to the given list the slot objects, i.e. the children of the slot
 *    container, for the given object, optionally filtering the result by the
 *    given pattern.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    Might add to the hash table to avoid duplicates.
 *
 *----------------------------------------------------------------------
 */
static void AddSlotObjects(Tcl_Interp *interp, NsfObject *parent, const char *prefix,
                           Tcl_HashTable *slotTablePtr, NsfClass *typeClass,
                           const char *pattern, Tcl_Obj *listObj)
  nonnull(1) nonnull(2) nonnull(3) nonnull(7);

static void
AddSlotObjects(Tcl_Interp *interp, NsfObject *parent, const char *prefix,
               Tcl_HashTable *slotTablePtr,
               NsfClass *typeClass, const char *pattern,
               Tcl_Obj *listObj) {
  NsfObject   *slotContainerObject;
  Tcl_DString  ds, *dsPtr = &ds;
  bool         isFullQualPattern = ((pattern != NULL) && *pattern == ':' && *(pattern+1) == ':');

  nonnull_assert(interp != NULL);
  nonnull_assert(parent != NULL);
  nonnull_assert(prefix != NULL);
  nonnull_assert(listObj != NULL);

  /*fprintf(stderr, "AddSlotObjects parent %s prefix %s type %p %s\n",
    ObjectName(parent), prefix, type, (type != NULL) ? ClassName(type) : "");*/

  DSTRING_INIT(dsPtr);
  Tcl_DStringAppend(dsPtr, ObjectName_(parent), -1);
  Tcl_DStringAppend(dsPtr, prefix, -1);
  slotContainerObject = GetObjectFromString(interp, Tcl_DStringValue(dsPtr));

  if (slotContainerObject != NULL && slotContainerObject->nsPtr
      && ((slotContainerObject->flags & NSF_IS_SLOT_CONTAINER) != 0u)) {
    Tcl_HashSearch       hSrch;
    const Tcl_HashEntry *hPtr;
    Tcl_HashTable       *cmdTablePtr = Tcl_Namespace_cmdTablePtr(slotContainerObject->nsPtr);
    Tcl_Command          cmd;

    hPtr = Tcl_FirstHashEntry(cmdTablePtr, &hSrch);
    for (; hPtr != NULL; hPtr = Tcl_NextHashEntry(&hSrch)) {
      const char *key = Tcl_GetHashKey(cmdTablePtr, hPtr);
      NsfObject *childObject;

      if (slotTablePtr != NULL) {
        int new;
        /*
	 * Does an entry already exist for this key?  Don't report overridden
	 * entries.
         */
        Tcl_CreateHashEntry(slotTablePtr, key, &new);
        if (new == 0) {
          continue;
        }
      }

      /*
       * Obtain childObject.
       */
      cmd = (Tcl_Command) Tcl_GetHashValue(hPtr);
      childObject = NsfGetObjectFromCmdPtr(cmd);

      /*
       * Report only the existing fully-initialized slot objects, not the one
       * currently being created.
       */
      if (childObject == NULL || (childObject->flags & NSF_INIT_CALLED) == 0u) {
        /* fprintf(stderr, "....... key %s unfinished\n", key);*/
        continue;
      }

      /*
       * Check the pattern.
       */
      if (pattern != NULL) {
        int isMatch;
        /*
	 * If the pattern is fully-qualified, match against the fully-qualified
	 * name.
         */

        if (isFullQualPattern) {
          isMatch = Tcl_StringMatch(ObjectName(childObject), pattern);
        } else {
          /*
           * Is this the mangled name of a private property/variable?
           */
          if (*key == '_' && *(key+1) == '_' && *(key+2) == '_' && *(key+3) == '_') {
            Tcl_Obj *value = Nsf_ObjGetVar2((Nsf_Object *)childObject, interp,
                                            NsfGlobalObjs[NSF_SETTERNAME], NULL, 0);

            isMatch = (value != NULL) ? Tcl_StringMatch(ObjStr(value), pattern) : 0;

            /*fprintf(stderr, "pattern <%s> isFullQualPattern %d child %s key %s %p <%s> match %d\n",
              pattern, isFullQualPattern, ObjectName(childObject), key,
              value, (value != NULL) ? ObjStr(value) : "", match);*/
          } else {
            isMatch = Tcl_StringMatch(key, pattern);
          }
        }
        if (isMatch == 0) {
          continue;
        }
      }

      /*
       * Does the entry have the right type?
       */
      if (typeClass != NULL && !IsSubType(childObject->cl, typeClass)) {
        continue;
      }

      /*
       * Add the entry to the list.
       */
      Tcl_ListObjAppendElement(interp, listObj, childObject->cmdName);
    }
  }
  DSTRING_FREE(dsPtr);
}

/*
 *----------------------------------------------------------------------
 * FindCalledClass --
 *
 *    Returns the called class, if any, found on the call stack for the given
 *    object.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static NsfClass *FindCalledClass(Tcl_Interp *interp, NsfObject *object)
  nonnull(1) nonnull(2);

static NsfClass *
FindCalledClass(Tcl_Interp *interp, NsfObject *object) {
  NsfCallStackContent *cscPtr;
  NsfClass            *result;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  cscPtr = CallStackGetTopFrame0(interp);
  if (unlikely(cscPtr == NULL)) {
    result = NULL;

  } else {
    if (cscPtr->frameType == NSF_CSC_TYPE_PLAIN) {
      result = cscPtr->cl;
    } else {
      const char *methodName;

      if (cscPtr->frameType == NSF_CSC_TYPE_ACTIVE_FILTER) {
        methodName = MethodName(cscPtr->filterStackEntry->calledProc);
      } else if (cscPtr->frameType == NSF_CSC_TYPE_ACTIVE_MIXIN && object->mixinStack != NULL) {
        methodName = Tcl_GetCommandName(interp, cscPtr->cmdPtr);
      } else {
        methodName = NULL;
      }

      if (unlikely(methodName == NULL)) {
        result = NULL;

      } else if (object->nsPtr != NULL && FindMethod(object->nsPtr, methodName) != NULL) {
        /*
         * An object-specific method was called.
         */
        result = NULL;
      } else {
        Tcl_Command  cmd;

        result = SearchCMethod(object->cl, methodName, &cmd);
      }
    }
  }
  return result;
}

/*
 * Next Primitive Handling
 */
/*
 *----------------------------------------------------------------------
 * NextSearchMethod --
 *
 *    Stores in cmdPtr the next method to be called via "next", if there is
 *    one, and also stores relevant information in the the given locations.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static int NextSearchMethod(
    NsfObject *object, Tcl_Interp *interp, const NsfCallStackContent *cscPtr,
    NsfClass **classPtr, const char **methodNamePtr, Tcl_Command *cmdPtr,
    bool *isMixinEntry, bool *isFilterEntry,
    bool *endOfFilterChain, Tcl_Command *currentCmdPtr
) nonnull(1) nonnull(2) nonnull(3) nonnull(4) nonnull(5) nonnull(6) nonnull(7) nonnull(8) nonnull(9) nonnull(10);

NSF_INLINE static int
NextSearchMethod(
    NsfObject *object, Tcl_Interp *interp, const NsfCallStackContent *cscPtr,
    NsfClass **classPtr, const char **methodNamePtr, Tcl_Command *cmdPtr,
    bool *isMixinEntry, bool *isFilterEntry,
    bool *endOfFilterChain, Tcl_Command *currentCmdPtr
) {
  bool         endOfChain = NSF_FALSE;
  unsigned int objflags;

  nonnull_assert(object != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(cscPtr != NULL);
  nonnull_assert(classPtr != NULL);
  nonnull_assert(methodNamePtr != NULL);
  nonnull_assert(cmdPtr != NULL);
  nonnull_assert(isMixinEntry != NULL);
  nonnull_assert(isFilterEntry != NULL);
  nonnull_assert(endOfFilterChain != NULL);
  nonnull_assert(currentCmdPtr != NULL);

  /*fprintf(stderr, "NextSearchMethod for %s called with cl %p\n", *methodNamePtr, *classPtr);*/

  /*
   *  Next in filters.
   */

  objflags = object->flags; /* avoid stalling */
  if ((objflags & NSF_MIXIN_ORDER_VALID) == 0u) {
    MixinComputeDefined(interp, object);
    objflags = object->flags; /* avoid stalling */
  }

  if ((objflags & NSF_FILTER_ORDER_VALID) != 0u
      && (object->filterStack != NULL)
      && object->filterStack->currentCmdPtr) {
    *cmdPtr = FilterSearchProc(interp, object, currentCmdPtr, classPtr);

    /*fprintf(stderr, "FilterSearchProc returned cmd %p\n", *cmdPtr);
      NsfShowStack(interp);*/

    if (*cmdPtr == NULL) {
      if (cscPtr->frameType == NSF_CSC_TYPE_ACTIVE_FILTER) {
        /*
         * Set MethodName and classPtr to values that existed before filters
         * were called.
         */
        *methodNamePtr = MethodName(object->filterStack->calledProc);
        endOfChain = NSF_TRUE;
        *endOfFilterChain = NSF_TRUE;
        *classPtr = NULL;
        /*fprintf(stderr, "EndOfChain resetting cl\n");*/
      }
    } else {
      *methodNamePtr = (char *) Tcl_GetCommandName(interp, *cmdPtr);
      *endOfFilterChain = NSF_FALSE;
      *isFilterEntry = NSF_TRUE;
      return TCL_OK;
    }
  }

  /*
   *  When [next] is called in a mixin the current frame must not be a plain
   *  frame and there must already be a mixinStack.
   */
  assert((objflags & NSF_MIXIN_ORDER_VALID) != 0u);

  if ((object->mixinStack != NULL) && cscPtr->frameType) {
    int result = MixinSearchProc(interp, object, *methodNamePtr,
                                 classPtr, currentCmdPtr, cmdPtr);

    /* fprintf(stderr, "next in mixins %s frameType %.6x\n", *methodNamePtr, cscPtr->frameType); */

    if (unlikely(result != TCL_OK)) {
      return result;
    }

    if (*cmdPtr == NULL) {
      if (cscPtr->frameType == NSF_CSC_TYPE_ACTIVE_MIXIN) {
        endOfChain = NSF_TRUE;
        *classPtr = NULL;
      }
    } else {
      *isMixinEntry = NSF_TRUE;
      return TCL_OK;
    }
  }

  /*fprintf(stderr, "nextsearch: object %s nsPtr %p endOfChain %d\n",
    ObjectName(object), object->nsPtr, endOfChain);*/

  /*
   * No mixin found. Continue with normal dispatch.
   *
   * If the curent frame is already associated with an item in the precedence
   * order list, then advance past that point in the list. Otherwise, i.e. if
   * classPtr == NULL, start at the beginning of the list.
   *
   * If this is the end of a mixin or filter, look for a fully-qualified method
   * name or a direct method of the object.
   */
  if (endOfChain) {
    if (**methodNamePtr == ':') {
      *cmdPtr = Tcl_FindCommand(interp, *methodNamePtr, NULL, TCL_GLOBAL_ONLY);
      /* fprintf(stderr, "NEXT found absolute cmd %s => %p\n", *methodNamePtr, *cmdPtr); */
    } else if (object->nsPtr != NULL) {
      *cmdPtr = FindMethod(object->nsPtr, *methodNamePtr);
      if ((*cmdPtr != NULL)
          && ((unsigned int)Tcl_Command_flags(*cmdPtr) & NSF_CMD_CALL_PRIVATE_METHOD) != 0u
          ) {
        /*fprintf(stderr, "NEXT found private cmd %s => %p\n", *methodNamePtr, *cmdPtr);*/
        *cmdPtr = NULL;
      }
    } else {
      *cmdPtr = NULL;
    }
  } else {
    *cmdPtr = NULL;
  }

  /*fprintf(stderr, "NEXT methodName %s *classPtr %p %s *cmd %p cscPtr->flags %.6x\n",
   *methodNamePtr, *classPtr, ClassName((*classPtr)), *cmdPtr, cscPtr->flags); */

  if (*cmdPtr == NULL) {
    const NsfClasses *pl = PrecedenceOrder(object->cl);
    const NsfClass   *class = *classPtr;

    if (class != NULL) {
      /*
       * Skip until actual class
       */
      for ( ; pl != NULL; pl = pl->nextPtr) {
        if (pl->cl == class) {
          pl = pl->nextPtr;
          break;
        }
      }
    }

    if (pl != NULL) {
      /*
       * Search for a further class method.  Prrivate methods are allowed if in
       * an active filter and the call had the "-local" flag set.
       */
      *classPtr = SearchPLMethod(pl, *methodNamePtr, cmdPtr,
                                 ((cscPtr->flags & NSF_CM_LOCAL_METHOD) != 0u &&
                                  (cscPtr->frameType == NSF_CSC_TYPE_ACTIVE_FILTER) != 0u)
                                 ? 0 : NSF_CMD_CALL_PRIVATE_METHOD);
    } else {
    *classPtr = NULL;
    }

  } else {
    *classPtr = NULL;
  }

  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 * NextGetArguments --
 *
 *    For a method invoked via next, obtains arguments either from the
 *    arguments or from the stack, which is either call stack content or the
 *    Tcl stack. For ensemble calls the stack entries of the ensemble
 *    invocation are used. Fills in cscPtrPtr, methodNamePtr, outObjc, outObjv,
 *    and freeArgumentVector.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int NextGetArguments(
    Tcl_Interp *interp, int objc, Tcl_Obj *const objv[],
    NsfCallStackContent **cscPtrPtr, const char **methodNamePtr,
    int *outObjc, Tcl_Obj ***outObjv, bool *freeArgumentVector
) nonnull(1) nonnull(4) nonnull(5) nonnull(6) nonnull(7) nonnull(8);

static int
NextGetArguments(
    Tcl_Interp *interp, int objc, Tcl_Obj *const objv[],
    NsfCallStackContent **cscPtrPtr, const char **methodNamePtr,
    int *outObjc, Tcl_Obj ***outObjv, bool *freeArgumentVector
) {
  Tcl_Obj            **nobjv;
  int                  nobjc, oc;
  bool                 inEnsemble;
  Tcl_CallFrame       *framePtr;
  NsfCallStackContent *cscPtr;

  nonnull_assert(interp != NULL);
  nonnull_assert(cscPtrPtr != NULL);
  nonnull_assert(methodNamePtr != NULL);
  nonnull_assert(outObjc != NULL);
  nonnull_assert(outObjv != NULL);
  nonnull_assert(freeArgumentVector != NULL);

  /*
   * Initialize to zero to make sure to only decrement when necessary.
   */
  *freeArgumentVector = NSF_FALSE;

  cscPtr = CallStackGetTopFrame(interp, &framePtr);
  if (cscPtr == NULL) {
    return NsfPrintError(interp, "next: can't find self");
  }

  if (cscPtr->cmdPtr == NULL) {
    return NsfPrintError(interp, "next: no executing proc");
  }

  oc = Tcl_CallFrame_objc(framePtr);

  if ((cscPtr->frameType & NSF_CSC_TYPE_ENSEMBLE)) {
    /*
     * This is an ensemble method, where [next] works not on the actual
     * methodName + frame, but on the ensemble above it.  Locate the
     * appropriate call-stack content and continue with that.
     */
    cscPtr = CallStackFindEnsembleCsc(framePtr, &framePtr);
    assert(cscPtr != NULL);
    inEnsemble = NSF_TRUE;
    *methodNamePtr = MethodName(cscPtr->objv[0]);
  } else {
    inEnsemble = NSF_FALSE;
    *methodNamePtr = Tcl_GetCommandName(interp, cscPtr->cmdPtr);
  }

  /*fprintf(stderr, "NextGetArguments oc %d objc %d inEnsemble %d objv %p\n",
    oc, objc, inEnsemble, cscPtr->objv); */

  if (objc > -1) {
    int methodNameLength;
    /*
     * Arguments were provided. Construct argumetns with the first argument(s)
     * as the method name. For an ensemble, insert the objs of the full
     * ensemble name.
     */
    if (inEnsemble) {
      methodNameLength = 1 + cscPtr->objc - oc;
      nobjc = objc + methodNameLength;
      nobjv = (Tcl_Obj **)ckalloc((unsigned)sizeof(Tcl_Obj *) * (unsigned)nobjc);
      MEM_COUNT_ALLOC("nextArgumentVector", nobjv);
      /*
       * Copy the ensemble pathname.
       */
      memcpy((char *)nobjv, cscPtr->objv, sizeof(Tcl_Obj *) * (size_t)methodNameLength);

     } else {
      methodNameLength = 1;
      nobjc = objc + methodNameLength;
      nobjv = (Tcl_Obj **)ckalloc((unsigned)sizeof(Tcl_Obj *) * (unsigned)nobjc);
      MEM_COUNT_ALLOC("nextArgumentVector", nobjv);
      /*
       * Copy the method name.
       */
      if (cscPtr->objv != NULL) {
        nobjv[0] = cscPtr->objv[0];
      } else if (Tcl_CallFrame_objv(framePtr)) {
        nobjv[0] = Tcl_CallFrame_objv(framePtr)[0];
      }
    }

    if (objc > 0 && (objv != NULL || cscPtr->objv != NULL)) {
      /*
       * Copy the remaining arguments.
       */
      memcpy(nobjv + methodNameLength, objv == NULL ? cscPtr->objv : objv, sizeof(Tcl_Obj *) * (size_t)objc);
    }

    INCR_REF_COUNT(nobjv[0]); /* This seems to be necesary */
    *freeArgumentVector = NSF_TRUE;
  } else {
    /*
     * No arguments were provided.
     */
    if (cscPtr->objv != NULL) {
      nobjv = (Tcl_Obj **)cscPtr->objv;
      nobjc = cscPtr->objc;
    } else {
      nobjc = Tcl_CallFrame_objc(framePtr);
      nobjv = (Tcl_Obj **)Tcl_CallFrame_objv(framePtr);
    }
  }

  *cscPtrPtr = cscPtr;
  *outObjc = nobjc;
  *outObjv = nobjv;

  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 * NextInvokeFinalize --
 *
 *    Called either via NRE callback or directly from NextSearchAndInvoke.
 *    After a successful lookup and invocation, resets continuation context,
 *    i.e. filter flags, etc., and optionally cleans up the arguments, which is
 *    inverse operation of NextGetArguments.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Frees memory.
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static int NextInvokeFinalize(ClientData data[], Tcl_Interp *interp, int result)
  nonnull(1) nonnull(2);

NSF_INLINE static int
NextInvokeFinalize(ClientData data[], Tcl_Interp *interp, int result) {
  Tcl_Obj             **nobjv;
  NsfCallStackContent  *cscPtr;

  nonnull_assert(data != NULL);
  nonnull_assert(interp != NULL);

  nobjv = data[0];
  cscPtr = data[1];

  /*fprintf(stderr, "***** NextInvokeFinalize cscPtr %p flags %.6x is next %d result %d unk %d\n",
          cscPtr, cscPtr->flags, cscPtr->flags & NSF_CSC_CALL_IS_NEXT, result,
          RUNTIME_STATE(interp)->unknown);*/

  if ((cscPtr->flags & NSF_CSC_CALL_IS_NEXT) != 0u) {
    /* fprintf(stderr, "..... it was a successful next\n"); */
    cscPtr->flags &= ~NSF_CSC_CALL_IS_NEXT;

    if (cscPtr->frameType == NSF_CSC_TYPE_INACTIVE_FILTER) {
      cscPtr->frameType = NSF_CSC_TYPE_ACTIVE_FILTER;
    } else if (cscPtr->frameType == NSF_CSC_TYPE_INACTIVE_MIXIN) {
      cscPtr->frameType = NSF_CSC_TYPE_ACTIVE_MIXIN;
    }
  }

  if (nobjv != NULL) {
    DECR_REF_COUNT(nobjv[0]);
    MEM_COUNT_FREE("nextArgumentVector", nobjv);
    ckfree((char *)nobjv);
  }

  if (result == TCL_ERROR && RUNTIME_STATE(interp)->unknown) {
    /* fprintf(stderr, "don't report unknown error\n"); */
    /*
     * Don't report "unknown" errors via next.
     */
    result = TCL_OK;
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * NextSearchAndInvoke --
 *
 *    Called with the finalized arguments, searches for a possibly overridden
 *    method, and if found, updates the continuation context, i.e. filter flags
 *    etc., calls the method, and then performs cleanup.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary. May modify he interp's unknown state.
 *
 *----------------------------------------------------------------------
 */
static int
NextSearchAndInvoke(
    Tcl_Interp *interp, const char *methodName,
    int objc, Tcl_Obj *const objv[],
    NsfCallStackContent *cscPtr,
    bool freeArgumentVector
) {
  Tcl_Command      cmd = NULL, currentCmd = NULL;
  int              result;
  bool             endOfFilterChain = NSF_FALSE,
                   isMixinEntry = NSF_FALSE,
                   isFilterEntry = NSF_FALSE;
  NsfRuntimeState *rst;
  NsfObject       *object;
  NsfClass        *class;

  nonnull_assert(interp != NULL);
  nonnull_assert(methodName != NULL);
  nonnull_assert(cscPtr != NULL);

  rst = RUNTIME_STATE(interp);
  /*
   * Find the next method.
   */
  class = cscPtr->cl;
  object = cscPtr->self;
  result = NextSearchMethod(object, interp, cscPtr, &class, &methodName, &cmd,
                            &isMixinEntry, &isFilterEntry, &endOfFilterChain, &currentCmd);

  /*fprintf(stderr, "NEXT search on %s.%s cl %p cmd %p endOfFilterChain %d result %d IS OK %d\n",
          ObjectName(object), methodName, (void*)class, (void*)cmd, endOfFilterChain,
          result, (result == TCL_OK));*/

  if (unlikely(result != TCL_OK)) {
    goto next_search_and_invoke_cleanup;
  }

#if 0
  Tcl_ResetResult(interp); /* needed for bytecode support */
#endif
  if (cmd != NULL) {
    unsigned short frameType = NSF_CSC_TYPE_PLAIN;

    /*
     * Change mixin state.
     */
    if (object->mixinStack != NULL) {
      if (cscPtr->frameType == NSF_CSC_TYPE_ACTIVE_MIXIN) {
        cscPtr->frameType = NSF_CSC_TYPE_INACTIVE_MIXIN;
      }
      /*
       * Move the command pointer forward.
       */
      if (isMixinEntry) {
        frameType = NSF_CSC_TYPE_ACTIVE_MIXIN;
        object->mixinStack->currentCmdPtr = currentCmd;
      }
    }

    /*
     * Change the filter state.
     */
    if (object->filterStack != NULL) {
      if (cscPtr->frameType == NSF_CSC_TYPE_ACTIVE_FILTER) {
        /*fprintf(stderr, "next changes filter state\n");*/
        cscPtr->frameType = NSF_CSC_TYPE_INACTIVE_FILTER;
      }

      /*
       * Move the command pointer forward.
       */
      if (isFilterEntry) {
        /*fprintf(stderr, "next moves filter forward\n");*/
        frameType = NSF_CSC_TYPE_ACTIVE_FILTER;
        object->filterStack->currentCmdPtr = currentCmd;
      }
    }

    /*
     * Now actually call the "next" method.
     */
    cscPtr->flags |= NSF_CSC_CALL_IS_NEXT;
    rst->unknown = 0;
#if defined(NRE)
    { unsigned int flags;
      /*
       * If the caller has NRE without immediate, allow only a call without the
       * immediate flag,
       */
      flags = NsfImmediateFromCallerFlags(cscPtr->flags);

      /*fprintf(stderr, "MethodDispatch in next flags %.6x NRE %d immediate %d next-flags %.6x\n",
        cscPtr->flags,
        (cscPtr->flags & NSF_CSC_CALL_IS_NRE) != 0,
        (cscPtr->flags & NSF_CSC_IMMEDIATE) != 0,
        flags);*/

      if (flags == 0) {
        /*
         * The call is NRE-enabled. Add the callback and return immediately.
         * In all other cases call NextInvokeFinalize() manually on return.
         */
        Tcl_NRAddCallback(interp, NextInvokeFinalize,
                          freeArgumentVector ? (ClientData)objv : NULL,
                          cscPtr, NULL, NULL);
        return MethodDispatch(interp, objc, objv, cmd,
                              object, class, methodName, frameType, flags);
      } else {
        result = MethodDispatch(interp, objc, objv, cmd,
                                object, class, methodName, frameType, flags);
      }
    }
#else
    /*fprintf(stderr, "NextSearchAndWinvoke calls cmd %p methodName %s cscPtr->flags %.8x\n",
      cmd, methodName, cscPtr->flags);*/
    result = MethodDispatch(interp, objc, objv, cmd,
                            object, class, methodName, frameType, cscPtr->flags);
#endif
  } else if (likely(result == TCL_OK)) {
    NsfCallStackContent *topCscPtr;
    Tcl_CallFrame       *varFramePtr = NULL;
    int                  isLeafNext;

    /*
     * If no command was found and there was no error, one of the following
     * conditions is true:
     *
     * An explicit "next" cmd (NsfNextCmd()) at the end of a filter chain.
     *
     *     Dispatch to unknown as no implementation for the requested is
     *     available.
     *
     * An explicit "next" cmd from within a leaf sub-method, i.e. a "leaf
     * next".
     *
     *     Remain silent.  Do not dispatch to unknown.
     *
     * An implicit "next" triggered for unresolved sub-methods that might be
     * resolved along the next path
     *
     *     The requested sub-cmd is not resolvable to a cmd. Dispatch to
     *     unknown.
     *
     * For the first and third cases, set the interp's unknown flag, signaling
     * to higher levels, e.g. MethodDispatchCsc() or in NsfNextCmd(), the need
     * to dispatch to unknown.
     */

    /* NsfShowStack(interp);*/

    topCscPtr = CallStackGetTopFrame(interp, &varFramePtr);
    assert(topCscPtr != NULL);
    assert(varFramePtr != NULL);

    /*
     * If an ensemble dispatch is in progress, find the appropriate frame
     * pointing to the start of the ensemble.
     */
    /*fprintf(stderr, "######## cscPtr %p topCscPtr %p\n", cscPtr, topCscPtr);*/
    if ( cscPtr != topCscPtr
         && (cscPtr->flags & NSF_CSC_CALL_IS_ENSEMBLE) != 0u
         && (topCscPtr->flags & NSF_CSC_CALL_IS_ENSEMBLE) != 0u) {

      for (; varFramePtr != NULL; varFramePtr = Tcl_CallFrame_callerPtr(varFramePtr)) {
        topCscPtr = (NsfCallStackContent *)Tcl_CallFrame_clientData(varFramePtr);
        assert(topCscPtr != NULL);
        /*fprintf(stderr, "######## cscPtr %p topCscPtr %p topCscPtr->flags %8x\n",
          cscPtr, topCscPtr, (topCscPtr != NULL) ? topCscPtr->flags : 0);*/
        if ((topCscPtr->flags & NSF_CM_ENSEMBLE_UNKNOWN) != 0u) {
          break;
        }
      }

      if (varFramePtr != NULL) {
        varFramePtr = Tcl_CallFrame_callerPtr(varFramePtr);
        if (((unsigned int)Tcl_CallFrame_isProcCallFrame(varFramePtr) & (FRAME_IS_NSF_METHOD|FRAME_IS_NSF_CMETHOD)) != 0u) {
          topCscPtr = (NsfCallStackContent *)Tcl_CallFrame_clientData(varFramePtr);
          assert(topCscPtr != NULL);
        }
      }
    }

    /* case 2 */
    isLeafNext = (cscPtr != topCscPtr)
      && (topCscPtr->frameType & NSF_CSC_TYPE_ENSEMBLE) != 0u
      && (topCscPtr->flags & NSF_CSC_CALL_IS_ENSEMBLE) == 0u;

    /*fprintf(stderr, "******** isleavenext %d based on %d && %d && %d <%s>\n",
            isLeafNext,
            (cscPtr != topCscPtr),
            (topCscPtr->frameType & NSF_CSC_TYPE_ENSEMBLE) != 0u,
            (topCscPtr->flags & NSF_CSC_CALL_IS_ENSEMBLE) == 0u);*/

    /*
     * If ENSEMBLE_UNKNOWN is active this may be a particular variant of case
     * 2: When "next" is called from an ensemble method, e.g. from a method "i
     * s", the call of "next" has to start over from "i" to search for the next
     * method, e.g. the next "i s" that was overriden, but there is none,
     * leading to the ENSEMBLE_UNKNOWN state, not immediately after the "next"
     * call, but after the other checks for handling this case fails, even
     * though called from "next".
     *
     * Therefore, inspect the call stack to determine whether whether there is
     * an an ensemble on a path leading to an invocation of "next".
     *
     * Such a situation is e.g. (simplified stack view, then with flag names)
     *
     *        varFrame  flags lvl csc          frameType flags
     *  0x7ffeeb7b1698 040001  5  0x7ffeeb7b1870    0000 8000104 (::b.0x7fa756821490 i)
     *  0x7fa75480eda0 020001  4  0x7fa75480ed40    0020 002100 (::b.0x7fa756821e10 s)
     *  0x7ffeeb7b2028 040001  3  0x7ffeeb7b2370    0000 000005 (::b.0x7fa756821c10 i)
     *
     * topcsc 0x7ffeeb7b1870
     * 0x7ffeeb7b1698   flags NSF_CSC_CALL_IS_ENSEMBLE|NSF_CSC_IMMEDIATE|NSF_CM_ENSEMBLE_UNKNOWN
     * 0x7fa75480eda0   flags NSF_CSC_CALL_IS_NRE|NSF_CSC_IMMEDIATE frametype NSF_CSC_TYPE_ENSEMBLE
     * 0x7ffeeb7b2028   flags NSF_CSC_CALL_IS_NEXT|NSF_CSC_CALL_IS_ENSEMBLE
     *
     */
    if (!isLeafNext && (topCscPtr->flags & NSF_CM_ENSEMBLE_UNKNOWN) != 0u) {

      for (;;) {
        varFramePtr = Tcl_CallFrame_callerPtr(varFramePtr);
        if (unlikely(varFramePtr == NULL)) {
          break;
        }
        if (((unsigned int)Tcl_CallFrame_isProcCallFrame(varFramePtr)
             & (FRAME_IS_NSF_METHOD|FRAME_IS_NSF_CMETHOD)) == 0) {
          /*
           * Parent frame is not an Nsf frame.
           */
          /*fprintf(stderr, "******** parent frame ptr is not an Nsf frame %p\n", (void*)varFramePtr);*/
          break;
        }
        topCscPtr = (NsfCallStackContent *)Tcl_CallFrame_clientData(varFramePtr);
        if ((topCscPtr->frameType & NSF_CSC_TYPE_ENSEMBLE) == 0u) {
          /*
           * Call stack content not of type ensemble.
           */
          /*fprintf(stderr, "******** topCscPtr not type ensemble %p\n", (void*)topCscPtr);*/
          break;
        }
      }

      isLeafNext = (
          (topCscPtr->flags & (NSF_CSC_CALL_IS_NEXT|NSF_CSC_CALL_IS_ENSEMBLE)) == (NSF_CSC_CALL_IS_NEXT|NSF_CSC_CALL_IS_ENSEMBLE) &&
          (topCscPtr->flags & NSF_CM_ENSEMBLE_UNKNOWN) == 0u
      );
      /*fprintf(stderr, "******** alternate isleavenext %d based on topcscptr %p flags %.6x\n",
        isLeafNext,
        (void*)topCscPtr,
        (topCscPtr != NULL ? topCscPtr->flags : 0));*/
    }

    rst->unknown =
      /* case 1 */ endOfFilterChain ||
      /* case 3 */ (!isLeafNext && ((cscPtr->flags & NSF_CSC_CALL_IS_ENSEMBLE) != 0u));

    /*NsfShowStack(interp);*/

    /*fprintf(stderr, "******** setting unknown to %d isLeafNext %d topCscPtr %p endOfFilterChain %d\n",
      rst->unknown, isLeafNext, (void *)topCscPtr, endOfFilterChain);*/
  }

 next_search_and_invoke_cleanup:
  /*
   * Thre is no NRE callback.
   */
  {ClientData data[2] = {
      freeArgumentVector ? (ClientData)objv : NULL,
      cscPtr
    };

    return NextInvokeFinalize(data, interp, result);
  }
}

/*
 *----------------------------------------------------------------------
 * NsfNextObjCmd --
 *
 *    nsf::xotclnext is for backwards compatibility with the implementation of
 *    [next] in XOTcl.  Invokes an overridden command, passing to it the given
 *    arguments or the arguments of the last invocation if no arguments are
 *    given.  If the first argument is "--noArgs", then no arguments are passed
 *    to the overridden method.
 *
 *    TODO: In the bigger picture this routine should go into an external
 *    library, e.g. an XOTcl compatibility library.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */
static int
NsfNextObjCmd(ClientData UNUSED(clientData), Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])
  nonnull(2) nonnull(4);

static int
NsfNextObjCmd(ClientData UNUSED(clientData), Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int                  result, nobjc = 0;
  bool                 freeArgumentVector;
  const char          *methodName = NULL;
  NsfCallStackContent *cscPtr;
  Tcl_Obj            **nobjv;

  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);

  if (likely(objc < 2)) {
    /*
     * No arguments were provided.
     */
    objc = 0;
  } else {
    /*
     * "--noArgs" was given.  Remove the flag and provide an empty argument
     * list.
     */
    const char *arg1String = ObjStr(objv[1]);

    if (*arg1String == '-' && !strcmp(arg1String, "--noArgs")) {
      objc = 1;
    }
  }

  result = NextGetArguments(interp, objc-1, &objv[1], &cscPtr, &methodName,
                            &nobjc, &nobjv, &freeArgumentVector);
  if (likely(result == TCL_OK)) {
    assert(nobjc > 0);
    result = NextSearchAndInvoke(interp, methodName, nobjc, nobjv, cscPtr, freeArgumentVector);
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * FindNextMethod --
 *
 *    Called via [current nextmethod] to resolve the method to be invoked by
 *    [next].  Returns the overridden method for the current frame if there is
 *    one.  There might not be a next method or this routine may have been
 *    called from outside of Nsf.  The caller owns any resulting Tcl_Obj.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static Tcl_Obj *FindNextMethod(Tcl_Interp *interp, Tcl_CallFrame *framePtr)
  nonnull(1) nonnull(2);

static Tcl_Obj *FindNextMethod(Tcl_Interp *interp, Tcl_CallFrame *framePtr) {
  Tcl_Obj             *result;
  NsfCallStackContent *cscPtr;

  nonnull_assert(interp != NULL);
  nonnull_assert(framePtr != NULL);

  cscPtr = Tcl_CallFrame_clientData(framePtr);
  if (unlikely(cscPtr == NULL)) {
    result = NULL;

  } else {
    bool         isEnsemble,
                 isMixinEntry = NSF_FALSE,
                 isFilterEntry = NSF_FALSE,
                 endOfFilterChain = NSF_FALSE;
    Tcl_Command  cmd = NULL, currentCmd = NULL;
    const char  *lookupMethodName, *methodName;
    NsfClass    *class;
    NsfObject   *object;

    isEnsemble = ((cscPtr->frameType & NSF_CSC_TYPE_ENSEMBLE) != 0u);

    methodName = Tcl_GetCommandName(interp, cscPtr->cmdPtr);
    if (isEnsemble) {
      NsfCallStackContent *cscPtr1 = CallStackFindEnsembleCsc(framePtr, &framePtr);

      lookupMethodName = MethodName(cscPtr1->objv[0]);
    } else {
      lookupMethodName = methodName;
    }

    class = cscPtr->cl;
    object = cscPtr->self;

    if (NextSearchMethod(object, interp, cscPtr,
                         &class, &lookupMethodName, &cmd, &isMixinEntry, &isFilterEntry,
                         &endOfFilterChain, &currentCmd) == TCL_OK
        && cmd != NULL) {
      Tcl_Obj *pathObj = NsfMethodNamePath(interp, framePtr, methodName);
      INCR_REF_COUNT(pathObj);

      methodName = isEnsemble ? ObjStr(pathObj) : lookupMethodName;
      result = MethodHandleObj((class != NULL) ? (NsfObject *)class : object, (class == NULL), methodName);
      DECR_REF_COUNT(pathObj);
    } else {
      result = NULL;
    }
  }
  return result;
}


/*
 *----------------------------------------------------------------------
 * ComputeLevelObj --
 *
 *    Returns the specified level as a new Tcl_Obj owned by the caller.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static Tcl_Obj * ComputeLevelObj(Tcl_Interp *interp, CallStackLevel level)
  nonnull(1) returns_nonnull;

static Tcl_Obj *
ComputeLevelObj(Tcl_Interp *interp, CallStackLevel level) {
  Tcl_CallFrame *framePtr;
  Tcl_Obj       *resultObj;

  nonnull_assert(interp != NULL);

  switch (level) {
  case CALLING_LEVEL: {
    Tcl_CallFrame *callingFramePtr = NULL;

    /*
     * Even though NsfCallStackFindCallingContext() sets the framePtr,
     * initialize framePtr explicitly to silence static checkers since
     * ComputeLevelObj() is not performance-critical.
     */
    framePtr = NULL;
    NsfCallStackFindCallingContext(interp, 1, &framePtr, &callingFramePtr);
    if (framePtr == NULL) {
      framePtr = callingFramePtr;
    }
    break;
  }
  case ACTIVE_LEVEL:
    NsfCallStackFindActiveFrame(interp,    1, &framePtr);
    break;
  }

  if (framePtr != NULL) {
    /*
     * This is an Nsf frame.  Return the absolute frame number.
     */
    char buffer[LONG_AS_STRING];
    int  l;

    buffer[0] = '#';
    Nsf_ltoa(buffer+1, (long)Tcl_CallFrame_level(framePtr), &l);
    resultObj = Tcl_NewStringObj(buffer, l+1);
  } else {
    /*
     * Return #0 if not called from an Nsf frame.
     *
     * TODO: With NsfCallStackFindCallingContext in place this should not be
     * reachable. Check NsfCallStackFindActiveFrame. When "in the clear",
     * provide a warning here?
     *
     */
    resultObj = Tcl_NewStringObj("#0", 2);
  }

  return resultObj;
}

/*
  int
  NsfKObjCmd(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  if (objc < 2) {
    return NsfPrintError(interp, "wrong # of args for K");
  }

  Tcl_SetObjResult(interp, objv[1]);
  return TCL_OK;
  }
*/

/*
 * object creation & destruction
 */

/*
 *----------------------------------------------------------------------
 * UnsetInAllNamespaces --
 *
 *    Unsets a variable in the given namespace and all namespaces under it, if
 *    possible.  Used by volatile to unset the automatic variable set for the
 *    destroy trace.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static int UnsetInAllNamespaces(
    Tcl_Interp *interp, const Tcl_Namespace *nsPtr, const char *name
) nonnull(1) nonnull(2) nonnull(3);

static int
UnsetInAllNamespaces(
    Tcl_Interp *interp, const Tcl_Namespace *nsPtr, const char *name
) {
  int            rc = 0;
  Tcl_HashSearch search;
  Tcl_HashEntry *entryPtr;
  const Tcl_Var *varPtr;

  nonnull_assert(interp != NULL);
  nonnull_assert(nsPtr != NULL);
  nonnull_assert(name != NULL);

  /*fprintf(stderr, "### UnsetInAllNamespaces variable '%s', current namespace '%s'\n",
          name, (nsPtr != NULL) ? nsPtr->fullName : "NULL");*/

  entryPtr = Tcl_FirstHashEntry(Tcl_Namespace_childTablePtr(nsPtr), &search);
  varPtr = (Tcl_Var *) Tcl_FindNamespaceVar(interp, name, (Tcl_Namespace *)nsPtr, 0);
  /*fprintf(stderr, "found %s in %s -> %p\n", name, nsPtr->fullName, varPtr);*/
  if (varPtr != NULL) {
    Tcl_DString dFullname, *dsPtr = &dFullname;
    int         result;

    Tcl_DStringInit(dsPtr);
    Tcl_DStringAppend(dsPtr, "unset ", -1);
    DStringAppendQualName(dsPtr, nsPtr, name);

    result = Tcl_Eval(interp, Tcl_DStringValue(dsPtr));
    /* fprintf(stderr, "fqName = '%s' unset => %d %d\n", Tcl_DStringValue(dsPtr), rc, TCL_OK);*/
    if (likely(result == TCL_OK)) {
      rc = 1;
    } else {
      Tcl_Obj *resultObj = Tcl_GetObjResult(interp);
      fprintf(stderr, "   err = '%s'\n", ObjStr(resultObj));
    }
    Tcl_DStringFree(dsPtr);
  }

  while ((rc == 0) && (entryPtr != NULL)) {
    Tcl_Namespace *childNsPtr = (Tcl_Namespace *) Tcl_GetHashValue(entryPtr);
    /*fprintf(stderr, "child = %s\n", childNsPtr->fullName);*/
    entryPtr = Tcl_NextHashEntry(&search);
    rc |= UnsetInAllNamespaces(interp, childNsPtr, name);
  }

  return rc;
}

/*
 *----------------------------------------------------------------------
 * FreeUnsetTraceVariable --
 *
 *    Unsets the trace variable for the given object.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static int FreeUnsetTraceVariable(Tcl_Interp *interp, const NsfObject *object)
  nonnull(1) nonnull(2);

static int
FreeUnsetTraceVariable(Tcl_Interp *interp, const NsfObject *object) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  if (object->opt != NULL && (object->opt->volatileVarName != NULL)) {
    int result = Tcl_UnsetVar2(interp, object->opt->volatileVarName, NULL, 0);

    if (unlikely(result != TCL_OK)) {
      /*
       * Somebody has manually destroyed a volatile object while the variable
       * trace is still active. There could be a problem if something later
       * unsets the variable, triggering the trace. Unset the variable here,
       * triggering a destroy via variable trace, which in turn clears the
       * volatileVarName flag.
       */
      /* fprintf(stderr, "### FreeUnsetTraceVariable %s\n", object->opt->volatileVarName);*/

      result = Tcl_UnsetVar2(interp, object->opt->volatileVarName, NULL, TCL_GLOBAL_ONLY);

      if (unlikely(result != TCL_OK)) {
        Tcl_Namespace *nsPtr = Tcl_GetCurrentNamespace(interp);
        if (UnsetInAllNamespaces(interp, nsPtr, object->opt->volatileVarName) == 0) {
          fprintf(stderr, "### don't know how to delete variable '%s' of volatile object\n",
                  object->opt->volatileVarName);
          /*
           * Return success since an error during destroy does not help at all.
           */
        }
      }
    }
    /*fprintf(stderr, "### FreeUnsetTraceVariable returns %d OK %d\n", result, TCL_OK);*/
  }

  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 * NsfUnsetTrace --
 *
 *    Called when the trace variable is deleted. Typically deletes the
 *    associated object.
 *
 * Results:
 *    A result message or NULL.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static const char *NsfUnsetTrace(
    ClientData clientData, Tcl_Interp *interp,
    const char *UNUSED(name), const char *UNUSED(name2), unsigned int UNUSED(flags)
) nonnull(1) nonnull(2);

static const char *
NsfUnsetTrace(
    ClientData clientData, Tcl_Interp *interp,
    const char *UNUSED(name), const char *UNUSED(name2), unsigned int UNUSED(flags)
) {
  Tcl_Obj    *objPtr = (Tcl_Obj *)clientData;
  NsfObject  *object;
  const char *resultMsg = NULL;

  nonnull_assert(clientData != NULL);
  nonnull_assert(interp != NULL);

  /*fprintf(stderr, "NsfUnsetTrace %s flags %.4x deleted %d\n", name, flags,
    Tcl_InterpDeleted(interp));*/

  if (Tcl_InterpDeleted(interp) == 0) {
    if (GetObjectFromObj(interp, objPtr, &object) == TCL_OK) {
      Tcl_Obj *savedResultObj = Tcl_GetObjResult(interp); /* save the result */

      INCR_REF_COUNT(savedResultObj);

      /*
       * Clear the variable.  The trace calls Destroy.
       */
      if (object->opt != NULL && object->opt->volatileVarName) {
        object->opt->volatileVarName = NULL;
      }

      if (DispatchDestroyMethod(interp, object, 0u) != TCL_OK) {
        resultMsg = "Destroy for volatile object failed";
      } else {
        resultMsg = "No Nsf Object passed";
      }

      Tcl_SetObjResult(interp, savedResultObj);  /* restore the result */
      DECR_REF_COUNT(savedResultObj);
    }
    DECR_REF_COUNT(objPtr);
  } else {
    /*fprintf(stderr, "omitting destroy on %s %p\n", name);*/
  }
  return resultMsg;
}

/*
 *----------------------------------------------------------------------
 * CleanupDestroyObject --
 *
 *    Returns an object to its just-initialized state.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    May free memory.
 *
 *----------------------------------------------------------------------
 */
static void CleanupDestroyObject(Tcl_Interp *interp, NsfObject *object, bool softrecreate)
  nonnull(1) nonnull(2);

static void
CleanupDestroyObject(Tcl_Interp *interp, NsfObject *object, bool softrecreate) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  /*fprintf(stderr, "CleanupDestroyObject obj %p softrecreate %d nsPtr %p\n",
    object, softrecreate, object->nsPtr);*/

  /*
   * The object pointer points to the same object so it is not sufficient for
   * methodObj validation.  Increment the objectMethodEpoch if an object has
   * its own methods.
   */
  if (object->nsPtr != NULL) {
    NsfObjectMethodEpochIncr("CleanupDestroyObject");
  }

  /*
   * Remove the instance unless this is ::Class/::Object.
   */
  if (!IsBaseClass(object)) {

    if (!softrecreate) {
      RemoveInstance(object, object->cl);
    }
  }

  /*
   * Preemptively unset object variables with unset traces.
   */
  UnsetTracedVars(interp, object);

  if (object->nsPtr != NULL) {
    NSCleanupNamespace(interp, object->nsPtr);
    NSDeleteChildren(interp, object->nsPtr);
  }

  if (object->varTablePtr != NULL) {
    /*
     * unset-traced variables have already been deleted by UnsetTracedVars.
     */
    TclDeleteVars(((Interp *)interp), object->varTablePtr);

    ckfree((char *)object->varTablePtr);
    /*FREE(obj->varTablePtr, obj->varTablePtr);*/
    object->varTablePtr = 0;
  }

  if (object->opt != NULL) {
    NsfObjectOpt *opt = object->opt;
#if defined(NSF_WITH_ASSERTIONS)
    if (opt->assertions != NULL) {
      AssertionRemoveStore(opt->assertions);
      opt->assertions = NULL;
    }
#endif

#if defined(PER_OBJECT_PARAMETER_CACHING)
    if (object->opt->parsedParamPtr != NULL) {
      NsfParameterCacheObjectInvalidateCmd(interp, object);
    }
#endif

    if (!softrecreate) {
      /*
       * Remove this object from the mixin list of all other objects and free
       * this object's objMixins, objFilters, and opt.
       */
      if (opt->objMixins != NULL) {
        RemoveFromObjectMixinsOf(object->id, opt->objMixins);
      }

      CmdListFree(&opt->objMixins, GuardDel);
      CmdListFree(&opt->objFilters, GuardDel);
      FREE(NsfObjectOpt, opt);
      object->opt = NULL;
    }
  }

  object->flags &= ~NSF_MIXIN_ORDER_VALID;
  if (object->mixinOrder != NULL) {
    MixinResetOrder(object);
  }
  object->flags &= ~NSF_FILTER_ORDER_VALID;
  if (object->filterOrder != NULL) {
    FilterResetOrder(object);
  }
}

/*
 * object initialization & namespace creation.
 */

/*
 *----------------------------------------------------------------------
 * CleanupInitObject --
 *
 *    Initializes the given object to its pristine state.
 *    cl might be NULL during bootstrap.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void CleanupInitObject(
    Tcl_Interp *interp, NsfObject *object,
    NsfClass *class, Tcl_Namespace *nsPtr, bool softrecreate
) nonnull(1) nonnull(2);

static void
CleanupInitObject(
    Tcl_Interp *interp, NsfObject *object,
    NsfClass *class, Tcl_Namespace *nsPtr, bool softrecreate
) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

#ifdef OBJDELETION_TRACE
  fprintf(stderr, "+++ CleanupInitObject\n");
#endif
  object->teardown = interp;
  object->nsPtr = nsPtr;

  if (!softrecreate && class != NULL) {
    AddInstance(object, class);
  }
  if ((object->flags & NSF_RECREATE) != 0u) {
    object->opt = NULL;
    object->varTablePtr = NULL;
    object->mixinOrder = NULL;
    object->filterOrder = NULL;
    object->flags = 0;
  }
  /*
    fprintf(stderr, "cleanupInitObject %s: %p cl = %p\n", (obj->cmdName != NULL) ? ObjectName(object) : "", object, object->cl);*/
}

/*
 *----------------------------------------------------------------------
 * PrimitiveDestroy --
 *
 *    Dispatches PrimitiveCDestroy on the object if it is a class, and
 *    PrimitiveODestroy otherwise.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static void
PrimitiveDestroy(ClientData clientData) {

  nonnull_assert(clientData != NULL);

  if (NsfObjectIsClass((NsfObject *)clientData)) {
    PrimitiveCDestroy(clientData);
  } else {
    PrimitiveODestroy(clientData);
  }
}

/*
 *----------------------------------------------------------------------
 * TclDeletesObject --
 *
 *    Called by Tcl when it deletes a command associated with an Nsf
 *    object/class, e.g. when a namespace is deleted.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static void TclDeletesObject(ClientData clientData)
  nonnull(1);

static void
TclDeletesObject(ClientData clientData) {
  NsfObject *object;

  nonnull_assert(clientData != NULL);

  object = (NsfObject *)clientData;

  /*
   * TODO: It would be a good idea to flag a deletion from Tcl by setting
   * object->id to NULL, but there are currently some dependencies preventing
   * this, so set a flag instead.
   */
  object->flags |= NSF_TCL_DELETE;

  /*fprintf(stderr, "cmd dealloc %p TclDeletesObject (%d)\n",
    object->id,  Tcl_Command_refCount(object->id));*/

#ifdef OBJDELETION_TRACE
  fprintf(stderr, "TclDeletesObject %p obj->id %p flags %.6x\n", object, object->id, object->flags);
#endif
  if (unlikely((object->flags & NSF_DURING_DELETE) == 0u)
      && (object->teardown != NULL)
      ) {

# ifdef OBJDELETION_TRACE
    fprintf(stderr, "... %p %s\n", object, ObjectName(object));
# endif

    CallStackDestroyObject(object->teardown, object);
  }
}


/*
 *----------------------------------------------------------------------
 * PrimitiveODestroy --
 *
 *    Deletes an object, its namespace, mixin stack, and filter stack. The
 *    NsfCleanupObject() frees the object at the right time.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Free object contents.
 *
 *----------------------------------------------------------------------
 */
static void
PrimitiveODestroy(ClientData clientData) {
  NsfObject  *object;
  Tcl_Interp *interp;

  nonnull_assert(clientData != NULL);

  object = (NsfObject *)clientData;
  assert(object->teardown != NULL);

  /*fprintf(stderr, "****** PrimitiveODestroy %p cmd %p flags %.6x\n",
    (void *)object, (void *)object->id, object->flags);*/

  /*
   * Destroy should have been called but the object not yet deleted.
   */
  assert((object->flags & NSF_DELETED) == 0u);
  assert((object->flags & NSF_DESTROY_CALLED) != 0u);

  /*
   * Check and latch against recurrent calls with object->teardown.
   */
  PRINTOBJ("PrimitiveODestroy", object);
  interp = object->teardown;

  /*
   * Don't destroy the object if the interpreter is being destroyed, e.g. if Tk
   * calls Tcl_DeleteInterp directly, or the window is killed.
   */
  if (!Tcl_InterpDeleted(interp)) {

#ifdef OBJDELETION_TRACE
    {Command *cmdPtr = object->id;
      fprintf(stderr, "  physical delete of %p id=%p (cmd->refCount %d) destroyCalled=%d '%s'\n",
              object, object->id, cmdPtr->refCount, (object->flags & NSF_DESTROY_CALLED), ObjectName(object));
    }
#endif
    CleanupDestroyObject(interp, object, NSF_FALSE);

    while (object->mixinStack != NULL) {
      MixinStackPop(object);
    }

    while (object->filterStack != NULL) {
      FilterStackPop(object);
    }

    /*
     * The object is now mostly dead.  Delete children first since
     * Nsf_DeleteNamespace might delegate to the parent, e.g.  slots, and then
     * clear the teardown member.
     */
    if (object->nsPtr != NULL) {
      /*fprintf(stderr, "PrimitiveODestroy calls deleteNamespace for object %p nsPtr %p\n", (void*)object, object->nsPtr);*/
      Nsf_DeleteNamespace(interp, object->nsPtr);
      object->nsPtr = NULL;
    }
    object->teardown = NULL;

    /*fprintf(stderr, " +++ OBJ/CLS free: %p %s\n", (void *)object, ObjectName(object));*/

    object->flags |= NSF_DELETED;
    ObjTrace("ODestroy", object);

    DECR_REF_COUNT(object->cmdName);
    NsfCleanupObject(object, "PrimitiveODestroy");
  }
}

/*
 *----------------------------------------------------------------------
 * DoDealloc --
 *
 *    Deallocates an object. Called from the dealloc method and also
 *    internally.  Cares about volatile, and frees/triggers free operation
 *    depending on the stack references.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static int DoDealloc(Tcl_Interp *interp, NsfObject *object)
  nonnull(1) nonnull(2);

static int
DoDealloc(Tcl_Interp *interp, NsfObject *object) {
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  /*fprintf(stderr, "DoDealloc obj= %s %p flags %.6x activation %d cmd %p opt=%p\n",
          ObjectName(object), object, object->flags, object->activationCount,
          object->id, object->opt);*/

  result = FreeUnsetTraceVariable(interp, object);
  if (unlikely(result == TCL_OK)) {
    if (RUNTIME_STATE(interp)->exitHandlerDestroyRound !=
        NSF_EXITHANDLER_ON_SOFT_DESTROY) {
      CallStackDestroyObject(interp, object);
    }
  }

  return result;
}


/*
 *----------------------------------------------------------------------
 * MarkUndestroyed --
 *
 *    Removes any mark that destroy was called on the object. Used, e.g.
 *    during recreation.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void MarkUndestroyed(NsfObject *object)
  nonnull(1);

static void
MarkUndestroyed(NsfObject *object) {

  nonnull_assert(object != NULL);

  object->flags &= ~NSF_DESTROY_CALLED;
}

/*
 *----------------------------------------------------------------------
 * PrimitiveOInit --
 *
 *    Sets/resets the object to a fresh, un-destroyed state.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void PrimitiveOInit(NsfObject *object, Tcl_Interp *interp, const char *name,
                           Tcl_Namespace *nsPtr, NsfClass *class)
  nonnull(1) nonnull(2) nonnull(3);

static void
PrimitiveOInit(NsfObject *object, Tcl_Interp *interp, const char *name,
               Tcl_Namespace *nsPtr, NsfClass *class) {

  nonnull_assert(object != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(name != NULL);

#ifdef OBJDELETION_TRACE
  fprintf(stderr, "+++ PrimitiveOInit\n");
#endif

#ifdef NSFOBJ_TRACE
  fprintf(stderr, "OINIT %s = %p\n", name, object);
#endif
  NsfObjectRefCountIncr(object);
  MarkUndestroyed(object);

  /*
   * If there is already a namespace with the given name, use it as the
   * namespace for the object.  It might contain Next Scripting objects, and
   * not reusing it would result in these objects not being recognized as child
   * objects, and deletions of the object might lead to a crash.
   *
   * If this namespace is not being destroyed, e.g. recreation of a new object
   * from a different object system, use the given nsPtr.
   */

  if (nsPtr != NULL && (((Namespace *)nsPtr)->flags & NS_DYING) != 0u) {
    Namespace  *dummy1Ptr, *dummy2Ptr, *nsPtr1 = (Namespace *)nsPtr;
    const char *dummy;
    TclGetNamespaceForQualName(interp, name,
                               NULL, TCL_GLOBAL_ONLY|TCL_FIND_ONLY_NS,
                               &nsPtr1, &dummy1Ptr, &dummy2Ptr, &dummy);
    nsPtr = (Tcl_Namespace *)nsPtr1;
    /*fprintf(stderr, "PrimitiveOInit %p calls TclGetNamespaceForQualName with %s => %p given %p object->nsPtr %p\n",
            object, name,
            nsPtr, nsPtr, object->nsPtr);*/
  }

  if (nsPtr != NULL) {
    NsfNamespaceInit(nsPtr);
  }

  /* fprintf(stderr, "PrimitiveOInit %p %s, ns %p\n", object, name, nsPtr); */
  CleanupInitObject(interp, object, class, nsPtr, NSF_FALSE);

  /*
   * TODO: would be nice if object flags could be initialized.
   */
  /* object->flags = NSF_MIXIN_ORDER_VALID | NSF_FILTER_ORDER_VALID;*/
  object->mixinStack = NULL;
  object->filterStack = NULL;
}

/*
 *----------------------------------------------------------------------
 * PrimitiveOCreate --
 *
 *    Returns a new nsfObject* having the given name, after creating the
 *    associated Tcl command and calling the initialization routines.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static NsfObject * PrimitiveOCreate(Tcl_Interp *interp, Tcl_Obj *nameObj, Tcl_Namespace *parentNsPtr, NsfClass *class)
  nonnull(1) nonnull(2) nonnull(4) returns_nonnull;

static NsfObject *
PrimitiveOCreate(Tcl_Interp *interp, Tcl_Obj *nameObj, Tcl_Namespace *parentNsPtr, NsfClass *class) {
  const char    *nameString;
  Tcl_Namespace *nsPtr;
  NsfObject     *object;

  nonnull_assert(interp != NULL);
  nonnull_assert(nameObj != NULL);
  nonnull_assert(class != NULL);

  object = (NsfObject *)ckalloc((int)sizeof(NsfObject));
  MEM_COUNT_ALLOC("NsfObject/NsfClass", object);
  assert(object != NULL); /* ckalloc panics, if malloc fails */

  memset(object, 0, sizeof(NsfObject));

  nameString = ObjStr(nameObj);
  assert(isAbsolutePath(nameString));

#if defined(NSFOBJ_TRACE)
  fprintf(stderr, "CKALLOC Object %p %s\n", object, nameString);
#endif
#ifdef OBJDELETION_TRACE
  fprintf(stderr, "+++ PrimitiveOCreate\n");
#endif

  nsPtr = NSCheckNamespace(interp, nameString, parentNsPtr);
  if (nsPtr != NULL) {
    NSNamespacePreserve(nsPtr);
  }
#if defined(NRE)
  object->id = Tcl_NRCreateCommand(interp, nameString,
                                   NsfObjDispatch,
                                   NsfObjDispatchNRE,
                                   object, TclDeletesObject);
#else
  object->id = Tcl_CreateObjCommand(interp, nameString, NsfObjDispatch,
                                    object, TclDeletesObject);
#endif

  /*fprintf(stderr, "cmd alloc %p %d (%s)\n", object->id,
    Tcl_Command_refCount(object->id), nameString);*/

  PrimitiveOInit(object, interp, nameString, nsPtr, class);
  if (nsPtr != NULL) {
    NSNamespaceRelease(nsPtr);
  }

  object->cmdName = nameObj;
  INCR_REF_COUNT(object->cmdName);

  ObjTrace("PrimitiveOCreate", object);

  return object;
}

/*
 *----------------------------------------------------------------------
 * DefaultSuperClass --
 *
 *    Returns the default superclass, if any, of the given class and metaclass,
 *    searchin for the variable NSF_DEFAULTMETACLASS or NSF_DEFAULTSUPERCLASS
 *    in the process.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static NsfClass *
DefaultSuperClass(Tcl_Interp *interp, const NsfClass *class, const NsfClass *metaClass, bool isMeta) {
  NsfClass *resultClass = NULL;
  Tcl_Obj  *resultObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(metaClass != NULL);

  /*fprintf(stderr, "DefaultSuperClass cl %s, mcl %s, isMeta %d\n",
    ClassName(class), ClassName(metaClass), isMeta );*/

  resultObj = Nsf_ObjGetVar2((Nsf_Object *)metaClass, interp, (isMeta != 0) ?
                             NsfGlobalObjs[NSF_DEFAULTMETACLASS] :
                             NsfGlobalObjs[NSF_DEFAULTSUPERCLASS], NULL, 0);

  if (resultObj != NULL) {
    if (unlikely(GetClassFromObj(interp, resultObj, &resultClass, NSF_FALSE) != TCL_OK)) {
      NsfPrintError(interp, "default superclass is not a class");
    }
    /*fprintf(stderr, "DefaultSuperClass for %s got from var %s => %s\n",
            ClassName(class),
            ObjStr((isMeta != 0) ? NsfGlobalObjs[NSF_DEFAULTMETACLASS] : NsfGlobalObjs[NSF_DEFAULTSUPERCLASS]),
            ClassName(resultClass));*/
  } else {
    const NsfClasses *sc;

    /*fprintf(stderr, "DefaultSuperClass for %s: search in superClasses starting with %p meta %d\n",
      ClassName(class), cl->super, isMeta);*/

    if (isMeta != 0) {
      /*
       * Is this already the root metaclass?
       */
      if (IsRootMetaClass(metaClass->object.cl)) {
        return metaClass->object.cl;
      }
    }

    /*
     * Check superClasses of metaclass.
     */
    for (sc = metaClass->super; sc && sc->cl != class; sc = sc->nextPtr) {
      /* fprintf(stderr, "  ... check ismeta %d %s root mcl %d root cl %d\n",
         isMeta, ClassName(sc->cl),
         sc->cl->object.flags & NSF_IS_ROOT_META_CLASS,
         sc->cl->object.flags & NSF_IS_ROOT_CLASS); */
      if (isMeta != 0) {
        if (IsRootMetaClass(sc->cl)) {
          return sc->cl;
        }
      } else {
        if (IsRootClass(sc->cl)) {
          /* fprintf(stderr, "found root-class %p %s\n", sc->cl, ClassName(sc->cl)); */
          return sc->cl;
        }
      }

      resultClass = DefaultSuperClass(interp, class, sc->cl, isMeta);
      if (resultClass != NULL) {
        break;
      }
    }
  }

  return resultClass;
}

/*
 *----------------------------------------------------------------------
 * CleanupDestroyClass --
 *
 *    Cleans up a class that is being destroyed:  Removes filters, mixins,
 *    assertions, instances, and finally remove the class from the class
 *    hierarchy.  Preserves the pointers from other class structures if the
 *    class is being recreated.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Updated class structures.
 *
 *----------------------------------------------------------------------
 */

static void CleanupDestroyClass(Tcl_Interp *interp, NsfClass *class, bool softrecreate, bool recreate)
  nonnull(1) nonnull(2);

static void
CleanupDestroyClass(Tcl_Interp *interp, NsfClass *class, bool softrecreate, bool recreate) {
  NsfClassOpt *clopt;
  NsfClass    *baseClass = NULL;
  NsfClasses  *subClasses;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);

  PRINTOBJ("CleanupDestroyClass", (NsfObject *)class);
  assert(softrecreate ? recreate : NSF_TRUE);

  clopt = class->opt;
  /*fprintf(stderr, "CleanupDestroyClass %p %s (ismeta=%d) softrecreate=%d, recreate=%d, %p\n",
          class, ClassName(class), IsMetaClass(interp, cl, NSF_TRUE),
          softrecreate, recreate, clopt);*/

  subClasses = DependentSubClasses(class);
  if (subClasses != NULL) {

    /*
     * If the class is a superclass of a class mixed into an object it might
     * have no clopt.  Perform the next steps anyway.
     */
    MixinInvalidateObjOrders(subClasses);
    if (FiltersDefined(interp) > 0) {
      FilterInvalidateObjOrders(interp, subClasses);
    }
  }

  if (clopt != NULL) {
    /*
     *  Remove this class from all isClassMixinOf lists and clear the
     *  class mixin list.
     */
    if (clopt->classMixins != NULL) {
      RemoveFromClassMixinsOf(clopt->id, clopt->classMixins);
    }

    CmdListFree(&clopt->classMixins, GuardDel);
    CmdListFree(&clopt->classFilters, GuardDel);

    if (clopt->mixinRegObjs != NULL) {
      NsfMixinregInvalidate(interp, clopt->mixinRegObjs);
      DECR_REF_COUNT2("mixinRegObjs", clopt->mixinRegObjs);
      clopt->mixinRegObjs = NULL;
    }

    if (!recreate) {
      /*
       *  Remove this class from the mixin list of each object it is mixed into
       *  and then free the isObjectMixinOf list of this class.
       */
      if (clopt->isObjectMixinOf != 0) {
        RemoveFromObjectMixins(clopt->id, clopt->isObjectMixinOf);
      }
      CmdListFree(&clopt->isObjectMixinOf, GuardDel);

      /*
       *  Remove this class from the mixin list of each class it is mixed into,
       *  and then free the isClassMixinOf list of this class.
       */
      if (clopt->isClassMixinOf != 0) {
        RemoveFromClassmixins(clopt->id, clopt->isClassMixinOf);
      }
      CmdListFree(&clopt->isClassMixinOf, GuardDel);
    }

    /*
     * Remove dependent filters of this class from all subclasses.
     */
    if (subClasses != NULL) {
      FilterRemoveDependentFilterCmds(class, subClasses);
    }

#if defined(NSF_WITH_ASSERTIONS)
    if (clopt->assertions != NULL) {
        AssertionRemoveStore(clopt->assertions);
        clopt->assertions = NULL;
      }
#endif

#ifdef NSF_OBJECTDATA
    NsfFreeObjectData(class);
#endif
  }

  NSCleanupNamespace(interp, class->nsPtr);
  NSDeleteChildren(interp, class->nsPtr);

  if (!softrecreate) {

    /*
     * Reclass all instances of this class to the most general appropriate
     * class, e.g. "baseClass". The most general class of a metaclass is the
     * root metaclass.  The most general class of an object is the root class.
     * Instances of metaclasses can be only reset to the root metaclass, not to
     * the root base class.
     */
    baseClass = DefaultSuperClass(interp, class, class->object.cl,
                                  IsMetaClass(interp, class, NSF_TRUE));
    /*
     * No need to reclassify the class if it is root class.
     */
    if (!IsRootClass(class)) {
      Tcl_HashTable       *instanceTablePtr = &class->instances;
      Tcl_HashSearch       hSrch;
      const Tcl_HashEntry *hPtr;

      for (hPtr = Tcl_FirstHashEntry(instanceTablePtr, &hSrch); hPtr != NULL;
           hPtr = Tcl_NextHashEntry(&hSrch)) {
        NsfObject *inst = (NsfObject *)Tcl_GetHashKey(instanceTablePtr, hPtr);

        /*fprintf(stderr, "    inst %p %s flags %.6x id %p baseClass %p %s\n",
          inst, ObjectName(inst), inst->flags, inst->id, baseClass, ClassName(baseClass));*/
        if ((inst != NULL)
            && (inst != (NsfObject *)class)
            && likely((inst->flags & NSF_DURING_DELETE) == 0u) /*inst->id*/
            ) {
          if (inst != &(baseClass->object)) {
            AddInstance(inst, baseClass);
          }
        }
      }
    }
    Tcl_DeleteHashTable(&class->instances);
    MEM_COUNT_FREE("Tcl_InitHashTable", &class->instances);
  }

  if (clopt != NULL && !recreate) {
    FREE(NsfClassOpt, clopt);
    class->opt = NULL;
  }

  if (subClasses != NULL) {
    /*
     * When recreating a class, the newly-created class might has a different
     * superclass, so flush the precedence list.
     */
    FlushPrecedences(subClasses);
    NsfClassListFree(subClasses);
  }

  while (class->super != NULL) {
    (void)RemoveSuper(class, class->super->cl);
  }

  if (!softrecreate) {
    /*
     * Flush all caches and unlink superClasses.
     */

    while (class->sub != NULL) {
      NsfClass *subClass = class->sub->cl;

      (void)RemoveSuper(subClass, class);
      /*
       * If there are no more superclasses add the Object class as
       * superClasses.  Don't do this for Object itself!
       */
      if (subClass->super == NULL && !IsRootClass(class)) {
        /* fprintf(stderr, "subClass %p %s baseClass %p %s\n",
           class, ClassName(class), baseClass, ClassName(baseClass)); */
        AddSuper(subClass, baseClass);
      }
    }
  }

}

/*
 *----------------------------------------------------------------------
 * CleanupInitClass --
 *
 *    Initializes a class: Sets the namespace, super- and subclasses,
 *    and optionally the instances table.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void CleanupInitClass(
    Tcl_Interp *interp, NsfClass *class, Tcl_Namespace *nsPtr,
    bool softrecreate, bool recreate
) nonnull(1) nonnull(2) nonnull(3);

static void
CleanupInitClass(
    Tcl_Interp *interp, NsfClass *class, Tcl_Namespace *nsPtr,
    bool softrecreate, bool recreate
) {
  NsfClass *defaultSuperclass;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(nsPtr != NULL);
  assert((softrecreate) ? recreate : NSF_TRUE);

#ifdef OBJDELETION_TRACE
  fprintf(stderr, "+++ CleanupInitClass\n");
#endif

  /*
   * Flag the object as a class and set its namespace.
   */
  NsfObjectSetClass((NsfObject *)class);
  class->nsPtr = nsPtr;

  if (!softrecreate) {
    /*
     * When recreating a class, preserve subclasses, but a different superclass
     * may be defined for the new class, so don't preserve superclasses.
     */
    class->sub = NULL;
  }
  class->super = NULL;

  /*
   * Derive the default superclass from the metaclass if the metaclass exists.
   */
  if (class->object.cl != NULL) {
    /* Look for a configured default superclass. */
    defaultSuperclass = DefaultSuperClass(interp, class, class->object.cl, NSF_FALSE);
  } else {
    defaultSuperclass = NULL;
  }
  if (class != defaultSuperclass) {
    AddSuper(class, defaultSuperclass);
  }

  class->color = WHITE;
  class->order = NULL;

  if (!softrecreate) {
    Tcl_InitHashTable(&class->instances, TCL_ONE_WORD_KEYS);
    MEM_COUNT_ALLOC("Tcl_InitHashTable", &class->instances);
  }

  if (!recreate) {
    class->opt = NULL;
  }
}

/*
 *----------------------------------------------------------------------
 * PrimitiveCDestroy --
 *
 *    Deletes a class, its namespace, and its associated data structures.
 *    PrimitiveODestroy() handles the physical deallocation.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Frees memory associated with the object.
 *
 *----------------------------------------------------------------------
 */
static void
PrimitiveCDestroy(ClientData clientData) {
  NsfClass      *class;

  nonnull_assert(clientData != NULL);

  class = (NsfClass *)clientData;
  PRINTOBJ("PrimitiveCDestroy", class);

  if (class != NULL && class->object.teardown != NULL) {
    /*
     * initiate teardown
     */
    Tcl_Interp *interp;

    interp = class->object.teardown;

    /*
     * Don't do teardown if the interpreter is in the process of being destroyed,
     * e.g. if Tk calls Tcl_DeleteInterp directly or if Window is killed.
     */
    if (!Tcl_InterpDeleted(interp)) {
      Tcl_Namespace *saved;

      /*
       * set teardown to NULL to prevent it from being called again.
       */
      /*fprintf(stderr, "PrimitiveCDestroy %s flags %.6x\n", ObjectName(object), object->flags);*/

      class->object.teardown = NULL;
      CleanupDestroyClass(interp, class, NSF_FALSE, NSF_FALSE);

      /*
       * Hand off the primitive teardown.
       */
      saved = class->nsPtr;
      class->object.teardown = interp;

      /*
       * Destroy the class and free its memory.
       */
      PrimitiveODestroy(clientData);

      /*fprintf(stderr, "primitive cdestroy calls delete namespace for obj %p, nsPtr %p flags %.6x\n",
        cl, saved, ((Namespace *)saved)->flags);*/
      Nsf_DeleteNamespace(interp, saved);
      /*fprintf(stderr, "primitive cdestroy %p DONE\n", class);*/
    }
  }
  return;
}

/*
 *----------------------------------------------------------------------
 * PrimitiveCInit --
 *
 *    Set/reset a class to a fresh, un-destroyed state.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void PrimitiveCInit(NsfClass *class, Tcl_Interp *interp, const char *name)
  nonnull(1) nonnull(2) nonnull(3);

static void
PrimitiveCInit(NsfClass *class, Tcl_Interp *interp, const char *name) {
  Tcl_CallFrame frame, *framePtr = &frame;

  nonnull_assert(class != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(name != NULL);

  /*
   * Ensure that the namespace is newly created during CleanupInitClass. Kill
   * it if it exists already.  TODO: Nothing here kills an existing namespace,
   * does it?
   */
  if (Tcl_PushCallFrame(interp, (Tcl_CallFrame *)framePtr,
                        RUNTIME_STATE(interp)->NsfClassesNS, 0) == TCL_OK) {
    Tcl_Namespace *nsPtr;

    nsPtr = NSGetFreshNamespace(interp, &class->object, name);
    Tcl_PopCallFrame(interp);
    CleanupInitClass(interp, class, nsPtr, NSF_FALSE, NSF_FALSE);
  }

  return;
}


/*
 *----------------------------------------------------------------------
 * PrimitiveCCreate --
 *
 *    Allocates memory for a class, initializes the class-specific data
 *    structure, e.g. class namespace, and calls PrimitiveOCreate() for the
 *    object-specific initialization.
 *
 * Results:
 *    An NsfClass*.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static NsfClass *PrimitiveCCreate(
    Tcl_Interp *interp, Tcl_Obj *nameObj,
    Tcl_Namespace *parentNsPtr, NsfClass *metaClass
) nonnull(1) nonnull(2) returns_nonnull;

static NsfClass *
PrimitiveCCreate(
    Tcl_Interp *interp, Tcl_Obj *nameObj,
    Tcl_Namespace *parentNsPtr, NsfClass *metaClass
) {
  Tcl_Namespace *nsPtr;
  const char    *nameString;
  NsfObject     *object;
  NsfClass      *class;

  nonnull_assert(interp != NULL);
  nonnull_assert(nameObj != NULL);

  class = (NsfClass *)ckalloc((int)sizeof(NsfClass));
  nameString = ObjStr(nameObj);
  object = (NsfObject *)class;

#if defined(NSFOBJ_TRACE)
  fprintf(stderr, "CKALLOC Class %p %s\n", class, nameString);
#endif

  memset(class, 0, sizeof(NsfClass));
  MEM_COUNT_ALLOC("NsfObject/NsfClass", class);

  /*
   * Obtain the object system from the metaclass.
   */
  if (metaClass != NULL) {
    class->osPtr = metaClass->osPtr;
  }

  assert(isAbsolutePath(nameString));
  /*
    fprintf(stderr, "Class alloc %p '%s'\n", cl, nameString);
  */
  nsPtr = NSCheckNamespace(interp, nameString, parentNsPtr);
  if (nsPtr != NULL) {
    NSNamespacePreserve(nsPtr);
  }
#if defined(NRE)
  object->id = Tcl_NRCreateCommand(interp, nameString,
                                   NsfObjDispatch,
                                   NsfObjDispatchNRE,
                                   class, TclDeletesObject);
#else
  object->id = Tcl_CreateObjCommand(interp, nameString, NsfObjDispatch,
                                    class, TclDeletesObject);
#endif
  PrimitiveOInit(object, interp, nameString, nsPtr, metaClass);

  if (nsPtr != NULL) {
    NSNamespaceRelease(nsPtr);
  }
  object->cmdName = nameObj;

  INCR_REF_COUNT(object->cmdName);
  PrimitiveCInit(class, interp, nameString+2);

  ObjTrace("PrimitiveCCreate", object);
  return class;
}


/*
 *----------------------------------------------------------------------
 * ChangeClass --
 *
 *    Changes the class of a Next Scripting object, ensuring that an object is
 *    not changed into a class or vice versa, and updates the instance
 *    relation. Changing metaclass to metaclass, or class to class, or object
 *    to object is fine, but upgrading/downgrading is not allowed.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static int ChangeClass(Tcl_Interp *interp, NsfObject *object, NsfClass *class)
  nonnull(1) nonnull(2) nonnull(3);

NSF_INLINE static int
ChangeClass(Tcl_Interp *interp, NsfObject *object, NsfClass *class) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(class != NULL);

  NsfInstanceMethodEpochIncr("ChangeClass");

  /*fprintf(stderr, "changing %s to class %s ismeta %d\n",
          ObjectName(object), ClassName(class),
          IsMetaClass(interp, cl, NSF_TRUE));*/

  if (class != object->cl) {
    if (IsMetaClass(interp, class, NSF_TRUE)) {
      /*
       * A class may not be upgraded to a metaclass, i.e. an object may not
       * become a class. Allowing this would require to reallocating the base
       * structures.
       */
      if (!IsMetaClass(interp, object->cl, NSF_TRUE)) {
        return NsfPrintError(interp, "cannot turn object into a class");
      }
    } else {
      /*
       * The target class is not a metaclass.
       */
      /*fprintf(stderr, "target class %s not a metaclass, am i a class %d\n",
        ClassName(class), NsfObjectIsClass(object) );*/

      if (NsfObjectIsClass(object)) {
        return NsfPrintError(interp, "cannot turn class into an object ");
      }
    }
    RemoveInstance(object, object->cl);
    AddInstance(object, class);

    MixinComputeDefined(interp, object);
    FilterComputeDefined(interp, object);
  }
  return TCL_OK;
}


/*
 *----------------------------------------------------------------------
 * DoObjInitialization --
 *
 *    Calls "configure" and "init" if not called already from configure, making
 *    sure that the called methods do not change given result function.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */
static int DoObjInitialization(Tcl_Interp *interp, NsfObject *object, int objc, Tcl_Obj *const objv[])
  nonnull(1) nonnull(2) nonnull(4);

static int
DoObjInitialization(Tcl_Interp *interp, NsfObject *object, int objc, Tcl_Obj *const objv[]) {
  Tcl_Obj *methodObj, *savedObjResult;
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(objv != NULL);
  assert(objc >= 0);

#if 0
  { int i;
    fprintf(stderr, "DoObjInitialization objc %d: ", objc);
    for(i = 0; i < objc; i++) {fprintf(stderr, " [%d]=%s,", i, ObjStr(objv[i]));}
    fprintf(stderr, "\n");
  }
#endif

  /*
   * Save the current result to return it on success.
   */
  savedObjResult = Tcl_GetObjResult(interp);
  INCR_REF_COUNT(savedObjResult);

  /*
   * clear INIT_CALLED flag
   */
  object->flags &= ~NSF_INIT_CALLED;
  /*
   * Ensure that the object survives initialization even if the cmd/initcmd
   * destroys it.
   */
  NsfObjectRefCountIncr(object);

  /*
   * Call configure method.
   */
  if (CallDirectly(interp, object, NSF_o_configure_idx, &methodObj)) {
    NSF_PROFILE_TIME_DATA;
    if (methodObj == NULL) {
      methodObj = NsfGlobalObjs[NSF_CONFIGURE];
    }
    assert(methodObj != NULL);
    /*
     * The methodObj is just used for error reporting.
     */
    NSF_PROFILE_CALL(interp, object, ObjStr(methodObj));
    result = NsfOConfigureMethod(interp, object, objc, objv, methodObj);
    NSF_PROFILE_EXIT(interp, object, ObjStr(methodObj));
  } else {
    result = CallMethod(object, interp, methodObj, objc+2, objv, NSF_CSC_IMMEDIATE);
  }

  if (likely(result == TCL_OK)) {
    /*
     * Call the constructor if needed.
     */
    if ((object->flags & (NSF_INIT_CALLED|NSF_DESTROY_CALLED)) == 0u) {
      result = DispatchInitMethod(interp, object, 0, NULL, 0u);
    }

    if (likely(result == TCL_OK)) {
      Tcl_SetObjResult(interp, savedObjResult);
    }
  } else {
    /*
     * Configure failed.  It might have left the object in a bogus state.
     * Delete the half-baked object avoid strange errors.
     */
    Tcl_Obj *errObj;

    /*
     *  Preserve the outer error message.  Calls triggered by
     *  DispatchDestroyMethod() can cause the interp result to be reset.
     */

    errObj = Tcl_GetObjResult(interp);
    INCR_REF_COUNT(errObj);

    DispatchDestroyMethod(interp, (NsfObject *)object, 0u);

    Tcl_SetObjResult(interp, errObj);
    DECR_REF_COUNT(errObj);
  }

  NsfCleanupObject(object, "obj init");
  DECR_REF_COUNT(savedObjResult);
  return result;
}

/*
 *----------------------------------------------------------------------
 * IsRootMetaClass --
 *
 *    True if the class has the root metaclass flag set.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static bool
IsRootMetaClass(const NsfClass *class) {

  nonnull_assert(class != NULL);

  return ((class->object.flags & NSF_IS_ROOT_META_CLASS) != 0u);
}

/*
 *----------------------------------------------------------------------
 * IsBaseClass --
 *
 *    Returns true if the object is a base class.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static bool
IsBaseClass(const NsfObject *object) {

  nonnull_assert(object != NULL);

  return ((object->flags & (NSF_IS_ROOT_CLASS|NSF_IS_ROOT_META_CLASS)) != 0u);
}

/*
 *----------------------------------------------------------------------
 * IsRootClass --
 *
 *    True if the object is a root class.
 *
 * Results:
 *    Boolean.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static bool
IsRootClass(const NsfClass *class) {

  nonnull_assert(class != NULL);

  return ((class->object.flags & (NSF_IS_ROOT_CLASS)) != 0u);
}


/*
 *----------------------------------------------------------------------
 * IsMetaClass --
 *
 *    True if the object is a metaclass, optionally checking mixins as well.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static bool
IsMetaClass(Tcl_Interp *interp, NsfClass *class, bool withMixins) {
  NsfClasses *pl;
  bool        result = NSF_FALSE;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);

  /*
   * Is the class the most general metaclass?
   */
  if (IsRootMetaClass(class)) {
    return NSF_TRUE;
  }

  /*
   * Is the class a subclass of a metaclass?
   */
  for (pl = PrecedenceOrder(class); pl != NULL; pl = pl->nextPtr) {
    if (IsRootMetaClass(pl->cl)) {
      return NSF_TRUE;
    }
  }

  if (withMixins) {
    NsfClasses *checkList = NULL, *mixinClasses = NULL, *mc;

    /*
     * Has the class metaclass been mixed in?
     */
    NsfClassListAddPerClassMixins(interp, class, &mixinClasses, &checkList);

    for (mc = mixinClasses; mc != NULL; mc = mc->nextPtr) {
      if (IsMetaClass(interp, mc->cl, NSF_FALSE)) {
        result = NSF_TRUE;
        break;
      }
    }
    if (mixinClasses != NULL) {
      NsfClassListFree(mixinClasses);
    }
    if (checkList != NULL) {
      NsfClassListFree(checkList);
    }
    /*fprintf(stderr, "has MC returns %d, mixinClasses = %p\n",
      result, mixinClasses);*/
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * IsSubType --
 *
 *    True if a class is a subclass of another class.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static bool
IsSubType(NsfClass *subClass, const NsfClass *class) {
  bool result;

  nonnull_assert(subClass != NULL);
  nonnull_assert(class != NULL);

  if (class != subClass) {
    result = (NsfClassListFind(PrecedenceOrder(subClass), class) != NULL);
  } else {
    result = NSF_TRUE;
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * HasMixin --
 *
 *    True if the given class has been mixed into the given object.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static bool HasMixin(Tcl_Interp *interp, NsfObject *object, NsfClass *class)
  nonnull(1) nonnull(2) nonnull(3);

static bool
HasMixin(Tcl_Interp *interp, NsfObject *object, NsfClass *class) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(class != NULL);

  if ((object->flags & NSF_MIXIN_ORDER_VALID) == 0u) {
    MixinComputeDefined(interp, object);
  }
  if ((object->flags & NSF_MIXIN_ORDER_DEFINED_AND_VALID) != 0u) {
    NsfCmdList *ml;

    for (ml = object->mixinOrder; ml != NULL; ml = ml->nextPtr) {
      NsfClass *mixinClass = NsfGetClassFromCmdPtr(ml->cmdPtr);

      if (mixinClass == class) {
        return NSF_TRUE;
      }
    }
  }
  return NSF_FALSE;
}

/*
 *----------------------------------------------------------------------
 * ImportInstVarIntoCurrentScope --
 *
 *    Imports an instance variable into the current variable scope,
 *    e.g. function scope.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int ImportInstVarIntoCurrentScope(Tcl_Interp *interp, const char *cmdName, NsfObject *object,
                                         Tcl_Obj *varName, Tcl_Obj *newName)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static int
ImportInstVarIntoCurrentScope(Tcl_Interp *interp, const char *cmdName, NsfObject *object,
                              Tcl_Obj *varName, Tcl_Obj *newName) {
  Var           *otherPtr = NULL, *arrayPtr;
  unsigned int   flogs = TCL_LEAVE_ERR_MSG;
  Tcl_CallFrame *varFramePtr;
  CallFrame      frame, *framePtr = &frame;
  const char    *varNameString;

  nonnull_assert(interp != NULL);
  nonnull_assert(cmdName != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(varName != NULL);

  if (unlikely(CheckVarName(interp, ObjStr(varName)) != TCL_OK)) {
    return TCL_ERROR;
  }

  Nsf_PushFrameObj(interp, object, framePtr);
  if (object->nsPtr != NULL) {
    flogs = flogs|TCL_NAMESPACE_ONLY;
  }

  otherPtr = TclObjLookupVar(interp, varName, NULL, (int)flogs, "define",
                             /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
  Nsf_PopFrameObj(interp, framePtr);

  if (unlikely(otherPtr == NULL)) {
    return NsfPrintError(interp, "can't import variable %s into method scope: "
                         "can't find variable on %s",
                         ObjStr(varName), ObjectName_(object));
  }

  /*
   * if newName == NULL -> there is no alias.  Use varName as the name.
   */
  if (newName == NULL) {
    /*
     * A variable linked into namespace cannot be an element in an array.
     * see Tcl_VariableObjCmd.
     */
    if (arrayPtr != NULL) {
      return NsfPrintError(interp, "can't make instance variable %s on %s: "
                           "Variable cannot be an element in an array; use e.g. an alias.",
                           ObjStr(varName), ObjectName_(object));
    }

    newName = varName;
  }
  varNameString = ObjStr(newName);
  varFramePtr = (Tcl_CallFrame *)Tcl_Interp_varFramePtr(interp);

  /*
   * If in a Tcl procedure, create a local variable linked to the new namespace
   * variable "varName".
   */
  if (varFramePtr != NULL && (Tcl_CallFrame_isProcCallFrame(varFramePtr) & FRAME_IS_PROC)) {
    Var *varPtr = (Var *)CompiledLocalsLookup((CallFrame *)varFramePtr, varNameString);
    int new = 0;

    if (varPtr == NULL) {
      /*
       * Look in the frame's local variable hash table.
       */
      TclVarHashTable *varTablePtr = Tcl_CallFrame_varTablePtr(varFramePtr);

      if (varTablePtr == NULL) {
        /*
	 * The variable table does not exist. This seems to be the first access
	 * to a variable on this frame. Create and initialize the variable hash
	 * table and update the object.
         */
        /*fprintf(stderr, "+++ create varTable in ImportInstVarIntoCurrentScope\n");*/
        Tcl_CallFrame_varTablePtr(varFramePtr) = varTablePtr = VarHashTableCreate();
      }
      varPtr = VarHashCreateVar(varTablePtr, newName, &new);
    }

    /*
     * If defining an alias, i.e. newName != varName, be sure that
     * the target does not exist already.
     */
    if (new == 0) {
      /*fprintf(stderr, "GetIntoScope create alias\n");*/
      if (unlikely(varPtr == otherPtr)) {
        return NsfPrintError(interp, "can't instvar to variable itself");
      }
      if (TclIsVarLink(varPtr)) {
        /*
         * Try to make the same instvar again. This is ok.
         */
        Var *linkPtr = TclVarValue(Var, varPtr, linkPtr);
        if (linkPtr == otherPtr) {
          return TCL_OK;
        }

        /*fprintf(stderr, "linkvar flags=%x\n", linkPtr->flags);
          Tcl_Panic("new linkvar %s... When does this happen?", ObjStr(newName), NULL);*/

        /*
         * A variable by the same name is already imported from a different
         * object. Delete it.
         */
        VarHashRefCount(linkPtr)--;
        if (TclIsVarUndefined(linkPtr)) {
          TclCleanupVar(linkPtr, (Var *) NULL);
        }

      } else if (unlikely(TclIsVarUndefined(varPtr) == 0)) {
        return NsfPrintError(interp, "varName '%s' exists already", varNameString);
      } else if (unlikely(TclIsVarTraced(varPtr) != 0)) {
        return NsfPrintError(interp, "varName '%s' has traces: can't use for instvar", varNameString);
      }
    }

    TclSetVarLink(varPtr);
    TclClearVarUndefined(varPtr);
    varPtr->value.linkPtr = otherPtr;
    VarHashRefCount(otherPtr)++;

    /* fprintf(stderr, "defining an alias var='%s' in obj %s fwd %d flags %x isLink %d isTraced %d isUndefined %d\n",
            ObjStr(newName), ObjectName(object),
            0,
            varPtr->flags,
            TclIsVarLink(varPtr), TclIsVarTraced(varPtr), TclIsVarUndefined(varPtr));
    */
  } else {
    return NsfPrintError(interp, "%s cannot import variable '%s' into method scope; "
                         "not called from a method frame", cmdName, varNameString);
  }
  return TCL_OK;
}



/*
 *----------------------------------------------------------------------
 * SetInstVar --
 *
 *    Assign the given value to an instance variable having the given name.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static int
SetInstVar(Tcl_Interp *interp, NsfObject *object, Tcl_Obj *nameObj, Tcl_Obj *valueObj, unsigned int flags) {
  CallFrame frame, *framePtr = &frame;
  Tcl_Obj *resultObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(nameObj != NULL);

  Nsf_PushFrameObj(interp, object, framePtr);

  if ((flags & NSF_VAR_TRIGGER_TRACE) != 0u) {
    int tclVarFlags;
    /*
     * Use the Tcl_Obj interface so that any traces are executed.
     */

    tclVarFlags = (object->nsPtr != NULL) ? TCL_LEAVE_ERR_MSG|TCL_NAMESPACE_ONLY : TCL_LEAVE_ERR_MSG;
    if (likely(valueObj == NULL)) {
      resultObj = Tcl_ObjGetVar2(interp, nameObj, NULL, tclVarFlags);
    } else {
      resultObj = Tcl_ObjSetVar2(interp, nameObj, NULL, valueObj, tclVarFlags);
    }
  } else {
    /*
     * Use TclLookupVar, which is lower-level and does not execute traces.
     */
    Var *arrayPtr, *varPtr;

    if (likely(valueObj == NULL)) {

      varPtr = TclLookupVar(interp, ObjStr(nameObj), NULL, TCL_LEAVE_ERR_MSG, "access",
                            /*createPart1*/ 0, /*createPart2*/ 0, &arrayPtr);
      if (likely(varPtr != NULL)) {
        resultObj = varPtr->value.objPtr;
      } else {
        resultObj = NULL;
      }

    } else {
      Tcl_Obj *oldValuePtr;

      varPtr = TclLookupVar(interp, ObjStr(nameObj), NULL, TCL_LEAVE_ERR_MSG, "access",
                            /*createPart1*/ 1, /*createPart2*/ 0, &arrayPtr);
      oldValuePtr = varPtr->value.objPtr;
      INCR_REF_COUNT2("SetInstVar", valueObj);
      varPtr->value.objPtr = valueObj;
      if (oldValuePtr != NULL) {
        DECR_REF_COUNT2("SetInstVar", oldValuePtr);
      }
      resultObj = valueObj;
    }
  }
  Nsf_PopFrameObj(interp, framePtr);

  if (likely(resultObj != NULL)) {
    Tcl_SetObjResult(interp, resultObj);
    return TCL_OK;
  }

  return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 * SetInstArray --
 *
 *    Assigns the given value to the named array of the given object, like
 *    "array set" does.  If the value is NULL, retrieves the current value
 *    instead, i.e. "array get".
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static int SetInstArray(Tcl_Interp *interp, NsfObject *object, Tcl_Obj *arrayNameObj, Tcl_Obj *valueObj)
  nonnull(1) nonnull(2) nonnull(3);

static int
SetInstArray(Tcl_Interp *interp, NsfObject *object, Tcl_Obj *arrayNameObj, Tcl_Obj *valueObj) {
  CallFrame frame, *framePtr = &frame;
  int result;
  Tcl_Obj *ov[4];

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(arrayNameObj != NULL);

  Nsf_PushFrameObj(interp, object, framePtr);

  ov[0] = NsfGlobalObjs[NSF_ARRAY];
  ov[2] = arrayNameObj;

  INCR_REF_COUNT(arrayNameObj);
  if (valueObj == NULL) {
    /*
     * "array get".
     */
    ov[1] = NsfGlobalObjs[NSF_GET];
    result = Tcl_EvalObjv(interp, 3, ov, 0);
  } else {
    /*
     * "array set".
     */
    ov[1] = NsfGlobalObjs[NSF_SET];
    ov[3] = valueObj;
    INCR_REF_COUNT(valueObj);
    result = Tcl_EvalObjv(interp, 4, ov, 0);
    DECR_REF_COUNT(valueObj);
  }
  DECR_REF_COUNT(arrayNameObj);
  Nsf_PopFrameObj(interp, framePtr);

  return result;
}


/*
 *----------------------------------------------------------------------
 * UnsetInstVar --
 *
 *    Unsets the named variable of the given object.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static int
UnsetInstVar(Tcl_Interp *interp, int withNocomplain, NsfObject *object, const char *name) {
  CallFrame frame, *framePtr = &frame;
  unsigned int flags;
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(name != NULL);

  flags = (withNocomplain != 0) ? 0 : TCL_LEAVE_ERR_MSG;
  if (object->nsPtr != NULL) {
    flags |= TCL_NAMESPACE_ONLY;
  }

  Nsf_PushFrameObj(interp, object, framePtr);
  result = Tcl_UnsetVar2(interp, name, NULL, (int)flags);
  Nsf_PopFrameObj(interp, framePtr);

  return (withNocomplain != 0) ? TCL_OK : result;
}

/*
 *----------------------------------------------------------------------
 * NsfSetterMethod --
 *
 *    This Tcl_ObjCmdProc is called when a setter method is invoked. A setter
 *    method accesses/modifies an identically-named variable of the object.
 *    Called without arguments, it returns the value of the variable. Called
 *    with one argument, it assigns that argument to the variable.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static int NsfSetterMethod(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])
  nonnull(1) nonnull(2) nonnull(4);

static int
NsfSetterMethod(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  SetterCmdClientData *cd;
  NsfObject           *object;
  int                  result;

  nonnull_assert(clientData != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);

  cd = (SetterCmdClientData *)clientData;
  object = cd->object;

  if (objc > 2) {
    Tcl_Obj *pathObj = NsfMethodNamePath(interp,
                                         CallStackGetTclFrame(interp, NULL, 1),
                                         NsfMethodName(objv[0]));
    INCR_REF_COUNT(pathObj);
    result = NsfObjWrongArgs(interp, "wrong # args", object->cmdName,
                             pathObj, "?value?");
    DECR_REF_COUNT(pathObj);
  } else if (object == NULL) {
    result = NsfDispatchClientDataError(interp, clientData, "object", ObjStr(objv[0]));

  } else {
    Tcl_Obj    *nameObj;
    const char *nameString = ObjStr(objv[0]);

    /*
     * When the setter method is called with a leading colon, pass a plain
     * object to SetInstVar() to avoid shimmering with tclCmds.
     */
    if (FOR_COLON_RESOLVER(nameString)) {
      nameString ++;
      nameObj = Tcl_NewStringObj(nameString, -1);
      INCR_REF_COUNT(nameObj);
    } else {
      nameObj = objv[0];
    }

    if (cd->paramsPtr != NULL && objc == 2) {
      Tcl_Obj   *outObjPtr;
      unsigned   flags = 0u;
      ClientData checkedData;

      result = ArgumentCheck(interp, objv[1], cd->paramsPtr,
                             RUNTIME_STATE(interp)->doCheckArguments,
                             &flags, &checkedData, &outObjPtr);

      if (likely(result == TCL_OK)) {
        result = SetInstVar(interp, object, nameObj, outObjPtr, NSF_VAR_TRIGGER_TRACE);
      }

      if ((flags & NSF_PC_MUST_DECR) != 0u) {
        DECR_REF_COUNT2("valueObj", outObjPtr);
      }
    } else {
      result = SetInstVar(interp, object, nameObj, objc == 2 ? objv[1] : NULL, NSF_VAR_TRIGGER_TRACE);
    }
    if (nameObj != objv[0]) {
      DECR_REF_COUNT(nameObj);
    }
  }
  return result;
}


/*
 *----------------------------------------------------------------------
 * NsfForwardPrintError --
 *
 *    Prints either an error message directly or calls the forwarder-specific
 *    callback method in tcd->onerror. Background: ForwardArg() is called at
 *    dispatch to substitute the argument list. To catch such errors it would
 *    be necessary to wrap every possible usage of a forwarder in a catch.
 *    Instead, the callback function gives a sensible error message appropriate
 *    for each context.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */
static int
NsfForwardPrintError(Tcl_Interp *interp, ForwardCmdClientData *tcd,
                     int objc, Tcl_Obj *const objv[],
                     const char *fmt, ...)
  nonnull(1) nonnull(2) nonnull(5) NSF_attribute_format((printf,5,6));

static int
NsfForwardPrintError(Tcl_Interp *interp, ForwardCmdClientData *tcd,
                     int objc, Tcl_Obj *const objv[],
                     const char *fmt, ...) {
  Tcl_DString ds;
  va_list ap;
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(tcd != NULL);
  nonnull_assert(fmt != NULL);

  Tcl_DStringInit(&ds);

  va_start(ap, fmt);
  NsfDStringVPrintf(&ds, fmt, ap);
  va_end(ap);

  fprintf(stderr, "==== DEBUG AppVeyor: error msg<<%s>> (len %d)\n", ds.string, ds.length);

  if (tcd->onerror != NULL) {
    Tcl_Obj *script = Tcl_DuplicateObj(tcd->onerror);
    Tcl_Obj *cmd;

    if (tcd->object != NULL) {
      cmd = Tcl_DuplicateObj(tcd->object->cmdName);
      if (objc > 0) {
        Tcl_Obj *methodObjPath = NsfMethodNamePath(interp,
                                                   CallStackGetTclFrame(interp, NULL, 1),
                                                   MethodName(objv[0]));
        INCR_REF_COUNT(methodObjPath);
        Tcl_ListObjAppendList(interp, cmd, methodObjPath);
        DECR_REF_COUNT(methodObjPath);

        if (objc > 1) {
          Tcl_ListObjAppendElement(interp, cmd,  Tcl_NewListObj(objc-1, objv+1));
        }
      }
    } else {
      cmd = Tcl_NewListObj(objc, objv);
    }

    Tcl_ListObjAppendElement(interp, script,  cmd);
    Tcl_ListObjAppendElement(interp, script,
                             Tcl_NewStringObj(Tcl_DStringValue(&ds),
                                              Tcl_DStringLength(&ds)));
    INCR_REF_COUNT(script);
    result = Tcl_EvalObjEx(interp, script, TCL_EVAL_DIRECT);
    DECR_REF_COUNT(script);
  } else {
    result = NsfPrintError(interp, "%s", Tcl_DStringValue(&ds));
  }

  Tcl_DStringFree(&ds);
  return result;
}

/*
 *----------------------------------------------------------------------
 * ForwardArg --
 *
 *    Helps NsfForwardMethod() by processing a single entry (ForwardArgObj) of
 *    the forward spec. Essentially, it performs the percent substitution of
 *    the forward spec.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Updates the given output arguments.
 *
 *----------------------------------------------------------------------
 */
static int ForwardArg(
    Tcl_Interp *interp, int objc, Tcl_Obj *const objv[],
    Tcl_Obj *forwardArgObj, ForwardCmdClientData *tcd, Tcl_Obj **out,
    Tcl_Obj **freeListObjPtr, int *inputArg, long *mapvalue,
    int firstPosArg, int *outputincr
) nonnull(1) nonnull(3) nonnull(4) nonnull(5) nonnull(6) nonnull(7) nonnull(8) nonnull(9) nonnull(11);

static int
ForwardArg(
    Tcl_Interp *interp,
    int objc, Tcl_Obj *const objv[],
    Tcl_Obj *forwardArgObj,
    ForwardCmdClientData *tcd,
    Tcl_Obj **out,
    Tcl_Obj **freeListObjPtr,
    int *inputArg,
    long *mapvalue,
    int firstPosArg,
    int *outputincr
) {
  const char *ForwardArgString, *p;
  int         totalargs, result = TCL_OK;
  char        c;

  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);
  nonnull_assert(forwardArgObj != NULL);
  nonnull_assert(tcd != NULL);
  nonnull_assert(out != NULL);
  nonnull_assert(freeListObjPtr != NULL);
  nonnull_assert(inputArg != NULL);
  nonnull_assert(mapvalue != NULL);
  nonnull_assert(outputincr != NULL);

  assert(objc >= 1);

  totalargs = objc + tcd->nr_args - 1;
  /*
   * By default each ForwardArgString in the processed list corresponds to
   * exactly one ForwardArgString in the computed final list.
   */
  *outputincr = 1;
  ForwardArgString = ObjStr(forwardArgObj);
  p = ForwardArgString;

  /* fprintf(stderr, "ForwardArg: processing '%s'\n", ForwardArgString);*/

  c = *ForwardArgString;
  if (c == '%' && *(ForwardArgString+1) == '@') {
    char *remainder = NULL;
    long  pos;

    ForwardArgString += 2;
    pos = strtol(ForwardArgString, &remainder, 0);
    if (ForwardArgString == remainder && *ForwardArgString == 'e'
        && !strncmp(ForwardArgString, "end", 3)) {
      pos = -1;
      remainder += 3;
    } else if (pos < 0) {
      pos --;
    }
    if (ForwardArgString == remainder || labs(pos) > totalargs) {
      return NsfForwardPrintError(interp, tcd, objc, objv,
                                  "forward: invalid index specified in argument %s",
                                  ObjStr(forwardArgObj));
    }
    if (!remainder || *remainder != ' ') {
      return NsfForwardPrintError(interp, tcd, objc, objv,
                                  "forward: invalid syntax in '%s'; use: %%@<pos> <cmd>",
                                  ObjStr(forwardArgObj));
    }

    ForwardArgString = remainder + 1;
    /*
     * If addressing from the end, reduce further to distinguish from
     * -1 (void)
     */
    if (pos < 0) {
      pos--;
    }
    /*fprintf(stderr, "remainder = '%s' pos = %ld\n", remainder, pos);*/
    *mapvalue = pos;
    c = *ForwardArgString;
  }

  if (c == '%') {
    Tcl_Obj    *listObj = NULL, **listElements = NULL;
    int         nrArgs = objc-1, nrPosArgs = objc - firstPosArg, nrElements = 0;
    char        c1, *firstActualArgument = nrArgs > 0 ? ObjStr(objv[1]) : NULL;
    const char *c1Ptr;

    assert(nrPosArgs >= 0);
    assert(nrArgs >= 0);

    c = *++ForwardArgString;
    c1Ptr = ForwardArgString + 1;
    c1 = *c1Ptr;

    if (c == 's' && !strcmp(ForwardArgString, "self")) {
      *out = tcd->object->cmdName;
    } else if ((c == 'p' && !strcmp(ForwardArgString, "proc"))
               || (c == 'm' && !strcmp(ForwardArgString, "method"))
               ) {
      const char *methodName = ObjStr(objv[0]);

      /*
       * If dispatching a method via ".", "." should not be visible in the
       * %proc, e.g. for the interceptor slots (such as mixin, ...)
       */
      if (FOR_COLON_RESOLVER(methodName)) {
        *out = Tcl_NewStringObj(methodName + 1, -1);
      } else {
        *out = objv[0];
      }
      AddObjToTclList(interp, freeListObjPtr, *out);
    } else if (c == '1' && (c1 == '\0' || NsfHasTclSpace(c1Ptr))) {

      if (c1 != '\0') {
        if (unlikely(Tcl_ListObjIndex(interp, forwardArgObj, 1, &listObj) != TCL_OK)) {
          return NsfForwardPrintError(interp, tcd, objc, objv,
                                      "forward: %%1 must be followed by a valid list, given: '%s'",
                                      ObjStr(forwardArgObj));
        }
        if (unlikely(Tcl_ListObjGetElements(interp, listObj, &nrElements, &listElements) != TCL_OK)) {
          return NsfForwardPrintError(interp, tcd, objc, objv,
                                      "forward: %%1 contains invalid list '%s'",
                                      ObjStr(listObj));
        }
      } else if (unlikely(tcd->subcommands != NULL)) {
        /*
         * Deprecated. Kept for backwards compatibility.
         */
        if (Tcl_ListObjGetElements(interp, tcd->subcommands, &nrElements, &listElements) != TCL_OK) {
          return NsfForwardPrintError(interp, tcd, objc, objv,
                                      "forward: %%1 contains invalid list '%s'",
                                      ObjStr(tcd->subcommands));
        }
      } else {
        assert(nrElements <= nrPosArgs);
      }
      /*fprintf(stderr, "nrElements=%d, nra=%d firstPos %d objc %d\n",
        nrElements, nrArgs, firstPosArg, objc);*/

      if (nrElements > nrPosArgs) {
        /*
         * Insert default subcommand depending on number of arguments.
         */
        assert(listElements != NULL);
        /*fprintf(stderr, "inserting listElements[%d] '%s'\n", nrPosArgs,
          ObjStr(listElements[nrPosArgs]));*/
        *out = listElements[nrPosArgs];
      } else if (objc <= 1) {

        result = NsfForwardPrintError(interp, tcd, objc, objv,
                                      "%%1 requires argument; should be \"%s arg ...\"",
                                      ObjStr(objv[0]));
      } else {
        /*fprintf(stderr, "copying %%1: '%s'\n", ObjStr(objv[firstPosArg]));*/
        *out = objv[firstPosArg];
        *inputArg = firstPosArg+1;
      }
    } else if (c == '-') {
      const char *firstElementString;
      int         insertRequired;
      bool        done = NSF_FALSE;

      /*fprintf(stderr, "process flag '%s'\n", firstActualArgument);*/
      if (Tcl_ListObjGetElements(interp, forwardArgObj, &nrElements, &listElements) != TCL_OK) {
        return NsfForwardPrintError(interp, tcd, objc, objv,
                                    "forward: '%s' is not a valid list",
                                    ForwardArgString);
      }
      if (nrElements < 1 || nrElements > 2) {
        return NsfForwardPrintError(interp, tcd, objc, objv,
                                    "forward: '%s': must contain 1 or 2 arguments",
                                    ForwardArgString);
      }
      firstElementString = ObjStr(listElements[0]);
      firstElementString++; /* skip the dash */

      if (firstActualArgument && *firstActualArgument == '-') {
        int i;

        /*fprintf(stderr, "we have a flag in first argument '%s'\n", firstActualArgument);*/
        for (i = 1; i < firstPosArg; i++) {
          if (strcmp(firstElementString, ObjStr(objv[i])) == 0) {
            /*fprintf(stderr, "We have a MATCH for '%s' oldInputArg %d\n", ForwardArgString, *inputArg);*/
            *out = objv[i];
            /* %1 starts at a different place. Proceed if necessary to firstPosArg */
            if (*inputArg < firstPosArg) {
              *inputArg = firstPosArg;
            }
            done = NSF_TRUE;
            break;
          }
        }
      }

      if (! done) {
        /*
         * A flag in the actual arguments does not match.  Proceed to the
         * actual arguments without dashes.
         */
        if (*inputArg < firstPosArg) {
          *inputArg = firstPosArg;
        }
        /*
         * On request, output the argument even when not given in the argument
         * list.
         */
        if (nrElements == 2
            && Tcl_GetIntFromObj(interp, listElements[1], &insertRequired) == TCL_OK
            && insertRequired) {
          /*
           * No match, but the flag must be inserted.
           */
          /*fprintf(stderr, "no match, but insert of %s required\n", firstElementString);*/
          *out = Tcl_NewStringObj(firstElementString, -1);
          *outputincr = 1;

          AddObjToTclList(interp, freeListObjPtr, *out);
        } else {
          /*
           * No match, and no need to insert the flag.  Skip the forwarder
           * option and output nothing.
           */
          /*fprintf(stderr, "no match, nrElements %d insert req %d\n", nrElements, insertRequired);*/
          *outputincr = 0;
        }
      }

    } else if (c == 'a' && !strncmp(ForwardArgString, "argcl", 4)) {

      if (Tcl_ListObjIndex(interp, forwardArgObj, 1, &listObj) != TCL_OK) {
        result = NsfForwardPrintError(interp, tcd, objc, objv,
                                      "forward: %%argclindex must by a valid list, given: '%s'",
                                      ForwardArgString);

      } else if (Tcl_ListObjGetElements(interp, listObj, &nrElements, &listElements) != TCL_OK) {
        result = NsfForwardPrintError(interp, tcd, objc, objv,
                                      "forward: %%argclindex contains invalid list '%s'",
                                      ObjStr(listObj));

      } else if (nrArgs >= nrElements) {
        result = NsfForwardPrintError(interp, tcd, objc, objv,
                                      "forward: not enough elements in specified list of ARGC argument %s",
                                      ForwardArgString);
      } else {
        *out = listElements[nrArgs];
      }
    } else if (c == '%') {
      Tcl_Obj *newarg = Tcl_NewStringObj(ForwardArgString, -1);

      *out = newarg;
      AddObjToTclList(interp, freeListObjPtr, *out);

    } else {
      /*
       * Evaluate the given command.
       */
      /*fprintf(stderr, "evaluating '%s'\n", ForwardArgString);*/
      result = Tcl_EvalEx(interp, ForwardArgString, -1, 0);
      if (likely(result == TCL_OK)) {
        *out = Tcl_DuplicateObj(Tcl_GetObjResult(interp));
        AddObjToTclList(interp, freeListObjPtr, *out);
        /*fprintf(stderr, "result = '%s'\n", ObjStr(*out));*/
      }
    }
  } else {
    if (likely(p == ForwardArgString)) {
      *out = forwardArgObj;
    } else {
      Tcl_Obj *newarg = Tcl_NewStringObj(ForwardArgString, -1);

      *out = newarg;
      AddObjToTclList(interp, freeListObjPtr, *out);
    }
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * CallForwarder --
 *
 *    Invokes the method to which the forwarder points, passing it the
 *    already-transformed arguments, and performing error handling on the
 *    result.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */

static int CallForwarder(ForwardCmdClientData *tcd, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])
  nonnull(1) nonnull(2) nonnull(4);

static int
CallForwarder(ForwardCmdClientData *tcd, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  int        result;
  NsfObject *object;
  CallFrame  frame, *framePtr = &frame;

  nonnull_assert(tcd != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);

  object = tcd->object;
  tcd->object = NULL;

  if (unlikely(tcd->verbose)) {
    Tcl_Obj *cmd = Tcl_NewListObj(objc, objv);

    NsfLog(interp, NSF_LOG_DEBUG, "forwarder calls '%s'",  ObjStr(cmd));
    DECR_REF_COUNT(cmd);
  }
  if (tcd->frame == FrameObjectIdx) {
    Nsf_PushFrameObj(interp, object, framePtr);
  }
  if (tcd->objProc != NULL) {
    /*fprintf(stderr, "CallForwarder Tcl_NRCallObjProc %p\n", tcd->clientData);*/
    result = Tcl_NRCallObjProc(interp, tcd->objProc, tcd->clientData, objc, objv);
  } else if (TclObjIsNsfObject(interp, tcd->cmdName, &object)) {
    /*fprintf(stderr, "CallForwarder NsfObjDispatch object %s, objc=%d\n",
      ObjStr(tcd->cmdName), objc);*/
    if (likely(objc > 1)) {
      result = ObjectDispatch(object, interp, objc, objv, NSF_CSC_IMMEDIATE);
    } else {
      result = DispatchDefaultMethod(interp, object, objv[0], NSF_CSC_IMMEDIATE);
    }
  } else {
    /*fprintf(stderr, "CallForwarder: no Nsf object %s [0] %s\n", ObjStr(tcd->cmdName), ObjStr(objv[0]));*/
    result = Tcl_EvalObjv(interp, objc, objv, 0);
  }

  if (tcd->frame == FrameObjectIdx) {
    Nsf_PopFrameObj(interp, framePtr);
  }

#if defined(NSF_FORWARD_WITH_ONERROR)
  if (unlikely(result == TCL_ERROR && tcd->onerror != NULL)) {
    Tcl_Obj *resultObj = Tcl_GetObjResult(interp);
    const char *errorMsg =  ObjStr(resultObj);

    INCR_REF_COUNT(resultObj);
    fprintf(stderr, "==== DEBUG AppVeyor: calling NsfForwardPrintError with <<%s>> (len %lu)\n",
            errorMsg, (unsigned long)strlen(errorMsg));
    result = NsfForwardPrintError(interp, tcd, objc, objv, "%s", errorMsg);
    DECR_REF_COUNT(resultObj);
  }
#endif

  return result;
}

/*
 *----------------------------------------------------------------------
 * NsfForwardMethod --
 *
 *    A Tcl_ObjCmdProc that is called when a forwarder is invoked.  Performs
 *    argument substitution through ForwardArg() and then calls the method
 *    to which the call was forwarded via CallForwarder().
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */

static int NsfForwardMethod(ClientData clientData, Tcl_Interp *interp,
                            int objc, Tcl_Obj *const objv[])
  nonnull(1) nonnull(2) nonnull(4);

static int
NsfForwardMethod(ClientData clientData, Tcl_Interp *interp,
                   int objc, Tcl_Obj *const objv[]) {
  ForwardCmdClientData *tcd = (ForwardCmdClientData *)clientData;
  int                   result, inputArg = 1;

  nonnull_assert(clientData != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);

  if (unlikely(!tcd || !tcd->object)) {
    return NsfDispatchClientDataError(interp, tcd, "object",
                                      objc > 0 ? ObjStr(objv[0]) : "forwarder");
  }

  /*
   * First handle two shortcuts for simple cases.
   */

  if (tcd->passthrough) {
    /*
     * This is set for early binding. The cmd is already
     * resolved and it is only necessary to tend to objscope.
     */
    return CallForwarder(tcd, interp, objc, objv);

  } else if (tcd->args == NULL && *(ObjStr(tcd->cmdName)) != '%') {
    /*
     * No args. Replace the method name with the given cmd name.
     */
    ALLOC_ON_STACK(Tcl_Obj*, objc, ov);
    /*fprintf(stderr, "+++ forwardMethod must subst oc=%d <%s>\n",
      objc, ObjStr(tcd->cmdName));*/
    memcpy(ov, objv, sizeof(Tcl_Obj *) * (size_t)objc);
    ov[0] = tcd->cmdName;
    result = CallForwarder(tcd, interp, objc, ov);
    FREE_ON_STACK(Tcl_Obj *, ov);
    return result;

  } else {
    Tcl_Obj **ov, *freeList = NULL;
    int       j, outputincr, outputArg = 0, firstPosArg=1,
              totalargs = objc + tcd->nr_args + 3;

    ALLOC_ON_STACK(Tcl_Obj*, totalargs, OV);
    {
      ALLOC_ON_STACK(long, totalargs, objvmap);

      /*fprintf(stderr, "+++ forwardMethod standard case, allocated %d args, tcd->args %s\n",
        totalargs, ObjStr(tcd->args));*/

      ov = &OV[1];
      if (tcd->needobjmap) {
        memset(objvmap, -1, sizeof(long) * (size_t)totalargs);
      }

      /*
       * The first argument is always the command to forward to.
       */
      if ((result = ForwardArg(interp, objc, objv, tcd->cmdName, tcd,
                               &ov[outputArg], &freeList, &inputArg,
                               &objvmap[outputArg],
                               firstPosArg, &outputincr)) != TCL_OK) {
        goto exitforwardmethod;
      }
      outputArg += outputincr;

      /*
       * If there are non-positional args, determine the position of the first
       * positional arg.
       * for %1
       */
      if (tcd->hasNonposArgs) {
        firstPosArg = objc;
        for (j = outputArg; j < objc; j++) {
          const char *arg = ObjStr(objv[j]);
          if (*arg != '-') {
            firstPosArg = j;
            break;
          }
        }
      }

      if (tcd->args != NULL) {
        Tcl_Obj **listElements;
        int       nrElements;

        /*
         * Copy the argument list from the definitions.
         */
        Tcl_ListObjGetElements(interp, tcd->args, &nrElements, &listElements);

        for (j = 0; j < nrElements; j++, outputArg += outputincr) {
          if ((result = ForwardArg(interp, objc, objv, listElements[j], tcd,
                                   &ov[outputArg], &freeList, &inputArg,
                                   &objvmap[outputArg],
                                   firstPosArg, &outputincr)) != TCL_OK) {
            goto exitforwardmethod;
          }
        }
      }

      /*fprintf(stderr, "objc=%d, tcd->nr_subcommands=%d size=%d\n",
        objc, tcd->nr_subcommands, objc+ 2            );*/

      if (objc-inputArg > 0) {
        /*fprintf(stderr, "  copying remaining %d args starting at [%d]\n",
          objc-inputArg, outputArg);*/
        memcpy(ov+outputArg, objv+inputArg, sizeof(Tcl_Obj *) * ((size_t)objc - (size_t)inputArg));
      } else {
        /*fprintf(stderr, "  nothing to copy, objc=%d, inputArg=%d\n", objc, inputArg);*/
      }
      if (tcd->needobjmap) {
        /*
         * The objmap can shuffle the argument list. Set the addressing
         * relative from the end. -2 means last, -3 element before last, etc.
         */
        int max = objc + tcd->nr_args - inputArg;

        for (j = 0; j < totalargs; j++) {
          if (objvmap[j] < -1) {
            /*fprintf(stderr, "must reduct, v=%d\n", objvmap[j]);*/
            objvmap[j] = max + objvmap[j] + 2;
            /*fprintf(stderr, "... new value=%d, max = %d\n", objvmap[j], max);*/
          }
        }
      }
      objc += outputArg - inputArg;

#if 0
      for(j = 0; j < objc; j++) {
        /*fprintf(stderr, "  ov[%d]=%p, objc=%d\n", j, ov[j], objc);*/
        fprintf(stderr, " o[%d]=%p %s (%d),", j, ov[j], ov[j] ? ObjStr(ov[j]) : "NADA", objvmap[j]);
      }
      fprintf(stderr, "\n");
#endif

      if (tcd->needobjmap) {

        for (j = 0; j < totalargs; j++) {
          Tcl_Obj *tmp;
          long     pos = objvmap[j], i;

          if (pos == -1 || pos == j) {
            continue;
          }
          tmp = ov[j];
          if (j > pos) {
            for(i = j; i > pos; i--) {
              /*fprintf(stderr, "...moving right %d to %d\n", i-1, i);*/
              ov[i] = ov[i-1];
              objvmap[i] = objvmap[i-1];
            }
          } else {
            for(i = j; i < pos; i++) {
              /*fprintf(stderr, "...moving left %d to %d\n", i+1, i);*/
              ov[i] = ov[i+1];
              objvmap[i] = objvmap[i+1];
            }
          }
          /*fprintf(stderr, "...setting at %d -> %s\n", pos, ObjStr(tmp));*/
          ov[pos] = tmp;
          objvmap[pos] = -1;
        }
      }

      /*
	If a prefix is given it is prepended to the 2nd argument to avoid name
	clashes, e.g. with a subcommand.

	Only prepend the prefix if a second argument is actually available!
	Let any given prefix be a no-op otherwise.
      */
      if (tcd->prefix && objc > 1) {
        Tcl_Obj *methodName = Tcl_DuplicateObj(tcd->prefix);

        Tcl_AppendObjToObj(methodName, ov[1]);
        ov[1] = methodName;
        INCR_REF_COUNT(ov[1]);
      }

#if 0
      for(j = 0; j < objc; j++) {
        /*fprintf(stderr, "  ov[%d]=%p, objc=%d\n", j, ov[j], objc);*/
        fprintf(stderr, "  ov[%d]=%p '%s' map=%d\n", j, ov[j], ov[j] ? ObjStr(ov[j]) : "NADA", objvmap[j]);
      }
#endif

      OV[0] = tcd->cmdName;

      result = CallForwarder(tcd, interp, objc, ov);

      if (tcd->prefix && objc > 1) {
        DECR_REF_COUNT(ov[1]);
      }
    exitforwardmethod:
      if (freeList != NULL) {
        DECR_REF_COUNT2("AddObjToTclList", freeList);
      }

      FREE_ON_STACK(long, objvmap);
    }
    FREE_ON_STACK(Tcl_Obj*, OV);
  }
  return result;
}


/*
 *----------------------------------------------------------------------
 * NsfProcAliasMethod --
 *
 *    A Tcl_ObjCmdProc.  Only invoked by directly calling the handle.  Since
 *    aliases are resolved during dispatch, it should never be called during
 *    normal operations. 
 *
 * Results:
 *    TCL_ERROR.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static int NsfProcAliasMethod(ClientData clientData,
                              Tcl_Interp *interp, int UNUSED(objc),
                              Tcl_Obj *const UNUSED(objv[]))
  nonnull(1) nonnull(2) nonnull(4);

static int
NsfProcAliasMethod(ClientData clientData,
                   Tcl_Interp *interp, int UNUSED(objc),
                   Tcl_Obj *const UNUSED(objv[])) {
  AliasCmdClientData *tcd;

  nonnull_assert(clientData != NULL);
  nonnull_assert(interp != NULL);

  tcd = (AliasCmdClientData *)clientData;
  return NsfDispatchClientDataError(interp, NULL, "object",
                                    Tcl_GetCommandName(interp, tcd->aliasCmd));
}


/*
 *----------------------------------------------------------------------
 * NsfObjscopedMethod --
 *
 *    A Tcl_ObjCmdProc.  Called when an object-scoped alias is invoked.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */

static int NsfObjscopedMethod(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])
  nonnull(1) nonnull(2) nonnull(4);

static int
NsfObjscopedMethod(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  AliasCmdClientData *tcd;
  NsfObject          *object;
  CallFrame           frame, *framePtr = &frame;
  int                 result;

  nonnull_assert(clientData != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);

  tcd = (AliasCmdClientData *)clientData;
  /*fprintf(stderr, "objscopedMethod obj=%p %s, ptr=%p\n", object, ObjectName(object), tcd->objProc);*/

  object = tcd->object;
  tcd->object = NULL;

  Nsf_PushFrameObj(interp, object, framePtr);
  result = Tcl_NRCallObjProc(interp, tcd->objProc, tcd->clientData, objc, objv);
  Nsf_PopFrameObj(interp, framePtr);

  return result;
}

/*
 *----------------------------------------------------------------------
 * IsDashArg --
 *
 *    Determines whether the given argument, which points to the index
 *    isFirstArg, starts with a "-" or is a list starting with a "-". Stores
 *    in *methodName the name of the dashed argument without the dash.
 *
 * Results:
 *    Enum value dashArgType.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

typedef enum {NO_DASH, SCALAR_DASH, LIST_DASH} dashArgType;

static dashArgType IsDashArg(Tcl_Interp *interp, Tcl_Obj *obj, int isFirstArg, const char **methodName,
                             int *objcPtr, Tcl_Obj **objvPtr[])
  nonnull(1) nonnull(2) nonnull(4) nonnull(5) nonnull(6);

static dashArgType
IsDashArg(Tcl_Interp *interp, Tcl_Obj *obj, int isFirstArg, const char **methodName,
          int *objcPtr, Tcl_Obj **objvPtr[]) {
  const char *flag;

  nonnull_assert(interp != NULL);
  nonnull_assert(obj != NULL);
  nonnull_assert(methodName != NULL);
  nonnull_assert(objcPtr != NULL);
  nonnull_assert(objvPtr != NULL);

  if (obj->typePtr == Nsf_OT_listType) {
    if (Tcl_ListObjGetElements(interp, obj, objcPtr, objvPtr) == TCL_OK && *objcPtr > 1) {
      flag = ObjStr(*objvPtr[0]);
      /*fprintf(stderr, "we have a list starting with '%s'\n", flag);*/
      if (*flag == '-') {
        *methodName = flag+1;
        return LIST_DASH;
      }
    }
  }
  flag = ObjStr(obj);
  /*fprintf(stderr, "we have a scalar '%s' isFirstArg %d\n", flag, isFirstArg);*/

  if ((*flag == '-') && isalpha(*((flag)+1))) {
    if (isFirstArg == 1) {
      /*
       * If the argument contains whitespace, try to split it.
       */
      const char *p = flag+1;

      while (*p != '\0' && !NsfHasTclSpace(p)) p++;
      if (NsfHasTclSpace(p)) {
        if (Tcl_ListObjGetElements(interp, obj, objcPtr, objvPtr) == TCL_OK) {
          *methodName = ObjStr(*objvPtr[0]);
          if (**methodName == '-') {
            (*methodName)++ ;
          }
          return LIST_DASH;
        }
      }
    }
    *methodName = flag+1;
    *objcPtr = 1;
    return SCALAR_DASH;
  }
  return NO_DASH;
}

/*
 *----------------------------------------------------------------------
 * CallConfigureMethod --
 *
 *    Calls a method identified by a string selector or prints an error
 *    message. This dispatcher function also records constructor (init) calls
 *    via this interface. The dispatcher is used in XOTcl's configure(),
 *    interpreting arguments with a leading dash as method dispatches.  This
 *    behavior is now implemented in NsfOResidualargsMethod().
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */
static int CallConfigureMethod(Tcl_Interp *interp, NsfObject *object, const char *initString,
                               const char *methodName,
                               int argc, Tcl_Obj *const argv[])
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static int
CallConfigureMethod(Tcl_Interp *interp, NsfObject *object, const char *initString,
                    const char *methodName,
                    int argc, Tcl_Obj *const argv[]) {
  int result;
  Tcl_Obj *methodObj = Tcl_NewStringObj(methodName, -1);

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(initString != NULL);
  nonnull_assert(methodName != NULL);

  /*
   * When "-init" is passed to configure, flag that fact in the object and call
   * the method.
   */

  if (*initString == *methodName && strcmp(methodName, initString) == 0) {
    object->flags |= NSF_INIT_CALLED;
  }

  Tcl_ResetResult(interp);
  INCR_REF_COUNT(methodObj);
  result = CallMethod(object, interp, methodObj, argc, argv,
                      NSF_CM_NO_UNKNOWN|NSF_CSC_IMMEDIATE|NSF_CM_IGNORE_PERMISSIONS);
  DECR_REF_COUNT(methodObj);

  /*fprintf(stderr, "method  '%s' called args: %d o=%p, result=%d %d\n",
    methodName, argc+1, object, result, TCL_ERROR);*/

  if (unlikely(result != TCL_OK)) {
    Tcl_Obj *res = Tcl_DuplicateObj(Tcl_GetObjResult(interp)); /* save the result */

    INCR_REF_COUNT(res);
    NsfPrintError(interp, "%s during '%s.%s'", ObjStr(res), ObjectName_(object), methodName);
    DECR_REF_COUNT(res);
  }

  return result;
}


/*
 * class method implementations
 */

/*
 *----------------------------------------------------------------------
 * IsRootNamespace --
 *
 *    True if the provided namespace is the namespace of the base class of an
 *    object system.
 *
 * Results:
 *    A boolean value.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static bool IsRootNamespace(const Tcl_Interp *interp, const Tcl_Namespace *nsPtr)
  nonnull(1) nonnull(2) NSF_pure;

static bool
IsRootNamespace(const Tcl_Interp *interp, const Tcl_Namespace *nsPtr) {
  const NsfObjectSystem *osPtr;

  nonnull_assert(interp != NULL);
  nonnull_assert(nsPtr != NULL);

  for (osPtr = RUNTIME_STATE(interp)->objectSystems; osPtr != NULL; osPtr = osPtr->nextPtr) {
    const Tcl_Command cmd = osPtr->rootClass->object.id;
    if ((Tcl_Namespace *)((Command *)cmd)->nsPtr == nsPtr) {
      return NSF_TRUE;
    }
  }
  return NSF_FALSE;
}

/*
 *----------------------------------------------------------------------
 * CallingNameSpace --
 *
 *    Returns the namespace for the level immediately above the Next Scripting
 *    system namespaces. Skips system-specific namespaces, e.g. the namespaces
 *    of the pre-defined slot handlers for mixin and class registration. etc.
 *    If such namespaces were used, names that aren't fully qualified would get
 *    resolved relative to the root namespace.
 *
 * Results:
 *    A Tcl_Namespace or NULL.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static Tcl_Namespace *
CallingNameSpace(Tcl_Interp *interp) {
  Tcl_CallFrame *framePtr;
  Tcl_Namespace *nsPtr = NULL;

  nonnull_assert(interp != NULL);

  /*NsfShowStack(interp);*/
  framePtr = CallStackGetActiveProcFrame((Tcl_CallFrame *)Tcl_Interp_varFramePtr(interp));
  /* framePtr = BeginOfCallChain(interp, GetSelfObj(interp));*/

  for (; likely(framePtr != NULL); framePtr = Tcl_CallFrame_callerVarPtr(framePtr)) {
    nsPtr = Tcl_CallFrame_nsPtr(framePtr);

    if (IsRootNamespace(interp, nsPtr)) {
      /*fprintf(stderr, "... %p skip %s\n", framePtr, nsPtr->fullName);*/
      continue;
    }
    /*fprintf(stderr, "... %p take %s\n", framePtr, nsPtr->fullName); */
    break;
  }

  if (framePtr == NULL) {
    nsPtr = Tcl_GetGlobalNamespace(interp);
  }

  /*fprintf(stderr, " **** CallingNameSpace: returns %p %s framePtr %p\n",
    nsPtr, (nsPtr != NULL) ? nsPtr->fullName:"(null)", framePtr);*/
  return nsPtr;
}

/***********************************
 * argument handling
 ***********************************/

static void ArgumentResetRefCounts(const struct Nsf_Param *pPtr, Tcl_Obj *valueObj)
  nonnull(1) nonnull(2);

static void
ArgumentResetRefCounts(const struct Nsf_Param *pPtr, Tcl_Obj *valueObj) {

  nonnull_assert(pPtr != NULL);
  nonnull_assert(valueObj != NULL);

  if ((pPtr->flags & NSF_ARG_IS_CONVERTER) != 0u) {
    DECR_REF_COUNT2("valueObj", valueObj);
  }
}

/*
 *----------------------------------------------------------------------
 * ArgumentCheckHelper --
 *
 *    Helper for ArgumentCheck().  Called when argument checking leads to a
 *    different output element, i.e. non-pure checking.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int ArgumentCheckHelper(Tcl_Interp *interp, Tcl_Obj *objPtr, const struct Nsf_Param *pPtr, unsigned int *flags,
                               ClientData *clientData, Tcl_Obj **outObjPtr)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4) nonnull(5) nonnull(6);

static int
ArgumentCheckHelper(Tcl_Interp *interp,
                    Tcl_Obj *objPtr,
                    const struct Nsf_Param *pPtr,
                    unsigned int *flags,
                    ClientData *clientData,
                    Tcl_Obj **outObjPtr) {
  int       objc, i, result;
  Tcl_Obj **ov;

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(pPtr != NULL);
  nonnull_assert(flags != NULL);
  nonnull_assert(clientData != NULL);
  nonnull_assert(outObjPtr != NULL);
  assert((pPtr->flags & NSF_ARG_MULTIVALUED) != 0u);
  assert((*flags & NSF_PC_MUST_DECR) != 0u);

  result = Tcl_ListObjGetElements(interp, objPtr, &objc, &ov);
  if (unlikely(result != TCL_OK)) {
    return result;
  }

  *outObjPtr = Tcl_NewListObj(0, NULL);
  INCR_REF_COUNT2("valueObj", *outObjPtr);

  for (i = 0; i < objc; i++) {
    Tcl_Obj    *elementObjPtr = ov[i];
    const char *valueString = ObjStr(elementObjPtr);

    if ((pPtr->flags & NSF_ARG_ALLOW_EMPTY) != 0u && *valueString == '\0') {
      result = Nsf_ConvertToString(interp, elementObjPtr, pPtr, clientData, &elementObjPtr);
    } else {
      result = (*pPtr->converter)(interp, elementObjPtr, pPtr, clientData, &elementObjPtr);
    }

    /*fprintf(stderr, "ArgumentCheckHelper convert %s result %d (%s)\n",
      valueString, result, ObjStr(elementObjPtr));*/

    if (result == TCL_OK || result == TCL_CONTINUE) {
      Tcl_ListObjAppendElement(interp, *outObjPtr, elementObjPtr);
      /*
       * If the refCount of the valueObj was already incremented, decrement it
       * here since valueObj should be reclaimed when the list containing the
       * valueObj is freed.
       */
      ArgumentResetRefCounts(pPtr, elementObjPtr);
    } else {
      Tcl_Obj *resultObj = Tcl_GetObjResult(interp);

      INCR_REF_COUNT(resultObj);
      NsfPrintError(interp, "invalid value in \"%s\": %s", ObjStr(objPtr), ObjStr(resultObj));
      *flags &= ~NSF_PC_MUST_DECR;
      *outObjPtr = objPtr;
      DECR_REF_COUNT2("valueObj", *outObjPtr);
      DECR_REF_COUNT(resultObj);

      break;
    }
  }
  return result;
}


/*
 *----------------------------------------------------------------------
 * ArgumentCheck --
 *
 *    Validates the argument parameter against the parameter structure if
 *    argument checking is enabled, which it is by default.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int
ArgumentCheck(Tcl_Interp *interp, Tcl_Obj *objPtr, const struct Nsf_Param *pPtr,
              unsigned int doCheckArguments,
              unsigned int *flags, ClientData *clientData, Tcl_Obj **outObjPtr) {
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);
  nonnull_assert(pPtr != NULL);
  nonnull_assert(flags != NULL);
  nonnull_assert(clientData != NULL);
  nonnull_assert(outObjPtr != NULL);

  /*
   * By default, assume outObjPtr is not modified.
   */
  *outObjPtr = objPtr;

  /*
   * Omit argument checking in the following cases:
   *
   *     Argument checking is turned off and the parameter is not a converter.
   *
   *     The ruling parameter option is 'cmd'.
   *
   *     slotset is active.
   */
  if ((unlikely((doCheckArguments & NSF_ARGPARSE_CHECK) == 0u) && (pPtr->flags & (NSF_ARG_IS_CONVERTER)) == 0u) ||
      ((pPtr->flags & (NSF_ARG_CMD)) != 0u) ||
      ((pPtr->flags & (NSF_ARG_SLOTSET)) != 0u)) {
    /* fprintf(stderr, "*** omit  argument check for arg %s flags %.6x\n", pPtr->name, pPtr->flags); */
    *clientData = ObjStr(objPtr);
    return TCL_OK;
  }

  /*
   * If the argument is multivalued, perform the check for each element of the
   * list (pure checker), or else build a new list if the converter alters the
   * values.
   */
  if (unlikely((pPtr->flags & NSF_ARG_MULTIVALUED) != 0u)) {
    int objc, i;
    Tcl_Obj **ov;

    result = Tcl_ListObjGetElements(interp, objPtr, &objc, &ov);
    if (unlikely(result != TCL_OK)) {
      return result;
    }

    if (objc == 0 && ((pPtr->flags & NSF_ARG_ALLOW_EMPTY) == 0u)) {
      return NsfPrintError(interp,
                           "invalid value for parameter '%s': list is not allowed to be empty",
                           pPtr->name);
    }

    /*
     * Use the helper function if necessary, e.g. the output element changed.
     */
    for (i = 0; i < objc; i++) {
      Tcl_Obj *elementObjPtr = ov[i];

      result = (*pPtr->converter)(interp, elementObjPtr, pPtr, clientData, &elementObjPtr);
      if (likely(result == TCL_OK || result == TCL_CONTINUE)) {
        if (ov[i] != elementObjPtr) {
          /*fprintf(stderr, "ArgumentCheck: switch to output list construction for value %s\n",
            ObjStr(elementObjPtr));*/
          /*
           * The elementObjPtr differs from the input Tcl_Obj. Switch to the
           * version of this handler building an output list, but first reset
           * the reference counts from the first conversion.
           */
          ArgumentResetRefCounts(pPtr, elementObjPtr);
          *flags |= NSF_PC_MUST_DECR;
          result = ArgumentCheckHelper(interp, objPtr, pPtr, flags, clientData, outObjPtr);
          break;
        }
      } else {
        Tcl_Obj *resultObj = Tcl_GetObjResult(interp);
        INCR_REF_COUNT(resultObj);
        NsfPrintError(interp, "invalid value in \"%s\": %s", ObjStr(objPtr), ObjStr(resultObj));
        DECR_REF_COUNT(resultObj);
        break;
      }
    }
  } else {
    assert(objPtr == *outObjPtr);
    if ((pPtr->flags & NSF_ARG_ALLOW_EMPTY) != 0u && *(ObjStr(objPtr)) == '\0') {
      result = Nsf_ConvertToString(interp, objPtr, pPtr, clientData, outObjPtr);
    } else {
      result = (*pPtr->converter)(interp, objPtr, pPtr, clientData, outObjPtr);
    }

    /*fprintf(stderr, "ArgumentCheck param %s type %s is converter %d flags %.6x "
            "outObj changed %d (%p %p) isok %d\n",
            pPtr->name, pPtr->type, pPtr->flags & NSF_ARG_IS_CONVERTER, pPtr->flags,
            objPtr != *outObjPtr, objPtr, *outObjPtr, result == TCL_OK);*/

    if (unlikely((pPtr->flags & NSF_ARG_IS_CONVERTER) != 0u) && objPtr != *outObjPtr) {
      *flags |= NSF_PC_MUST_DECR;
    } else {
      /*
       * If the output object differs from the input object, verify that
       * MUST_DECR is set.
       */
      assert( (*flags & NSF_PC_MUST_DECR) != 0u || objPtr == *outObjPtr );
    }
  }

  if (unlikely(result == TCL_CONTINUE)) {
    *flags |= NSF_ARG_WARN;
    result = TCL_OK;
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * ArgumentDefaults --
 *
 *    Processes the given arguments and if necessary, sets defaults in the
 *    given parse context, if provided.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int ArgumentDefaults(ParseContext *pcPtr, Tcl_Interp *interp,
                            const Nsf_Param *ifd, int nrParams, unsigned int processFlags)
  nonnull(1) nonnull(2) nonnull(3);

static int
ArgumentDefaults(ParseContext *pcPtr, Tcl_Interp *interp,
                 const Nsf_Param *ifd, int nrParams, unsigned int processFlags) {
  const Nsf_Param *pPtr;
  int i;

  nonnull_assert(pcPtr != NULL);
  nonnull_assert(interp != NULL);
  nonnull_assert(ifd != NULL);

  for (pPtr = ifd, i = 0; i < nrParams; pPtr++, i++) {
    /*fprintf(stderr, "ArgumentDefaults got for arg %s (req %d, nrArgs %d) %p => %p %p, default '%s' \n",
            pPtr->name, pPtr->flags & NSF_ARG_REQUIRED, pPtr->nrArgs, pPtr,
            pcPtr->clientData[i], pcPtr->objv[i],
            (pPtr->defaultValue != NULL) ? ObjStr(pPtr->defaultValue) : "NONE");*/

    if (pcPtr->objv[i] != NULL) {
      /*
       * This is an actual value which was already checked by ArgumentParse().
       * If the value is a switch and NSF_PC_INVERT_DEFAULT is set, take the
       * default and invert the value in-place.
       */
      if (unlikely((pcPtr->flags[i] & NSF_PC_INVERT_DEFAULT) != 0u)) {
        int boolVal;

        assert(pPtr->defaultValue != NULL);

        Tcl_GetBooleanFromObj(interp, pPtr->defaultValue, &boolVal);
        pcPtr->objv[i] = Tcl_NewBooleanObj(boolVal == 0);
        /*
         * Bump the reference count to preserve the new obj until this process
         * completes.  ParseContextRelease() then decrements it.
         */
        INCR_REF_COUNT2("valueObj", pcPtr->objv[i]);
        pcPtr->flags[i] |= NSF_PC_MUST_DECR;
        pcPtr->status |= NSF_PC_STATUS_MUST_DECR;
      }
    } else {
      /*
       * No value was passed. Is a default available?
       */

      if (pPtr->defaultValue != NULL) {
        int mustDecrNewValue;
        Tcl_Obj *newValue = pPtr->defaultValue;
        ClientData checkedData;

        /*
         * There is a default value.  Flag the argument accordingly.
         */
        pcPtr->flags[i] |= NSF_PC_IS_DEFAULT;

        /*
         * Does the user want to substitute in the default value?
         */
        if (unlikely((pPtr->flags & NSF_ARG_SUBST_DEFAULT) != 0u)) {
          int      tclOptions = 0;
          Tcl_Obj *obj;

          if ((pPtr->flags & NSF_ARG_SUBST_DEFAULT_VARIABLES) != 0u) {
            tclOptions |= TCL_SUBST_VARIABLES;
          }
          if ((pPtr->flags & NSF_ARG_SUBST_DEFAULT_COMMANDS) != 0u) {
            tclOptions |= TCL_SUBST_COMMANDS;
          }
          if ((pPtr->flags & NSF_ARG_SUBST_DEFAULT_BACKSLASHES) != 0u) {
            tclOptions |= TCL_SUBST_BACKSLASHES;
          }
          /* fprintf(stderr, "SUBST tclOptions %.4x\n", tclOptions);*/
          obj = Tcl_SubstObj(interp, newValue, tclOptions);

          if (likely(obj != NULL)) {
             newValue = obj;
          } else {
            pcPtr->flags[i] = 0u;
            return TCL_ERROR;
          }

          /*
           * ParseContextRelease() performs the matching decrement.
           */
          INCR_REF_COUNT2("valueObj", newValue);
          /*fprintf(stderr, "SUBST_DEFAULT increments %p refCount %d\n",
            newValue, newValue->refCount);*/
          mustDecrNewValue = 1;
          pcPtr->flags[i] |= NSF_PC_MUST_DECR;
          pcPtr->status |= NSF_PC_STATUS_MUST_DECR;
        } else {
          mustDecrNewValue = 0;
        }

        pcPtr->objv[i] = newValue;
        /*fprintf(stderr, "==> setting default value '%s' for var '%s' flag %d type %s conv %p\n",
                ObjStr(newValue), pPtr->name, pPtr->flags & NSF_ARG_INITCMD,
                pPtr->type, pPtr->converter);*/
        /*
         * Check the default value if necessary.
         */
        if (pPtr->type != NULL || unlikely((pPtr->flags & NSF_ARG_MULTIVALUED) != 0u)) {
          unsigned int mustDecrList = 0;

          if (unlikely((pPtr->flags & NSF_ARG_INITCMD) == 0u &&
                       ArgumentCheck(interp, newValue, pPtr,
                                     RUNTIME_STATE(interp)->doCheckArguments,
                                     &mustDecrList, &checkedData, &pcPtr->objv[i]) != TCL_OK)) {
            if (mustDecrNewValue == 1) {
              DECR_REF_COUNT2("valueObj", newValue);
              pcPtr->flags[i] &= ~NSF_PC_MUST_DECR;
            }
            return TCL_ERROR;
          }

          if (unlikely(pcPtr->objv[i] != newValue)) {
            /*
             * The output Tcl_Obj differs from the input, so the Tcl_Obj was
             * converted. If NSF_PC_MUST_DECR is set on the on newValue,
             * decrement the refCount and clear the flag.
             */
            if (mustDecrNewValue == 1) {
              DECR_REF_COUNT2("valueObj", newValue);
              pcPtr->flags[i] &= ~NSF_PC_MUST_DECR;
            }
            /*
	     * The new output value itself might require a decrement, so set
	     * the flag here if requiredT this is only necessary for
	     * multivalued converted output.
             */
            if (mustDecrList == 1) {
              pcPtr->flags[i] |= NSF_PC_MUST_DECR;
              pcPtr->status |= NSF_PC_STATUS_MUST_DECR;
            }
          }
        } else {
          /*fprintf(stderr, "Param %s default %s type %s\n",
            pPtr->name, ObjStr(pPtr->defaultValue), pPtr->type);*/
          assert((pPtr->type != NULL) ? pPtr->defaultValue == NULL : 1);
        }
      } else if (unlikely((pPtr->flags & NSF_ARG_REQUIRED) != 0u)
                 && ((processFlags & NSF_ARGPARSE_FORCE_REQUIRED) != 0u)) {
        Tcl_Obj *paramDefsObj = NsfParamDefsSyntax(interp, ifd, pcPtr->object, NULL);
        Tcl_Obj *methodPathObj = NsfMethodNamePath(interp,
                                                   CallStackGetTclFrame(interp, NULL, 1),
                                                   MethodName(pcPtr->full_objv[0]));

        INCR_REF_COUNT2("methodPathObj", methodPathObj);

        NsfPrintError(interp, "required argument '%s' is missing, should be:\n        %s%s%s %s",
                      (pPtr->nameObj != NULL) ? ObjStr(pPtr->nameObj) : pPtr->name,
                      (pcPtr->object != NULL) ? ObjectName(pcPtr->object) : "", (pcPtr->object != NULL) ? " " : "",
                      ObjStr(methodPathObj),
                      ObjStr(paramDefsObj));

        DECR_REF_COUNT2("paramDefsObj", paramDefsObj);
        DECR_REF_COUNT2("methodPathObj", methodPathObj);

        return TCL_ERROR;

      } else {
        /*
         * Use an arbitrary symbol which must not be returned to the Tcl level
         * as the default value.  It is unset later, typically by
         * NsfUnsetUnknownArgsCmd().
         */
        pcPtr->objv[i] = NsfGlobalObjs[NSF___UNKNOWN__];
      }
    }
  }
  return TCL_OK;
}


/*
 *----------------------------------------------------------------------
 * ArgumentParse --
 *
 *    Parses the arguments using the given parameter definitions.  The result
 *    is stored in a normalized order in the parse context.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
int
Nsf_ArgumentParse(
    Tcl_Interp *interp, int objc, Tcl_Obj *const objv[],
    Nsf_Object *object, Tcl_Obj *procNameObj,
    const Nsf_Param *paramPtr, int nrParams, int serial,
    unsigned int processFlags, Nsf_ParseContext *pcPtr
) {

  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);
  nonnull_assert(procNameObj != NULL);
  nonnull_assert(pcPtr != NULL);

  return ArgumentParse(interp, objc, objv, (NsfObject *)object, procNameObj,
                       paramPtr, nrParams, serial, processFlags,
                       (ParseContext *)pcPtr);
}

/*
 *----------------------------------------------------------------------
 * NextParam --
 *
 *    Advances in the parameter definitions and returns the next parameter.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static const Nsf_Param * NextParam(Nsf_Param const *paramPtr, const Nsf_Param *lastParamPtr)
  nonnull(1) nonnull(2) returns_nonnull NSF_pure;

static const Nsf_Param *
NextParam(Nsf_Param const *paramPtr, const Nsf_Param *lastParamPtr) {

  nonnull_assert(paramPtr != NULL);
  nonnull_assert(lastParamPtr != NULL);

  for (; (++paramPtr <= lastParamPtr) && (*paramPtr->name == '-'); );
  return paramPtr;
}

/*
 *----------------------------------------------------------------------
 * ArgumentParse --
 *
 *    Parses the given list of arguments using the given parameter definitions,
 *    storing the result in the parse context structure.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

#define SkipNonposParamDefs(cPtr) \
  for (; (++(cPtr) <= lastParamPtr) && (*(cPtr)->name == '-'); )

static int
ArgumentParse(
    Tcl_Interp *interp, int objc, Tcl_Obj *const objv[],
    NsfObject *object, Tcl_Obj *procNameObj,
    const Nsf_Param *paramPtr, int nrParams, int serial,
    unsigned int processFlags, ParseContext *pcPtr
) {
  int              o, fromArg;
  bool             dashdash = NSF_FALSE;
  long             j;
  const Nsf_Param *currentParamPtr;
  const Nsf_Param *lastParamPtr;

  nonnull_assert(interp != NULL);
  nonnull_assert(procNameObj != NULL);
  nonnull_assert(paramPtr != NULL);
  nonnull_assert(pcPtr != NULL);

  if ((processFlags & NSF_ARGPARSE_START_ZERO) != 0u) {
    fromArg = 0;
  } else {
    fromArg = 1;
  }

  ParseContextInit(pcPtr, nrParams, object, procNameObj);

#if defined(PARSE_TRACE)
  { const Nsf_Param *pPtr;
    fprintf(stderr, "PARAMETER ");
    for (o = 0, pPtr = paramPtr; pPtr->name != NULL; o++, pPtr++) {
      fprintf(stderr, "[%d]%s (nrargs %d %s) ", o,
              pPtr->name, pPtr->nrArgs,
              (pPtr->flags & NSF_ARG_REQUIRED) != 0u ? "req" : "opt");
    }
    fprintf(stderr, "\n");
    fprintf(stderr, "BEGIN (%d) [0]%s ", objc, ObjStr(procNameObj));
    for (o = fromArg; o < objc; o++) {
      Tcl_Obj *obj = objv[o];
      if (obj->bytes == NULL) {
        fprintf(stderr, "[%d]unk(%s) ", o, obj->typePtr->name);
      } else {
        fprintf(stderr, "[%d]%s ", o, ObjStr(obj));
      }
    }
    fprintf(stderr, "\n");
  }
#endif

  currentParamPtr = paramPtr;
  lastParamPtr = paramPtr + nrParams - 1;
  for (o = fromArg; o < objc; o++) {
    const Nsf_Param *pPtr = currentParamPtr;
    Tcl_Obj         *argumentObj = objv[o], *valueObj = NULL;
    const char      *valueInArgument = NULL;

#if defined(PARSE_TRACE_FULL)
    fprintf(stderr, "arg [%d]: %s (param %ld, last %d)\n",
            o, ObjStr(argumentObj), currentParamPtr - paramPtr, currentParamPtr == lastParamPtr);
#endif

    if (unlikely(currentParamPtr > lastParamPtr)) {
      int result;
      Tcl_Obj *methodPathObj;

      methodPathObj = NsfMethodNamePath(interp,
                                        CallStackGetTclFrame(interp, NULL, 0),
                                        NsfMethodName(procNameObj));
      INCR_REF_COUNT(methodPathObj);
      result = NsfUnexpectedArgumentError(interp, ObjStr(argumentObj), (Nsf_Object*)object,
                                        paramPtr, methodPathObj);
      DECR_REF_COUNT(methodPathObj);
      return result;
    }

    if (*currentParamPtr->name == '-') {
      /*
       * A non-positional argument is expected. Determine whether there is
       * already Tcl_Obj converted to NsfFlagObjType.
       */
      NsfFlag *flagPtr = argumentObj->internalRep.twoPtrValue.ptr1;

#if defined(PARSE_TRACE_FULL)
      fprintf(stderr, "... arg %p %s expect non-pos arg in block %s isFlag %d sig %d serial %d (%d => %d)\n",
              (void*)argumentObj, ObjStr(argumentObj), currentParamPtr->name,
              argumentObj->typePtr == &NsfFlagObjType,
              argumentObj->typePtr == &NsfFlagObjType ? flagPtr->signature == paramPtr : 0,
              argumentObj->typePtr == &NsfFlagObjType ? flagPtr->serial == serial : 0,
              argumentObj->typePtr == &NsfFlagObjType ? flagPtr->serial : 0,
              serial );
#endif

      if (argumentObj->typePtr == &NsfFlagObjType
          && flagPtr->signature == paramPtr
          && flagPtr->serial == serial
          && flagPtr->paramPtr != NULL /* when the parameter was previously used in a cget */
          ) {
        /*
         * The argument was processed before and the Tcl_Obj is still valid.
         */
        if ((flagPtr->flags & NSF_FLAG_DASHDAH) != 0u) {
          /*
           * Found a dash-dash, skip non-pos param definitions and continue with next
           * element from objv.
           */
          SkipNonposParamDefs(currentParamPtr);
          assert(!dashdash);
          continue;
        } else if ((flagPtr->flags & NSF_FLAG_CONTAINS_VALUE) != 0u) {
          /*
           * Found a flag with an embedded value, e.g. -flag=1.
           */
          valueInArgument = "flag";
        }
        pPtr = flagPtr->paramPtr;
        valueObj = flagPtr->payload;

      } else if ((argumentObj->typePtr == Nsf_OT_byteArrayType)
                 || (argumentObj->typePtr == Nsf_OT_properByteArrayType)
                 /*
                    || (argumentObj->typePtr == Nsf_OT_intType)
                    || (argumentObj->typePtr == Nsf_OT_doubleType)
                 */
                 ) {
        /*
         * The actual argument belongs to the types which are assumed to not
         * belong to a non-positional flag.  The argument might be e.g. a pure
         * Tcl bytearray, for which a string representation should not be
         * generated (Tcl 8.6). Proceed in the parameters to the next
         * positional parameter.
         */
        SkipNonposParamDefs(currentParamPtr);
        pPtr = currentParamPtr;
        /*
         * currentParamPtr is either NULL or points to a positional parameter.
         */
        assert(currentParamPtr == NULL || currentParamPtr->name == NULL || *currentParamPtr->name != '-');
      } else {
        const char *argumentString = ObjStr(argumentObj);
        /*
	 * A non-positional argument is expected but the lookup from the
	 * Tcl_Obj has failed.  If this non-positional argument is optional the
	 * current argument might also contain a value for a positional
	 * argument, and the argument might be for a positional argument later.
	 * First check whether the argument looks like a flag.
         */
        if (argumentString[0] != '-') {
          /*
           * The actual argument is not a flag so proceed in the parameters
           * to the next block (positional parameter).
           */
          SkipNonposParamDefs(currentParamPtr);
          pPtr = currentParamPtr;
          /*
           * currentParamPtr is either NULL or points to a positional parameter.
           */
          assert(currentParamPtr == NULL || currentParamPtr->name == NULL || *currentParamPtr->name != '-');

        } else {
          /*
           * The actual argument starts with a dash, so search for the flag in
           * the current block of non-positional parameter definitions.
           */
          char ch1 = *(argumentString+1);

          /*
           * Is there a "--" ?
           */
          if (ch1 == '-' && *(argumentString+2) == '\0' && !dashdash) {
            dashdash = NSF_TRUE;
            NsfFlagObjSet(interp, argumentObj, paramPtr, serial,
                          NULL, NULL, NSF_FLAG_DASHDAH);
            SkipNonposParamDefs(currentParamPtr);
            continue;
          }

          valueInArgument = strchr(argumentString, '=');
          if (valueInArgument != NULL) {
            bool   found = NSF_FALSE;
            long   equalOffset = valueInArgument - argumentString;

            /*
             * Handle parameter like -flag=1.
             */
            for (; (pPtr <= lastParamPtr) && (*pPtr->name == '-'); pPtr++) {
              if (pPtr->nrArgs > 0) {
                /*
                 * Parameter expects no arg.  Can't be this.
                 */
                continue;
              }
              if ((pPtr->flags & NSF_ARG_NOCONFIG) == 0u
                  && ch1 == pPtr->name[1]
                  && strncmp(argumentString, pPtr->name, (size_t)equalOffset) == 0
                  && *(pPtr->name+equalOffset) == '\0') {

                valueObj = Tcl_NewStringObj(valueInArgument+1, -1);
                /*fprintf(stderr, "... value from argument = %s\n", ObjStr(valueObj));*/
                NsfFlagObjSet(interp, argumentObj, paramPtr, serial,
                              pPtr, valueObj, NSF_FLAG_CONTAINS_VALUE);
                found = NSF_TRUE;
                break;
              }
            }
            if (!found) {
              const Nsf_Param *nextParamPtr = NextParam(currentParamPtr, lastParamPtr);

              if (nextParamPtr > lastParamPtr
                  || ((nextParamPtr->flags & NSF_ARG_NODASHALNUM) != 0u)) {
                int result;
                Tcl_Obj *methodPathObj= NsfMethodNamePath(interp,
                                                          CallStackGetTclFrame(interp, NULL, 0),
                                                          NsfMethodName(procNameObj));
                INCR_REF_COUNT(methodPathObj);
                result = NsfUnexpectedNonposArgumentError(interp, argumentString,
                                                          (Nsf_Object *)object,
                                                          currentParamPtr, paramPtr,
                                                          methodPathObj);
                DECR_REF_COUNT(methodPathObj);
                return result;
              }
              pPtr = currentParamPtr = nextParamPtr;
            }
          } else {
            /*
             * Must be a classical non-positional argument.  Check for a
             * matching parameter definition.
             */
            bool found = NSF_FALSE;

            assert(pPtr == currentParamPtr);

            if (likely(ch1 != '\0')) {
              if (unlikely(NsfParamDefsNonposLookup(interp, argumentString, currentParamPtr, &pPtr) != TCL_OK)) {
                return TCL_ERROR;
              } else {
                if (pPtr != NULL) {
                  found = NSF_TRUE;
                  NsfFlagObjSet(interp, argumentObj, paramPtr, serial, pPtr, NULL, 0u);
                }
              }
            }

            /*
	     * The argument starting with the dash may have been found in the
	     * parameter definitions. If not, advance to the next positional
	     * parameter and store the value there if the parameter definition
	     * allows it.
             */
            if (!found) {
              int nonposArgError = 0;
              const Nsf_Param *nextParamPtr = NextParam(currentParamPtr, lastParamPtr);

              /*fprintf(stderr, "non-pos-arg '%s' not found, current %p %s last %p %s next %p %s\n",
                      argumentString,
                      currentParamPtr,  currentParamPtr->name,
                      lastParamPtr, lastParamPtr->name,
                      nextParamPtr, nextParamPtr->name);*/

              if (nextParamPtr > lastParamPtr) {
                nonposArgError = 1;
              } else if ((nextParamPtr->flags & NSF_ARG_NODASHALNUM) != 0u) {
                /*
		 * A numeric argument is allowed even when NSF_ARG_NODASHALNUM
		 * is true.
                 */
                nonposArgError = 1;

                if (argumentString[1] >= '0' && argumentString[1] <= '9') {
                  char *p;

                  (void)strtod(&argumentString[1], &p);
                  if (*p == '\0') {
                    /*
                     * The argument is numeric.
                     */
                    nonposArgError = 0;
                  }
                }
              }

              if (nonposArgError != 0) {
                int result;
                Tcl_Obj *methodPathObj = NsfMethodNamePath(interp,
                                                           CallStackGetTclFrame(interp, NULL, 0),
                                                           NsfMethodName(procNameObj));
                INCR_REF_COUNT(methodPathObj);
                result = NsfUnexpectedNonposArgumentError(interp, argumentString,
                                                          (Nsf_Object *)object,
                                                          currentParamPtr, paramPtr,
                                                          methodPathObj);
                DECR_REF_COUNT(methodPathObj);
                return result;
              }
              pPtr = currentParamPtr = nextParamPtr;
            }
          }
        }
        /* end of lookup loop */
      }
    } else {
      valueInArgument = NULL;
    }

    assert(pPtr != NULL);
    /*
     * "pPtr" points to the actual parameter (part of the currentParamPtr
     * block) or might point to a place past the last parameter, in which case
     * an unexpected argument was provided. "o" is the index of the actual
     * parameter, "valueObj" might be already provided for valueInArgument.
     */
    if (unlikely(pPtr > lastParamPtr)) {
      int      result;
      Tcl_Obj *methodPathObj;

      methodPathObj = NsfMethodNamePath(interp, CallStackGetTclFrame(interp, NULL, 0),
                                        NsfMethodName(procNameObj));
      INCR_REF_COUNT(methodPathObj);
      /*fprintf(stderr, "call NsfUnexpectedArgumentError 2\n");*/
      result = NsfUnexpectedArgumentError(interp, ObjStr(argumentObj),
                                        (Nsf_Object *)object, paramPtr,
                                        methodPathObj);
      DECR_REF_COUNT(methodPathObj);
      return result;
    }

    /*
     * Set the position in the downstream argv (normalized order).
     */
    j = pPtr - paramPtr;

#if defined(PARSE_TRACE_FULL)
    fprintf(stderr, "... pPtr->name %s/%d o %d objc %d\n", pPtr->name, pPtr->nrArgs, o, objc);
#endif
    if (*pPtr->name == '-') {
      /*
       * Process the non-positional arg.
       */
      if (pPtr->nrArgs == 1) {
        /*
         * The non-postional argument expects an argument.
         */
        o++;
        if (unlikely(o >= objc)) {
          /*
           * An argument is expected but this is the end of the argument list.
           */
          return NsfPrintError(interp, "value for parameter '%s' expected", pPtr->name);
        }
        assert(valueObj == NULL);
        valueObj = objv[o];
      } else {
        /*
         * The non-positional arg expects no argument.
         */
        if (valueObj == NULL) {
          valueObj = NsfGlobalObjs[NSF_ONE];
        }
      }

    } else if (unlikely((pPtr == lastParamPtr)
                        && (pPtr->converter == ConvertToNothing))) {
      /*
       * "args" was given. Use the varargs interface.  Store the actual
       * argument into pcPtr->objv. No checking is performed on "args".
       */
      pcPtr->varArgs = NSF_TRUE;
      pcPtr->objv[j] = argumentObj;


#if defined(PARSE_TRACE_FULL)
      fprintf(stderr, "... args found o %d objc %d is dashdash %d [%ld] <%s>\n",
              o, objc, (int)dashdash, j, ObjStr(argumentObj));
#endif
      break;

    } else {
      /*
       * Process an ordinary positional argument.
       */
      currentParamPtr ++;

#if defined(PARSE_TRACE_FULL)
      fprintf(stderr, "... positional arg o %d objc %d, nrArgs %d next paramPtr %s\n",
              o, objc, pPtr->nrArgs, currentParamPtr->name);
#endif

      if (unlikely(pPtr->nrArgs == 0)) {
        /*
         * For object parameter aliases, which are always fired, allow
         * positional arguments with no args. Such a parameter is non-consuming
         * so the processing of the current argument is not finished. Decrement
         * o and check for the end of the parameters.
         */
        o--;
        continue;
      }
      if (unlikely(dashdash)) {
        /*
         * Reset dashdash.
         */
        dashdash = NSF_FALSE;
      }

      valueObj = argumentObj;
    }

#if defined(PARSE_TRACE_FULL)
    fprintf(stderr, "... setting parameter %s pos %ld valueObj '%s'\n",
            pPtr->name, j,
            valueObj == argumentObj ? "=" : ObjStr(valueObj));
#endif

    /*
     * The value for the flag is now in the valueObj.  Verify that the value is
     * permitted.
     */
    assert(valueObj != NULL);

    if (unlikely(ArgumentCheck(interp, valueObj, pPtr, processFlags,
                               &pcPtr->flags[j],
                               &pcPtr->clientData[j],
                               &pcPtr->objv[j]) != TCL_OK)) {
      if (pcPtr->flags[j] & NSF_PC_MUST_DECR) {
        pcPtr->status |= NSF_PC_STATUS_MUST_DECR;
      }
      return TCL_ERROR;
    }

    /*
     * Switches are more tricky: If the flag is provided without
     * valueInArgument, invert the default.
     */
    if (likely(valueInArgument == NULL)) {
      if (unlikely(pPtr->converter == Nsf_ConvertToSwitch)) {
        /*fprintf(stderr, "... set INVERT_DEFAULT for '%s' flags %.6x\n",
          pPtr->name, pPtr->flags);*/
        assert(pPtr->defaultValue != NULL);
        pcPtr->flags[j] |= NSF_PC_INVERT_DEFAULT;
      }
    }

    /*fprintf(stderr, "... non-positional pcPtr %p check [%d] obj %p flags %.6x & %p\n",
      pcPtr, j, pcPtr->objv[j], pcPtr->flags[j], &(pcPtr->flags[j]));        */

    /*
     * Provide warnings for double-settings.
     */
    if (unlikely((pcPtr->flags[j] & NSF_ARG_SET) != 0u)) {
      Tcl_Obj *cmdLineObj = Tcl_NewListObj(objc-1, objv+1);

      INCR_REF_COUNT(cmdLineObj);
      NsfLog(interp, NSF_LOG_WARN, "Non-positional parameter %s was passed more than once (%s%s%s %s)",
             pPtr->name, (object != NULL) ? ObjectName(object) : "", (object != NULL) ? " method " : "",
             ObjStr(procNameObj), ObjStr(cmdLineObj));
      DECR_REF_COUNT(cmdLineObj);
    }
    pcPtr->flags[j] |= NSF_ARG_SET;

    /*
     * Embed error message of converter in current context.
     */
    if (unlikely((pcPtr->flags[j] & NSF_ARG_WARN) != 0u)) {
      Tcl_Obj *resultObj = Tcl_GetObjResult(interp);
      Tcl_DString ds, *dsPtr = &ds;

      Tcl_DStringInit(dsPtr);
      INCR_REF_COUNT(resultObj);
      NsfDStringArgv(dsPtr, objc, objv);
      NsfLog(interp, NSF_LOG_WARN, "%s during:\n%s %s",
             ObjStr(resultObj), (object != NULL) ? ObjectName(object) : "nsf::proc", Tcl_DStringValue(dsPtr));
      DECR_REF_COUNT(resultObj);
      Tcl_DStringFree(dsPtr);
    }

    if (unlikely((pcPtr->flags[j] & NSF_PC_MUST_DECR) != 0u)) {
      pcPtr->status |= NSF_PC_STATUS_MUST_DECR;
    }

    assert(!pcPtr->varArgs);

#if defined(PARSE_TRACE_FULL)
    fprintf(stderr, "... iterate on o %d objc %d, currentParamPtr %s\n",
            o, objc, currentParamPtr->name);
#endif
  }

  if ((currentParamPtr <= lastParamPtr) && (!pcPtr->varArgs)) {
    /*
     * Not all parameter processed.  Make sure varags is set.
     */

    /*fprintf(stderr, ".... not all parms processed, pPtr '%s' j %ld nrParams %d last '%s' varArgs %d dashdash %d\n",
            currentParamPtr->name, currentParamPtr - paramPtr, nrParams, lastParamPtr->name,
            pcPtr->varArgs, (int)dashdash);*/

    if (lastParamPtr->converter == ConvertToNothing) {
      pcPtr->varArgs = NSF_TRUE;
    }
  }

  /*
   * Set lastObjc as the index of the first "unprocessed" parameter.
   */
  pcPtr->lastObjc = o;
  pcPtr->objc = nrParams;

  /*
   * The index "pcPtr->lastObjc-1" might be "-1", which is a problem when
   * called via nsf::parseargs, where the allocated objv array starts at
   * position 0. It is fine when just a part of the real objv is passed to
   * ArgumentParse().
   *
   *     assert(ISOBJ(objv[pcPtr->lastObjc-1]));
   */

#if defined(PARSE_TRACE_FULL)
  fprintf(stderr, "..... argv processed o %d lastObjc %d nrParams %d o<objc %d varargs %d\n",
          o, pcPtr->lastObjc, nrParams, o<objc, pcPtr->varArgs);
#endif

  return ArgumentDefaults(pcPtr, interp, paramPtr, nrParams, processFlags);
}

/***********************************
 * Begin result setting commands
 * (essentially List*() and support
 ***********************************/
/*
 *----------------------------------------------------------------------
 * ListVarKeys --
 *
 *    Assigns the names of variables in of the given hash table to the interp
 *    result. If pattern is given it filters the result.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static int ListVarKeys(Tcl_Interp *interp, Tcl_HashTable *tablePtr, const char *pattern)
  nonnull(1);

static int
ListVarKeys(Tcl_Interp *interp, Tcl_HashTable *tablePtr, const char *pattern) {
  const Tcl_HashEntry *hPtr;

  nonnull_assert(interp != NULL);

  if (pattern != NULL && NoMetaChars(pattern)) {
    Tcl_Obj *patternObj = Tcl_NewStringObj(pattern, -1);

    INCR_REF_COUNT(patternObj);
    hPtr = (tablePtr != NULL) ? Tcl_CreateHashEntry(tablePtr, (char *)patternObj, NULL) : NULL;
    if (hPtr != NULL) {
      const Var *val = TclVarHashGetValue(hPtr);

      Tcl_SetObjResult(interp, TclVarHashGetKey(val));
    } else {
      Tcl_SetObjResult(interp, NsfGlobalObjs[NSF_EMPTY]);
    }
    DECR_REF_COUNT(patternObj);

  } else {
    Tcl_Obj       *list = Tcl_NewListObj(0, NULL);
    Tcl_HashSearch hSrch;

    hPtr = (tablePtr != NULL) ? Tcl_FirstHashEntry(tablePtr, &hSrch) : NULL;
    for (; hPtr != NULL; hPtr = Tcl_NextHashEntry(&hSrch)) {
      const Var *val = TclVarHashGetValue(hPtr);
      Tcl_Obj   *key = TclVarHashGetKey(val);

      if (pattern == NULL || Tcl_StringMatch(ObjStr(key), pattern)) {
        Tcl_ListObjAppendElement(interp, list, key);
      }
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 * GetOriginalCommand --
 *
 *    Obtains the original command of an an imported/aliased cmd.
 *
 * Results:
 *    A Tcl command.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static Tcl_Command
GetOriginalCommand(
    Tcl_Command cmd  /* The imported command for which the original
                      * command should be returned.
                      */
) {
  Tcl_Command importedCmd;

  nonnull_assert(cmd != NULL);

  while (1) {
    AliasCmdClientData *tcd;

    /*
     * Dereference the namespace import reference chain.
     */
    if ((importedCmd = TclGetOriginalCommand(cmd))) {
      cmd = importedCmd;
    }
    /*
     * Dereference the Next Scripting alias chain.
     */
    if (Tcl_Command_deleteProc(cmd) == AliasCmdDeleteProc) {
      tcd = (AliasCmdClientData *)Tcl_Command_objClientData(cmd);
      /*
        fprintf(stderr, "... GetOriginalCommand finds alias %s -> %s\n",
        Tcl_GetCommandName(NULL, cmd), Tcl_GetCommandName(NULL, tcd->aliasedCmd));
      */
      cmd = tcd->aliasedCmd;
      continue;
    }
    /*
     * Since the alias reference on the AliasCmdDeleteProc might be identified.
     * dereference the Next Scripting alias chain via potential proc contexts.
     */
    if (Tcl_Command_deleteProc(cmd) == NsfProcDeleteProc
       && Tcl_Command_objProc(cmd) == NsfProcAliasMethod) {
      NsfProcContext *ctxPtr = Tcl_Command_deleteData(cmd);

      if (ctxPtr->oldDeleteProc == AliasCmdDeleteProc) {
        tcd = (AliasCmdClientData *)Tcl_Command_objClientData(cmd);

        /*
           fprintf(stderr, "... GetOriginalCommand finds alias via oldDeleteProc %s -> %s (%p -> %p)\n",
           Tcl_GetCommandName(NULL, cmd), Tcl_GetCommandName(NULL, tcd->aliasedCmd),
           (void*)cmd, (void*)tcd->aliasedCmd  );
           char *name =Tcl_GetCommandName(NULL, cmd);
           if (!strcmp("incr", name)) {char *p = NULL; *p=1;}
        */

        cmd = tcd->aliasedCmd;
        continue;
      }
    }
    break;
  }

  return cmd;
}

/*
 *----------------------------------------------------------------------
 * ListProcBody --
 *
 *    Assigns the body of a scripted proc to the Tcl interp result.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static int ListProcBody(Tcl_Interp *interp, Proc *procPtr)
  nonnull(1) nonnull(2);

static int
ListProcBody(Tcl_Interp *interp, Proc *procPtr) {
  const char *body;

  nonnull_assert(interp != NULL);
  nonnull_assert(procPtr != NULL);

  body = ObjStr(procPtr->bodyPtr);
  Tcl_SetObjResult(interp, Tcl_NewStringObj(StripBodyPrefix(body), -1));
  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 * ListParamDefs --
 *
 *    Lists as the intepreter result the parameter definition in one of four
 *    different forms.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static Tcl_Obj *ListParamDefs(Tcl_Interp *interp, const Nsf_Param *paramsPtr,
                              NsfObject *contextObject, const char *pattern,
                              NsfParamsPrintStyle style)
  nonnull(1) nonnull(2) returns_nonnull;

static Tcl_Obj *
ListParamDefs(Tcl_Interp *interp, const Nsf_Param *paramsPtr,
              NsfObject *contextObject,  const char *pattern,
              NsfParamsPrintStyle style) {
  Tcl_Obj *listObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(paramsPtr != NULL);

  switch (style) {
  case NSF_PARAMS_PARAMETER: listObj = ParamDefsFormat(interp, paramsPtr, contextObject, pattern); break;
  case NSF_PARAMS_LIST:      listObj = ParamDefsList(interp, paramsPtr, contextObject, pattern);   break;
  case NSF_PARAMS_NAMES:     listObj = ParamDefsNames(interp, paramsPtr, contextObject, pattern);  break;
  case NSF_PARAMS_SYNTAX:    listObj = NsfParamDefsSyntax(interp, paramsPtr, contextObject, pattern); break;
  }

  return listObj;
}

/*
 *----------------------------------------------------------------------
 * ListCmdParams --
 *
 *    Obtains a cmd and a method name. As a side effect, sets the Tcl interp
 *    result to a list of parameter definitions, if available. The print-style
 *    NSF_PARAMS_NAMES, NSF_PARAMS_LIST, NSF_PARAMS_PARAMETER,
 *    NSF_PARAMS_SYNTAX controls the list content.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static int ListCmdParams(Tcl_Interp *interp, Tcl_Command cmd, NsfObject *contextObject,
                         const char *pattern, const char *methodName, NsfParamsPrintStyle printStyle)
  nonnull(1) nonnull(2) nonnull(5);

static int
ListCmdParams(Tcl_Interp *interp, Tcl_Command cmd,  NsfObject *contextObject,
                const char *pattern, const char *methodName, NsfParamsPrintStyle printStyle) {
  NsfParamDefs *paramDefs;
  Tcl_Obj      *listObj;
  Proc         *procPtr;
  int           result = TCL_OK;

  nonnull_assert(interp != NULL);
  nonnull_assert(methodName != NULL);
  nonnull_assert(cmd != NULL);

  paramDefs = ParamDefsGet(cmd, NULL, NULL);

  if (paramDefs != NULL && paramDefs->paramsPtr != NULL) {
    /*
     * Obtain parameter info from paramDefs.
     */
    listObj = ListParamDefs(interp, paramDefs->paramsPtr, contextObject, pattern, printStyle);
    Tcl_SetObjResult(interp, listObj);
    DECR_REF_COUNT2("paramDefsObj", listObj);
    return TCL_OK;
  }

  procPtr = GetTclProcFromCommand(cmd);
  if (procPtr != NULL) {
    /*
     * Obtain parameter info from compiled locals.
     */
    CompiledLocal *args = procPtr->firstLocalPtr;

    listObj = Tcl_NewListObj(0, NULL);
    for ( ; args; args = args->nextPtr) {

      if (!TclIsCompiledLocalArgument(args)) {
        continue;
      }
      if (pattern != NULL && !Tcl_StringMatch(args->name, pattern)) {
        continue;
      }

      if (printStyle == NSF_PARAMS_SYNTAX && strcmp(args->name, "args") == 0) {
        if (args != procPtr->firstLocalPtr) {
          Tcl_AppendToObj(listObj, " ", 1);
        }
        Tcl_AppendToObj(listObj, "?/arg .../?", 11);
      } else {
        if (printStyle == NSF_PARAMS_SYNTAX) {
          /*
           * A default means that the argument is optional.
           */
          if (args->defValuePtr != NULL) {
            Tcl_AppendToObj(listObj, "?", 1);
            Tcl_AppendToObj(listObj, args->name, -1);
            Tcl_AppendToObj(listObj, "?", 1);
          } else {
            Tcl_AppendToObj(listObj, "/", 1);
            Tcl_AppendToObj(listObj, args->name, -1);
            Tcl_AppendToObj(listObj, "/", 1);
          }
          if (args->nextPtr != NULL) {
            Tcl_AppendToObj(listObj, " ", 1);
          }
        } else {
          Tcl_Obj *innerListObj = Tcl_NewListObj(0, NULL);

          Tcl_ListObjAppendElement(interp, innerListObj, Tcl_NewStringObj(args->name, -1));
          /*
           * Return the default for NSF_PARAMS_PARAMETER only.
           */
          if ((args->defValuePtr != NULL) && (printStyle == NSF_PARAMS_PARAMETER)) {
            Tcl_ListObjAppendElement(interp, innerListObj, args->defValuePtr);
          }
          Tcl_ListObjAppendElement(interp, listObj, innerListObj);
        }
      }
    }

    Tcl_SetObjResult(interp, listObj);
    return TCL_OK;
  }

  {
    /*
     * If a command is not found for the object|class, look for parameter
     * definitions for the C-defined method.
     */
    Nsf_methodDefinition *mdPtr = Nsf_CmdDefinitionGet(((Command *)cmd)->objProc);
    if (mdPtr != NULL) {
      NsfParamDefs localParamDefs = {mdPtr->paramDefs, mdPtr->nrParameters, 1, 0};
      Tcl_Obj     *list = ListParamDefs(interp, localParamDefs.paramsPtr, contextObject, pattern, printStyle);

      Tcl_SetObjResult(interp, list);
      DECR_REF_COUNT2("paramDefsObj", list);
      return TCL_OK;
    }
  }

  if (((Command *)cmd)->objProc == NsfSetterMethod) {
    SetterCmdClientData *cd = (SetterCmdClientData *)Tcl_Command_objClientData(cmd);

    if (cd != NULL && cd->paramsPtr) {
      NsfParamDefs localParamDefs;
      Tcl_Obj     *list;

      localParamDefs.paramsPtr = cd->paramsPtr;
      /*localParamDefs.nrParams = 1;*/
      list = ListParamDefs(interp, localParamDefs.paramsPtr, contextObject, pattern, printStyle);
      Tcl_SetObjResult(interp, list);
      DECR_REF_COUNT2("paramDefsObj", list);
    } else {
      Tcl_SetObjResult(interp, Tcl_NewStringObj(methodName, -1));
    }
    return TCL_OK;
  }

  /*
   * If there is no result so far, try to use the definitions of the
   * object-system implementors in the array ::nsf::parametersyntax. This is
   * the only way to obtain the parameter syntax.
   */
  if (printStyle == NSF_PARAMS_SYNTAX) {
    Tcl_DString ds, *dsPtr = &ds;
    Tcl_Obj *parameterSyntaxObj;

    Tcl_DStringInit(dsPtr);
    DStringAppendQualName(dsPtr, Tcl_Command_nsPtr(cmd), methodName);
    /*fprintf(stderr, "Looking up ::nsf::parametersyntax(%s) ...\n", Tcl_DStringValue(dsPtr));*/
    parameterSyntaxObj = Tcl_GetVar2Ex(interp, NsfGlobalStrings[NSF_ARRAY_PARAMETERSYNTAX],
                                       Tcl_DStringValue(dsPtr), TCL_GLOBAL_ONLY);

    /*fprintf(stderr, "No parametersyntax so far methodName %s cmd name %s ns %s\n",
      methodName, Tcl_GetCommandName(interp, cmd), Tcl_DStringValue(dsPtr));*/

    Tcl_DStringFree(dsPtr);
    if (parameterSyntaxObj != NULL) {
      Tcl_SetObjResult(interp, parameterSyntaxObj);
      return TCL_OK;
    }
  }

  if (Tcl_Command_objProc(cmd) == NsfForwardMethod) {
    result = NsfPrintError(interp, "could not obtain parameter definition for forwarder '%s'",
                           methodName);

  } else if (CmdIsNsfObject(cmd)) {
    /* procPtr == NsfObjDispatch:

       Reached for:
       ... ensemble objects
       ... plain objects
     */
  } else if (Tcl_Command_objProc(cmd) == NsfProcStub) {
    /*
     * Reached for C-implemented Tcl command procs.
     */

  } else {
    /*
     * Reached for other C-implemented command procs.
     */
    result = NsfPrintError(interp, "could not obtain parameter definition for method '%s'", methodName);
  }
  return result;
}


/*
 *----------------------------------------------------------------------
 * AppendForwardDefinition --
 *
 *    Appends the parameters of a forward definition to the given listObj.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static void AppendForwardDefinition(Tcl_Interp *interp, Tcl_Obj *listObj, ForwardCmdClientData *tcd)
  nonnull(1) nonnull(2) nonnull(3);

static void
AppendForwardDefinition(Tcl_Interp *interp, Tcl_Obj *listObj, ForwardCmdClientData *tcd) {

  nonnull_assert(interp != NULL);
  nonnull_assert(listObj != NULL);
  nonnull_assert(tcd != NULL);

  if (tcd->prefix != NULL) {
    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewStringObj("-prefix", -1));
    Tcl_ListObjAppendElement(interp, listObj, tcd->prefix);
  }
  if (tcd->subcommands != NULL) {
    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewStringObj("-default", -1));
    Tcl_ListObjAppendElement(interp, listObj, tcd->subcommands);
  }
  if (tcd->objProc != NULL) {
    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewStringObj("-earlybinding", -1));
  }
  if (tcd->frame == FrameObjectIdx) {
    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewStringObj("-frame", 6));
    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewStringObj("object", 6));
  }
  Tcl_ListObjAppendElement(interp, listObj, tcd->cmdName);

  if (tcd->args != NULL) {
    Tcl_Obj **args;
    int nrArgs, i;

    Tcl_ListObjGetElements(interp, tcd->args, &nrArgs, &args);
    for (i = 0; i < nrArgs; i++) {
      Tcl_ListObjAppendElement(interp, listObj, args[i]);
    }
  }
}

/*
 *----------------------------------------------------------------------
 * AppendMethodRegistration --
 *
 *    Appends to listObj the command words needed for definition /
 *    registration.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static void AppendMethodRegistration(Tcl_Interp *interp, Tcl_Obj *listObj, const char *registerCmdName,
                                     NsfObject *object, const char *methodName, Tcl_Command cmd,
                                     bool withObjFrame, bool withPer_object, int withProtection)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4) nonnull(5) nonnull(6);

static void
AppendMethodRegistration(Tcl_Interp *interp, Tcl_Obj *listObj, const char *registerCmdName,
                         NsfObject *object, const char *methodName, Tcl_Command cmd,
                         bool withObjFrame, bool withPer_object, int withProtection) {

  nonnull_assert(interp != NULL);
  nonnull_assert(listObj != NULL);
  nonnull_assert(registerCmdName != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodName != NULL);
  nonnull_assert(cmd != NULL);

  Tcl_ListObjAppendElement(interp, listObj, object->cmdName);
  if (withProtection != CallprotectionNULL) {
    Tcl_ListObjAppendElement(interp, listObj,
                             (((unsigned int)Tcl_Command_flags(cmd) & NSF_CMD_CALL_PRIVATE_METHOD) != 0)
                             ? Tcl_NewStringObj("private", 7)
                             : (((unsigned int)Tcl_Command_flags(cmd) & NSF_CMD_CALL_PROTECTED_METHOD) != 0)
                             ? Tcl_NewStringObj("protected", 9)
                             : Tcl_NewStringObj("public", 6));
  }

  if (!NsfObjectIsClass(object) || withPer_object) {
    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewStringObj("object", 6));
  }
  Tcl_ListObjAppendElement(interp, listObj, Tcl_NewStringObj(registerCmdName, -1));
  Tcl_ListObjAppendElement(interp, listObj, Tcl_NewStringObj(methodName, -1));

  if (withObjFrame) {
    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewStringObj("-frame", 6));
    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewStringObj("object", 6));
  }
  if (((unsigned int)Tcl_Command_flags(cmd) & NSF_CMD_NONLEAF_METHOD) != 0) {
    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewStringObj("-frame", 6));
    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewStringObj("method", 6));
  }
}

/*
 *----------------------------------------------------------------------
 * AppendReturnsClause --
 *
 *    Appends to the listObj a "returns" clause if it there is one for the
 *    current cmd.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static void AppendReturnsClause(Tcl_Interp *interp, Tcl_Obj *listObj, Tcl_Command cmd)
  nonnull(1) nonnull(2) nonnull(3);

static void
AppendReturnsClause(Tcl_Interp *interp, Tcl_Obj *listObj, Tcl_Command cmd) {
  Tcl_Obj *returnsObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(listObj != NULL);
  nonnull_assert(cmd != NULL);

  returnsObj = ParamDefsGetReturns(cmd);
  if (returnsObj != NULL) {
    /* TODO: avoid hard-coding the script-level/NX-specific keyword "-returns" */
    Tcl_ListObjAppendElement(interp, listObj, Tcl_NewStringObj("-returns", -1));
    Tcl_ListObjAppendElement(interp, listObj, returnsObj);
  }
}

static Tcl_Obj *DisassembleProc(Tcl_Interp *interp, Proc *procPtr,
                                const char *procName, Namespace *nsPtr)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

static Tcl_Obj *DisassembleProc(Tcl_Interp *interp, Proc *procPtr,
                                const char *procName, Namespace *nsPtr) {
  unsigned int dummy = 0;
  Tcl_Obj *byteCodeObj = NULL;

  if ((procPtr->bodyPtr->typePtr == Nsf_OT_byteCodeType) ||
      (ByteCompiled(interp, &dummy, procPtr, nsPtr, procName) == TCL_OK)) {
    Tcl_Obj *ov[3];

    ov[0] = NULL;
    ov[1] = NsfGlobalObjs[NSF_SCRIPT];
    ov[2] = procPtr->bodyPtr;

    if ((NsfCallCommand(interp, NSF_DISASSEMBLE, 3, ov) == TCL_OK)) {
      byteCodeObj = Tcl_GetObjResult(interp);
    }
  }

  return byteCodeObj;
}



/*
 *----------------------------------------------------------------------
 * ListMethod --
 *
 *    Constructs a command to regenerate the named method and assigns the
 *    result as the interpreter result. The method might be scripted or not,
 *    e.g. alias, forwarder, etc.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static int ListMethod(Tcl_Interp *interp,
                      NsfObject *regObject,
                      NsfObject *defObject,
                      const char *methodName,
                      Tcl_Command cmd,
                      InfomethodsubcmdIdx_t subcmd,
                      NsfObject *contextObject,
                      const char *pattern,
                      bool withPer_object)
  nonnull(1) nonnull(4) nonnull(5);

static int ListDefinedMethods(Tcl_Interp *interp, NsfObject *object, const char *pattern,
                              bool withPer_object,
                              MethodtypeIdx_t methodType,
                              CallprotectionIdx_t withCallprotection,
                              bool withPath)
  nonnull(1) nonnull(2);

static int
ListMethod(Tcl_Interp *interp,
           NsfObject *regObject,
           NsfObject *defObject,
           const char *methodName,
           Tcl_Command cmd,
           InfomethodsubcmdIdx_t subcmd,
           NsfObject *contextObject,
           const char *pattern,
           bool withPer_object) {

  Tcl_ObjCmdProc *objCmdProc;
  Proc           *procPtr;
  bool            outputPerObject;
  Tcl_Obj        *resultObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(methodName != NULL);
  nonnull_assert(cmd != NULL);

  assert(*methodName != ':');

  Tcl_ResetResult(interp);

  if (regObject != NULL && !NsfObjectIsClass(regObject)) {
    withPer_object = 1;
    /*
     * Don't output "object" modifier if regObject is not a class.
     */
    outputPerObject = NSF_FALSE;
  } else {
    outputPerObject = withPer_object;
  }

  switch (subcmd) {
  case InfomethodsubcmdRegistrationhandleIdx:
    {
      if (regObject != NULL) {
        Tcl_SetObjResult(interp, MethodHandleObj(regObject, withPer_object, methodName));
      }
      return TCL_OK;
    }
  case InfomethodsubcmdDefinitionhandleIdx:
    {
      if (defObject != NULL) {
        Tcl_SetObjResult(interp, MethodHandleObj(defObject,
                                                 NsfObjectIsClass(defObject) ? withPer_object : 1,
                                                 Tcl_GetCommandName(interp, cmd)));
      }
      return TCL_OK;
    }
  case InfomethodsubcmdExistsIdx:
    {
      Tcl_SetObjResult(interp, Tcl_NewIntObj((int)(!CmdIsNsfObject(cmd))));
      return TCL_OK;
    }
  case InfomethodsubcmdArgsIdx:
    {
      Tcl_Command importedCmd = GetOriginalCommand(cmd);
      return ListCmdParams(interp, importedCmd, contextObject, pattern, methodName, NSF_PARAMS_NAMES);
    }
  case InfomethodsubcmdParameterIdx:
    {
      Tcl_Command importedCmd = GetOriginalCommand(cmd);
      return ListCmdParams(interp, importedCmd, contextObject, pattern, methodName, NSF_PARAMS_PARAMETER);
    }
  case InfomethodsubcmdReturnsIdx:
    {
      Tcl_Obj *returnsObj = ParamDefsGetReturns(GetOriginalCommand(cmd));

      if (returnsObj != NULL) {
        Tcl_SetObjResult(interp, returnsObj);
      }
      return TCL_OK;
    }
  case InfomethodsubcmdSyntaxIdx:
    {
      Tcl_Command importedCmd = GetOriginalCommand(cmd);
      return ListCmdParams(interp, importedCmd, contextObject, pattern, methodName, NSF_PARAMS_SYNTAX);
    }

  case InfomethodsubcmdPreconditionIdx:
#if defined(NSF_WITH_ASSERTIONS)
      if (regObject != NULL) {
        NsfProcAssertion *procs = NULL;

        if (withPer_object == 1) {
          if (regObject->opt != NULL && regObject->opt->assertions != NULL) {
            procs = AssertionFindProcs(regObject->opt->assertions, methodName);
          }
        } else {
          NsfClass *class = (NsfClass *)regObject;
          if (class->opt != NULL && class->opt->assertions != NULL) {
            procs = AssertionFindProcs(class->opt->assertions, methodName);
          }
        }
        if (procs != NULL) {
          Tcl_SetObjResult(interp, AssertionList(interp, procs->pre));
        }
      }
#endif
      return TCL_OK;


  case InfomethodsubcmdPostconditionIdx:
#if defined(NSF_WITH_ASSERTIONS)
      if (regObject != NULL) {
        NsfProcAssertion *procs = NULL;

        if (withPer_object == 1) {
          if (regObject->opt != NULL && regObject->opt->assertions != NULL) {
            procs = AssertionFindProcs(regObject->opt->assertions, methodName);
          }
        } else {
          NsfClass *class = (NsfClass *)regObject;
          if (class->opt != NULL && class->opt->assertions != NULL) {
            procs = AssertionFindProcs(class->opt->assertions, methodName);
          }
        }
        if (procs != NULL) {
          Tcl_SetObjResult(interp, AssertionList(interp, procs->post));
        }
      }
#endif
      return TCL_OK;

  case InfomethodsubcmdSubmethodsIdx:
    {
      Tcl_Command origCmd = GetOriginalCommand(cmd);

      if (CmdIsNsfObject(origCmd)) {
        NsfObject *subObject = NsfGetObjectFromCmdPtr(origCmd);
        if (subObject != NULL) {
          return ListDefinedMethods(interp, subObject, NULL, NSF_TRUE /* per-object */,
                                    NSF_METHODTYPE_ALL, CallprotectionAllIdx, NSF_FALSE);
        }
      }
      /*
       * All other cases return empty.
       */
      Tcl_SetObjResult(interp, NsfGlobalObjs[NSF_EMPTY]);
      return TCL_OK;
    }

  case InfomethodsubcmdBodyIdx:        NSF_FALL_THROUGH; /* fall through */
  case InfomethodsubcmdOriginIdx:      NSF_FALL_THROUGH; /* fall through */
  case InfomethodsubcmdTypeIdx:        NSF_FALL_THROUGH; /* fall through */
  case InfomethodsubcmdDefinitionIdx:  NSF_FALL_THROUGH; /* fall through */
  case InfomethodsubcmdDisassembleIdx: NSF_FALL_THROUGH; /* fall through */
  case InfomethodsubcmdNULL:
    break;
  }

  objCmdProc = Tcl_Command_objProc(cmd);
  procPtr = GetTclProcFromCommand(cmd);

  /*
   * The subcommands differ for each type of method. The converter in
   * InfoMethods defines the types:
   *
   *    all|scripted|builtin|alias|forwarder|object|setter|nsfproc
   */
  if (procPtr != NULL) {
    /*
     * A scripted method.
     */
    switch (subcmd) {

    case InfomethodsubcmdTypeIdx:
      if (regObject != NULL) {
        Tcl_SetObjResult(interp, Tcl_NewStringObj("scripted", -1));
      } else {
        Tcl_SetObjResult(interp, Tcl_NewStringObj("proc", -1));
      }
      break;

    case InfomethodsubcmdBodyIdx:
      ListProcBody(interp, procPtr);
      break;

    case InfomethodsubcmdDisassembleIdx:
    {
      Tcl_Namespace *nsPtr;
      NsfParamDefs  *paramDefs;

      paramDefs = ParamDefsGet(cmd, NULL, &nsPtr);

      if (paramDefs == NULL || nsPtr == NULL) {
        nsPtr = (Tcl_Namespace *)procPtr->cmdPtr->nsPtr;
      }

      resultObj = DisassembleProc(interp, procPtr, methodName,
                                  (Namespace *)nsPtr);

      if (resultObj != NULL) {
        Tcl_SetObjResult(interp, resultObj);
      }
    }
    break;
    case InfomethodsubcmdDefinitionIdx:
      {
        resultObj = Tcl_NewListObj(0, NULL);

        /* todo: don't hard-code registering command name "method" / NSF_METHOD */
        if (regObject != NULL) {
          AppendMethodRegistration(interp, resultObj, NsfGlobalStrings[NSF_METHOD],
                                   regObject, methodName, cmd, NSF_FALSE, outputPerObject, 1);
        } else {
          Tcl_DString ds, *dsPtr = &ds;

          Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj("::proc", -1));

          Tcl_DStringInit(dsPtr);
          DStringAppendQualName(dsPtr, Tcl_Command_nsPtr(cmd), methodName);
          Tcl_ListObjAppendElement(interp, resultObj,
                                   Tcl_NewStringObj(Tcl_DStringValue(dsPtr),
                                                    Tcl_DStringLength(dsPtr)));
          Tcl_DStringFree(dsPtr);
        }
        ListCmdParams(interp, cmd, contextObject, NULL, methodName, NSF_PARAMS_PARAMETER);
        Tcl_ListObjAppendElement(interp, resultObj, Tcl_GetObjResult(interp));

        AppendReturnsClause(interp, resultObj, cmd);

        ListProcBody(interp, procPtr);
        Tcl_ListObjAppendElement(interp, resultObj, Tcl_GetObjResult(interp));

#if defined(NSF_WITH_ASSERTIONS)
        if (regObject != NULL) {
          NsfAssertionStore *assertions;

          if (withPer_object == 1) {
            assertions = (regObject->opt != NULL) ? regObject->opt->assertions : NULL;
          } else {
            NsfClass *class = (NsfClass *)regObject;
            assertions = (class->opt != NULL) ? class->opt->assertions : NULL;
          }

          if (assertions != NULL) {
            NsfProcAssertion *procs = AssertionFindProcs(assertions, methodName);
            if (procs != NULL) {
              Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj("-precondition", -1));
              Tcl_ListObjAppendElement(interp, resultObj, AssertionList(interp, procs->pre));
              Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj("-postcondition", -1));
              Tcl_ListObjAppendElement(interp, resultObj, AssertionList(interp, procs->post));
            }
          }
        }
#endif
        Tcl_SetObjResult(interp, resultObj);
        break;
      }
    case InfomethodsubcmdArgsIdx:               NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdDefinitionhandleIdx:   NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdExistsIdx:             NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdOriginIdx:             NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdParameterIdx:          NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdPostconditionIdx:      NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdPreconditionIdx:       NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdRegistrationhandleIdx: NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdReturnsIdx:            NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdSubmethodsIdx:         NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdSyntaxIdx:             NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdNULL:
    break;
    }

  } else if (objCmdProc == NsfForwardMethod) {
    /*
     * The command is a forwarder.
     */
    switch (subcmd) {
    case InfomethodsubcmdTypeIdx:
      Tcl_SetObjResult(interp, NsfGlobalObjs[NSF_FORWARD]);
      break;
    case InfomethodsubcmdDefinitionIdx:
      if (regObject != NULL) {
        ClientData clientData;

        clientData = Tcl_Command_objClientData(cmd);
        if (clientData != NULL) {
          resultObj = Tcl_NewListObj(0, NULL);
          /* todo: don't hard-code registering command name "forward" / NSF_FORWARD*/
          AppendMethodRegistration(interp, resultObj, NsfGlobalStrings[NSF_FORWARD],
                                   regObject, methodName, cmd, NSF_FALSE, outputPerObject, 1);
          AppendReturnsClause(interp, resultObj, cmd);

          AppendForwardDefinition(interp, resultObj, clientData);
          Tcl_SetObjResult(interp, resultObj);
        }
      }
      break;
    case InfomethodsubcmdArgsIdx:                NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdBodyIdx:                NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdDefinitionhandleIdx:    NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdExistsIdx:              NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdOriginIdx:              NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdParameterIdx:           NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdPostconditionIdx:       NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdPreconditionIdx:        NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdRegistrationhandleIdx:  NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdReturnsIdx:             NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdSubmethodsIdx:          NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdSyntaxIdx:              NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdDisassembleIdx:         NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdNULL:
      break;
    }

  } else if (objCmdProc == NsfSetterMethod) {
    /*
     * The cmd is one of the setter methods.
     */
    switch (subcmd) {
    case InfomethodsubcmdTypeIdx:
      Tcl_SetObjResult(interp, NsfGlobalObjs[NSF_SETTER]);
      break;
    case InfomethodsubcmdDefinitionIdx:
      if (regObject != NULL) {
        SetterCmdClientData *cd = (SetterCmdClientData *)Tcl_Command_objClientData(cmd);

        resultObj = Tcl_NewListObj(0, NULL);
        /* todo: don't hard-code registering command name "setter" / NSF_SETTER */
        AppendMethodRegistration(interp, resultObj, NsfGlobalStrings[NSF_SETTER], regObject,
                                 (cd != NULL && cd->paramsPtr) ? ObjStr(cd->paramsPtr->paramObj) : methodName,
                                 cmd, NSF_FALSE, outputPerObject, 1);
        Tcl_SetObjResult(interp, resultObj);
      }
      break;
    case InfomethodsubcmdArgsIdx:                NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdBodyIdx:                NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdDefinitionhandleIdx:    NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdExistsIdx:              NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdOriginIdx:              NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdParameterIdx:           NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdPostconditionIdx:       NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdPreconditionIdx:        NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdRegistrationhandleIdx:  NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdReturnsIdx:             NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdSubmethodsIdx:          NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdSyntaxIdx:              NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdDisassembleIdx:         NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdNULL:
      break;
    }
  } else if (objCmdProc == NsfProcStub) {
    /*
     * Special nsfproc handling:
     */
    NsfProcClientData *tcd = Tcl_Command_objClientData(cmd);

    if (tcd != NULL && tcd->procName) {
      Tcl_Command  procCmd = Tcl_GetCommandFromObj(interp, tcd->procName);
      Proc         *tProcPtr = GetTclProcFromCommand(procCmd);
      Tcl_DString  ds, *dsPtr = &ds;

      switch (subcmd) {

      case InfomethodsubcmdTypeIdx:
        Tcl_SetObjResult(interp, Tcl_NewStringObj("nsfproc", -1));
        break;

      case InfomethodsubcmdBodyIdx:
        ListProcBody(interp, tProcPtr);
        break;

      case InfomethodsubcmdDefinitionIdx:
        resultObj = Tcl_NewListObj(0, NULL);
        Tcl_DStringInit(dsPtr);
        DStringAppendQualName(dsPtr, Tcl_Command_nsPtr(cmd), methodName);
        /* don't hardcode names */
        Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj("::nsf::proc", -1));
        if ((tcd->flags & NSF_PROC_FLAG_AD) != 0) {
          Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj("-ad", 3));
        }
        if (((unsigned int)Tcl_Command_flags(tcd->wrapperCmd) & NSF_CMD_DEBUG_METHOD) != 0) {
          Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj("-debug", 6));
        }
        if (((unsigned int)Tcl_Command_flags(tcd->wrapperCmd) & NSF_CMD_DEPRECATED_METHOD) != 0) {
          Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj("-deprecated", 11));
        }

        Tcl_ListObjAppendElement(interp, resultObj,
                                 Tcl_NewStringObj(Tcl_DStringValue(dsPtr),
                                                  Tcl_DStringLength(dsPtr)));
        ListCmdParams(interp, cmd, NULL, NULL, Tcl_DStringValue(dsPtr), NSF_PARAMS_PARAMETER);
        Tcl_ListObjAppendElement(interp, resultObj, Tcl_GetObjResult(interp));
        ListProcBody(interp, tProcPtr);
        Tcl_ListObjAppendElement(interp, resultObj, Tcl_GetObjResult(interp));
        Tcl_SetObjResult(interp, resultObj);
        Tcl_DStringFree(dsPtr);
        break;
      case InfomethodsubcmdDisassembleIdx:

        resultObj = DisassembleProc(interp, tProcPtr, methodName,
                                    tProcPtr->cmdPtr->nsPtr);

        if (resultObj != NULL) {
          Tcl_SetObjResult(interp, resultObj);
        }
        break;
      case InfomethodsubcmdArgsIdx:                NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdDefinitionhandleIdx:    NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdExistsIdx:              NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdOriginIdx:              NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdParameterIdx:           NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdPostconditionIdx:       NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdPreconditionIdx:        NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdRegistrationhandleIdx:  NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdReturnsIdx:             NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdSubmethodsIdx:          NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdSyntaxIdx:              NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdNULL:
        break;
      }
    }

  } else if (defObject != NULL) {
    /*
     * The cmd must be an alias or object.
     *
     * Some aliases come with objCmdProc == NsfObjDispatch.  In order to
     * distinguish between "object" and alias, do the lookup for the entryObj
     * to determine whether it is really an alias.
     */
    Tcl_Obj *entryObj;

    entryObj = AliasGet(interp, defObject->cmdName,
                        Tcl_GetCommandName(interp, cmd),
                        regObject != defObject ? NSF_TRUE : withPer_object, NSF_FALSE);
    /*
      fprintf(stderr, "aliasGet %s -> %s/%s (%d) returned %p\n",
      ObjectName(defObject), methodName, Tcl_GetCommandName(interp, cmd),
      withPer_object, entryObj);
      fprintf(stderr, "... regObject %p %s\n", regObject, ObjectName(regObject));
      fprintf(stderr, "... defObject %p %s\n", defObject, ObjectName(defObject));
    */

    if (entryObj != NULL) {
      /*
       * The entry is an alias.
       */
      switch (subcmd) {
      case InfomethodsubcmdTypeIdx:
        Tcl_SetObjResult(interp, NsfGlobalObjs[NSF_ALIAS]);
        break;
      case InfomethodsubcmdDefinitionIdx:
        if (regObject != NULL) {
          int nrElements;
          Tcl_Obj **listElements;

          resultObj = Tcl_NewListObj(0, NULL);
          Tcl_ListObjGetElements(interp, entryObj, &nrElements, &listElements);
          /* todo: don't hard-code registering command name "alias" / NSF_ALIAS */
          AppendMethodRegistration(interp, resultObj, NsfGlobalStrings[NSF_ALIAS],
                                   regObject, methodName, cmd,
                                   objCmdProc == NsfObjscopedMethod,
                                   outputPerObject, 1);
          AppendReturnsClause(interp, resultObj, cmd);
          Tcl_ListObjAppendElement(interp, resultObj, listElements[nrElements-1]);
          Tcl_SetObjResult(interp, resultObj);
        }
        break;

      case InfomethodsubcmdOriginIdx:
        {
          int nrElements;
          Tcl_Obj **listElements;
          Tcl_ListObjGetElements(interp, entryObj, &nrElements, &listElements);
          Tcl_SetObjResult(interp, listElements[nrElements-1]);
          break;
        }

      case InfomethodsubcmdArgsIdx:                NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdBodyIdx:                NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdDefinitionhandleIdx:    NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdExistsIdx:              NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdParameterIdx:           NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdPostconditionIdx:       NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdPreconditionIdx:        NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdRegistrationhandleIdx:  NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdReturnsIdx:             NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdSubmethodsIdx:          NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdSyntaxIdx:              NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdDisassembleIdx:         NSF_FALL_THROUGH; /* fall through */
      case InfomethodsubcmdNULL:
        break;
      }
    } else {
      /*
       * To be on the safe side, determine whether the command is an nsfObject.
       */
      if (CmdIsNsfObject(cmd)) {
        switch (subcmd) {
        case InfomethodsubcmdTypeIdx:
          Tcl_SetObjResult(interp, Tcl_NewStringObj("object", -1));
          break;
        case InfomethodsubcmdDefinitionIdx:
          {
            NsfObject *subObject = NsfGetObjectFromCmdPtr(cmd);

            assert(subObject != NULL);
            resultObj = Tcl_NewListObj(0, NULL);
            AppendMethodRegistration(interp, resultObj, "create",
                                     &(subObject->cl)->object,
                                     ObjStr(subObject->cmdName), cmd,
                                     NSF_FALSE, NSF_FALSE, 0);
            Tcl_SetObjResult(interp, resultObj);
            break;
          }

        case InfomethodsubcmdArgsIdx:                NSF_FALL_THROUGH; /* fall through */
        case InfomethodsubcmdBodyIdx:                NSF_FALL_THROUGH; /* fall through */
        case InfomethodsubcmdDefinitionhandleIdx:    NSF_FALL_THROUGH; /* fall through */
        case InfomethodsubcmdExistsIdx:              NSF_FALL_THROUGH; /* fall through */
        case InfomethodsubcmdParameterIdx:           NSF_FALL_THROUGH; /* fall through */
        case InfomethodsubcmdPostconditionIdx:       NSF_FALL_THROUGH; /* fall through */
        case InfomethodsubcmdPreconditionIdx:        NSF_FALL_THROUGH; /* fall through */
        case InfomethodsubcmdRegistrationhandleIdx:  NSF_FALL_THROUGH; /* fall through */
        case InfomethodsubcmdReturnsIdx:             NSF_FALL_THROUGH; /* fall through */
        case InfomethodsubcmdSubmethodsIdx:          NSF_FALL_THROUGH; /* fall through */
        case InfomethodsubcmdSyntaxIdx:              NSF_FALL_THROUGH; /* fall through */
        case InfomethodsubcmdOriginIdx:              NSF_FALL_THROUGH; /* fall through */
        case InfomethodsubcmdDisassembleIdx:         NSF_FALL_THROUGH; /* fall through */
        case InfomethodsubcmdNULL:
          break;
        }
      } else {
        /*
         * Should never happen.
         *
         * The warning is just a guess, so don't raise an error here.
         */
        NsfLog(interp, NSF_LOG_WARN, "Could not obtain alias definition for %s. "
               "Maybe someone deleted the alias %s for object %s?",
               methodName, methodName, ObjectName(regObject));
        Tcl_ResetResult(interp);
      }
    }
  } else {
    /*
     * The cmd must be a plain unregistered cmd.
     */
    switch (subcmd) {
    case InfomethodsubcmdTypeIdx:
      Tcl_SetObjResult(interp, NsfGlobalObjs[NSF_CMD]);
      break;
    case InfomethodsubcmdDefinitionIdx:
      break;
    case InfomethodsubcmdOriginIdx:
      break;

    case InfomethodsubcmdArgsIdx:                NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdBodyIdx:                NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdDefinitionhandleIdx:    NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdExistsIdx:              NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdParameterIdx:           NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdPostconditionIdx:       NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdPreconditionIdx:        NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdRegistrationhandleIdx:  NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdReturnsIdx:             NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdSubmethodsIdx:          NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdSyntaxIdx:              NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdDisassembleIdx:         NSF_FALL_THROUGH; /* fall through */
    case InfomethodsubcmdNULL:
      break;
    }
  }

  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 * ListMethodResolve --
 *
 *    Calls ListMethod(), but attempts to resolve the method name/handle first.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int
ListMethodResolve(Tcl_Interp *interp, InfomethodsubcmdIdx_t subcmd,
                  NsfObject *contextObject, const char *pattern,
                  Tcl_Namespace *nsPtr, NsfObject *object,
                  Tcl_Obj *methodNameObj, bool fromClassNS)
  nonnull(1) nonnull(7);

static int
ListMethodResolve(Tcl_Interp *interp, InfomethodsubcmdIdx_t subcmd,
                  NsfObject *contextObject, const char *pattern,
                  Tcl_Namespace *nsPtr, NsfObject *object,
                  Tcl_Obj *methodNameObj, bool fromClassNS) {
  NsfObject   *regObject, *defObject;
  const char  *methodName1 = NULL;
  int          result = TCL_OK;
  Tcl_DString  ds, *dsPtr = &ds;
  Tcl_Command  cmd;

  nonnull_assert(interp != NULL);
  nonnull_assert(methodNameObj != NULL);

  Tcl_DStringInit(dsPtr);

  cmd = ResolveMethodName(interp, nsPtr, methodNameObj,
                          dsPtr, &regObject, &defObject, &methodName1, &fromClassNS);
  /*
   * If the cmd is not found, return empty, but for the "exists" sub-command
   * return 0.
   */
  if (likely(cmd != NULL)) {

    result = ListMethod(interp, (regObject != NULL) ? regObject : object, (defObject != NULL) ? defObject : object,
                        methodName1, cmd, subcmd,
                        contextObject, pattern, (fromClassNS == 0));

  } else if (subcmd == InfomethodsubcmdExistsIdx) {
    Tcl_SetObjResult(interp, Tcl_NewIntObj(0));
  }

  Tcl_DStringFree(dsPtr);
  return result;
}


/*
 *----------------------------------------------------------------------
 * MethodSourceMatches --
 *
 *    True if the given class or object (mutually exclusive) matches
 *    with the required method source (typically all|application|system).
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static bool MethodSourceMatches(DefinitionsourceIdx_t withSource, NsfClass *class, NsfObject *object) NSF_pure;

static bool MethodSourceMatches(DefinitionsourceIdx_t withSource, NsfClass *class, NsfObject *object) {
  bool result;

  if (withSource == DefinitionsourceAllIdx) {
    result = NSF_TRUE;

  } else if (class == NULL) {
    /*
     * If the method is object-specific, it can't be from a baseclass and must
     * be application-specific.
     */
    assert(object != NULL);
    result = (withSource == DefinitionsourceApplicationIdx && !IsBaseClass(object));

  } else {
    bool isBaseClass;

    assert(class != NULL);

    isBaseClass = IsBaseClass(&class->object);
    if (withSource == DefinitionsourceSystemIdx && isBaseClass) {
      result = NSF_TRUE;
    } else if (withSource == DefinitionsourceApplicationIdx && !isBaseClass) {
      result = NSF_TRUE;
    } else {
      result = NSF_FALSE;
    }
  }
  return result;
}


/*
 *----------------------------------------------------------------------
 * MethodTypeMatches --
 *
 *    True if the given command for a method matches the required method type,
 *    typically all|scripted|builtin|alias|forwarder|object|setter.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

static bool MethodTypeMatches(Tcl_Interp *interp, MethodtypeIdx_t methodType, Tcl_Command cmd,
                              NsfObject *object, const char *methodName, int withPer_object,
                              bool *isObject)
  nonnull(1) nonnull(3) nonnull(5) nonnull(7);

static bool
MethodTypeMatches(Tcl_Interp *interp, MethodtypeIdx_t methodType, Tcl_Command cmd,
                  NsfObject *object, const char *methodName, int withPer_object,
                  bool *isObject) {
  Tcl_ObjCmdProc *proc;
  Tcl_Command     importedCmd;

  nonnull_assert(interp != NULL);
  nonnull_assert(cmd != NULL);
  nonnull_assert(methodName != NULL);
  nonnull_assert(isObject != NULL);

  proc = Tcl_Command_objProc(cmd);
  importedCmd = GetOriginalCommand(cmd);

  /*
   * Return state isObject since the cmd might be an ensemble, requiring
   * further searching.
   */
  *isObject = CmdIsNsfObject(importedCmd);

  if (methodType == NSF_METHODTYPE_ALIAS) {
    if (!(proc == NsfProcAliasMethod
          || AliasGet(interp, object->cmdName, methodName, withPer_object, NSF_FALSE))
       ) {
      return NSF_FALSE;
      }
  } else {
    Tcl_ObjCmdProc *resolvedProc;

    if (proc == NsfProcAliasMethod) {
      if ((methodType & NSF_METHODTYPE_ALIAS) == 0) {
        return NSF_FALSE;
      }
    }
    resolvedProc = Tcl_Command_objProc(importedCmd);

    /*
     * The following cases are disjoint.
     */
    if (CmdIsProc(importedCmd)) {
      /*fprintf(stderr, "%s scripted %d\n", methodName, methodType & NSF_METHODTYPE_SCRIPTED);*/
      if ((methodType & NSF_METHODTYPE_SCRIPTED) == 0) {
        return NSF_FALSE;
      }
    } else if (resolvedProc == NsfForwardMethod) {
      if ((methodType & NSF_METHODTYPE_FORWARDER) == 0) {
        return NSF_FALSE;
      }
    } else if (resolvedProc == NsfSetterMethod) {
      if ((methodType & NSF_METHODTYPE_SETTER) == 0) {
        return NSF_FALSE;
      }
    } else if (*isObject) {
      if ((methodType & NSF_METHODTYPE_OBJECT) == 0) {
        return NSF_FALSE;
      }
    } else if (resolvedProc == NsfProcStub) {
      if ((methodType & NSF_METHODTYPE_NSFPROC) == 0) {
        return NSF_FALSE;
      }
    } else if ((methodType & NSF_METHODTYPE_OTHER) == 0) {
      /* fprintf(stderr, "OTHER %s not wanted %.4x\n", methodName, methodType);*/
      return NSF_FALSE;
    }
    /* NsfObjscopedMethod ??? */
  }
  return NSF_TRUE;
}

/*
 *----------------------------------------------------------------------
 * ProtectionMatches --
 *
 *    True if the given command for a method matches the
 *    required call-protection, typically all|public|protected|private.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static bool ProtectionMatches(CallprotectionIdx_t withCallprotection, Tcl_Command cmd)
  nonnull(2) NSF_pure;

static bool
ProtectionMatches(CallprotectionIdx_t withCallprotection, Tcl_Command cmd) {
  int          result;
  bool         isProtected, isPrivate;
  unsigned int cmdFlags;

  nonnull_assert(cmd != NULL);

  cmdFlags    = (unsigned int)Tcl_Command_flags(cmd);
  isProtected = ((cmdFlags & NSF_CMD_CALL_PROTECTED_METHOD) != 0u);
  isPrivate   = ((cmdFlags & NSF_CMD_CALL_PRIVATE_METHOD) != 0u);

  if (withCallprotection == CallprotectionNULL) {
    withCallprotection = CallprotectionPublicIdx;
  }
  switch (withCallprotection) {
  case CallprotectionAllIdx: result = NSF_TRUE; break;
  case CallprotectionPublicIdx: result = (isProtected == 0); break;
  case CallprotectionProtectedIdx: result = (isProtected && !isPrivate); break;
  case CallprotectionPrivateIdx: result = isPrivate; break;
  case CallprotectionNULL: result = NSF_TRUE; break;
  default: result = NSF_FALSE; break;
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 *
 * ListMethodKeys --
 *
 *      Assigns to the interpreter result a list of names of methods in the
 *      given hash table that match the given filtering options: types,
 *      pattern, protection, etc.. A name prefix can optionally be given as a
 *      Tcl_DString.
 *
 * Results:
 *      A Tcl return code.
 *
 * Side effects:
 *      See description.
 *
 *----------------------------------------------------------------------
 */
static int ListMethodKeys(Tcl_Interp *interp, Tcl_HashTable *tablePtr,
                          Tcl_DString *prefix, const char *pattern,
                          MethodtypeIdx_t methodType, CallprotectionIdx_t withCallprotection, bool withPath,
                          Tcl_HashTable *dups, NsfObject *object, bool withPer_object)
  nonnull(1) nonnull(2);

static int
ListMethodKeys(Tcl_Interp *interp, Tcl_HashTable *tablePtr,
               Tcl_DString *prefix, const char *pattern,
               MethodtypeIdx_t methodType, CallprotectionIdx_t withCallprotection, bool withPath,
               Tcl_HashTable *dups, NsfObject *object, bool withPer_object) {
  Tcl_HashSearch       hSrch;
  const Tcl_HashEntry *hPtr;
  Tcl_Command          cmd;
  const char          *key;
  bool                 isObject, methodTypeMatch;
  Tcl_Obj             *resultObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(tablePtr != NULL);

  resultObj = Tcl_GetObjResult(interp);
  if (pattern != NULL && NoMetaChars(pattern) && strchr(pattern, ' ') == NULL) {
    /*
     * The pattern can be used for direct lookup. No need to iterate.
     */
    hPtr = Tcl_CreateHashEntry(tablePtr, pattern, NULL);
    if (hPtr != NULL) {
      NsfObject   *childObject;
      Tcl_Command  origCmd;

      key = Tcl_GetHashKey(tablePtr, hPtr);
      cmd = (Tcl_Command)Tcl_GetHashValue(hPtr);
      methodTypeMatch = MethodTypeMatches(interp, methodType, cmd, object, key,
                                          withPer_object, &isObject);
      if (((unsigned int)Tcl_Command_flags(cmd) & NSF_CMD_CLASS_ONLY_METHOD) != 0u
          && !NsfObjectIsClass(object)) {
        return TCL_OK;
      }
      /*
       * Aliased object methods return 1 but lookup from cmd returns NULL.
       * Select true sub-objects.
       */
      origCmd = GetOriginalCommand(cmd);
      childObject = (isObject) ? NsfGetObjectFromCmdPtr(origCmd) : NULL;

      if (childObject != NULL && withPath) {
        return TCL_OK;
      }

      if (ProtectionMatches(withCallprotection, cmd) && methodTypeMatch) {
        int prefixLength = (prefix != NULL) ? Tcl_DStringLength(prefix) : 0;

        if (prefixLength != 0) {
          Tcl_DStringAppend(prefix, key, -1);
          key = Tcl_DStringValue(prefix);
        }
        if (dups != NULL) {
          int new;

          (void)Tcl_CreateHashEntry(dups, key, &new);
          if (new != 0) {
            Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj(key, -1));
          }
        } else {
          Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj(key, -1));
        }
      }
    }
    return TCL_OK;

  } else {
    int prefixLength = (prefix != NULL) ? Tcl_DStringLength(prefix) : 0;

    /*
     * Iterate over the elements.
     */

    for (hPtr = Tcl_FirstHashEntry(tablePtr, &hSrch);
         hPtr != NULL;
         hPtr = Tcl_NextHashEntry(&hSrch)) {
      NsfObject   *childObject;
      Tcl_Command  origCmd;

      key = Tcl_GetHashKey(tablePtr, hPtr);
      cmd = (Tcl_Command)Tcl_GetHashValue(hPtr);
      if (prefixLength != 0) {
        Tcl_DStringSetLength(prefix, prefixLength);
      }
      methodTypeMatch = MethodTypeMatches(interp, methodType, cmd, object, key,
                                          withPer_object, &isObject);
      /*
       * Aliased objects methods return 1 but lookup from cmd returns NULL.
       * Select true sub-objects.
       */
      origCmd = GetOriginalCommand(cmd);
      childObject = (isObject) ? NsfGetObjectFromCmdPtr(origCmd) : NULL;

      if (childObject != NULL) {
        if (withPath) {
          Tcl_HashTable *cmdTablePtr;

          if (childObject->nsPtr == NULL) {
            /*
             * Nothing to do.
             */
            continue;
          }
          cmdTablePtr = Tcl_Namespace_cmdTablePtr(childObject->nsPtr);
          if (cmdTablePtr == NULL) {
            /*
             * Nothing to do.
             */
            continue;
          }
          if ((childObject->flags & NSF_IS_SLOT_CONTAINER) != 0u) {
            /*
             * Don't report a slot container.
             */
            continue;
          }
          if ((childObject->flags & NSF_KEEP_CALLER_SELF) == 0u) {
            /*
             * Only report sub-objects if NSF_KEEP_CALLER_SELF is true.
             */
            continue;
          }

          /*fprintf(stderr, "ListMethodKeys key %s append key space flags %.6x\n",
            key, childObject->flags);*/
          if (prefix == NULL) {
            Tcl_DString ds, *dsPtr = &ds;

            DSTRING_INIT(dsPtr);
            Tcl_DStringAppend(dsPtr, key, -1);
            Tcl_DStringAppend(dsPtr, " ", 1);
            ListMethodKeys(interp, cmdTablePtr, dsPtr, pattern, methodType,
                           withCallprotection, NSF_TRUE, dups, object, withPer_object);
            DSTRING_FREE(dsPtr);
          } else {
            Tcl_DStringAppend(prefix, key, -1);
            Tcl_DStringAppend(prefix, " ", 1);
            ListMethodKeys(interp, cmdTablePtr, prefix, pattern, methodType,
                           withCallprotection, NSF_TRUE, dups, object, withPer_object);
          }
          /*
           * Don't list ensembles by themselves.
           */
          continue;
        }
      }

      if (((unsigned int)Tcl_Command_flags(cmd) & NSF_CMD_CLASS_ONLY_METHOD) != 0u
          && !NsfObjectIsClass(object)
          ) {
        continue;
      }
      if (!ProtectionMatches(withCallprotection, cmd)
          || (!methodTypeMatch)) {
        continue;
      }

      if (prefixLength != 0) {
        Tcl_DStringAppend(prefix, key, -1);
        key = Tcl_DStringValue(prefix);
      }

      if (pattern != NULL && !Tcl_StringMatch(key, pattern)) {
        continue;
      }
      if (dups != NULL) {
        int new;

        Tcl_CreateHashEntry(dups, key, &new);
        if (new == 0) {
          continue;
        }
      }
      Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj(key, -1));
    }
  }
  /*fprintf(stderr, "listkeys returns '%s'\n", ObjStr(Tcl_GetObjResult(interp)));*/
  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ListChildren --
 *
 *      Stores as the interp result a list of the children of the given object,
 *      optionally filtered by pattern or type.
 *
 * Results:
 *      A Tcl return code.
 *
 * Side effects:
 *      See description.
 *
 *----------------------------------------------------------------------
 */
static int ListChildren(
    Tcl_Interp *interp, NsfObject *object,
    const char *pattern,
    bool classesOnly, NsfClass *typeClass
) nonnull(1) nonnull(2);

static int
ListChildren(
    Tcl_Interp *interp, NsfObject *object,
    const char *pattern,
    bool classesOnly, NsfClass *typeClass
) {
  NsfObject *childObject;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  if (object->nsPtr == NULL) {
    return TCL_OK;
  }

  if (pattern != NULL && NoMetaChars(pattern)) {
    Tcl_DString ds, *dsPtr = &ds;

    Tcl_DStringInit(dsPtr);

    if (*pattern != ':') {
      /*
       * Build a fully-qualified name.
       */
      DStringAppendQualName(dsPtr, object->nsPtr, pattern);
      pattern = Tcl_DStringValue(dsPtr);
    }

    if ((childObject = GetObjectFromString(interp, pattern)) &&
        (!classesOnly || NsfObjectIsClass(childObject)) &&
        ((typeClass == NULL) || IsSubType(childObject->cl, typeClass)) &&
        (Tcl_Command_nsPtr(childObject->id) == object->nsPtr)  /* true children */
        ) {
      Tcl_SetObjResult(interp, childObject->cmdName);
    } else {
      Tcl_SetObjResult(interp, NsfGlobalObjs[NSF_EMPTY]);
    }
    Tcl_DStringFree(dsPtr);

  } else {
    Tcl_Obj *list = Tcl_NewListObj(0, NULL);
    Tcl_HashSearch hSrch;
    Tcl_HashTable *cmdTablePtr = Tcl_Namespace_cmdTablePtr(object->nsPtr);
    const Tcl_HashEntry *hPtr;

    for (hPtr = Tcl_FirstHashEntry(cmdTablePtr, &hSrch);
         hPtr != NULL;
         hPtr = Tcl_NextHashEntry(&hSrch)) {
      const char *key = Tcl_GetHashKey(cmdTablePtr, hPtr);

      if (pattern == NULL || Tcl_StringMatch(key, pattern)) {
        Tcl_Command cmd = (Tcl_Command)Tcl_GetHashValue(hPtr);

        /*fprintf(stderr, "... check %s child key %s child object %p %p\n",
                ObjectName(object), key, GetObjectFromString(interp, key),
                NsfGetObjectFromCmdPtr(cmd));*/

        if ((childObject = NsfGetObjectFromCmdPtr(cmd)) &&
            (!classesOnly || NsfObjectIsClass(childObject)) &&
            ((typeClass == NULL) || IsSubType(childObject->cl, typeClass)) &&
            (Tcl_Command_nsPtr(childObject->id) == object->nsPtr)  /* true children */
            ) {
          Tcl_ListObjAppendElement(interp, list, childObject->cmdName);
        }
      }
    }
    Tcl_SetObjResult(interp, list);
  }

  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ListForward --
 *
 *      Sets the interpreter result to the list of forward methods defined in
 *      the given hash table. The list can be filtered by the given pattern,
 *      and the result catn optionally be a single forward definition instead.
 *
 * Results:
 *      A Tcl return code.
 *
 * Side effects:
 *      See description.
 *
 *----------------------------------------------------------------------
 */
static int ListForward(Tcl_Interp *interp, Tcl_HashTable *tablePtr,
            const char *pattern, int withDefinition)
  nonnull(1) nonnull(2);

static int
ListForward(Tcl_Interp *interp, Tcl_HashTable *tablePtr,
            const char *pattern, int withDefinition) {

  nonnull_assert(interp != NULL);
  nonnull_assert(tablePtr != NULL);

  if (withDefinition != 0) {
    const Tcl_HashEntry *hPtr = (pattern != NULL) ? Tcl_CreateHashEntry(tablePtr, pattern, NULL) : NULL;
    /*
     * No pattern wildcard matching when "-definition" is true.
     */
    if (hPtr != NULL) {
      Tcl_Command cmd = (Tcl_Command)Tcl_GetHashValue(hPtr);
      ClientData clientData = (cmd != NULL) ? Tcl_Command_objClientData(cmd) : NULL;
      ForwardCmdClientData *tcd = (ForwardCmdClientData *)clientData;

      if (tcd != NULL && Tcl_Command_objProc(cmd) == NsfForwardMethod) {
        Tcl_Obj *listObj = Tcl_NewListObj(0, NULL);

        AppendForwardDefinition(interp, listObj, tcd);
        Tcl_SetObjResult(interp, listObj);
        return TCL_OK;
      }
    }
    return NsfPrintError(interp, "'%s' is not a forwarder", pattern);
  }
  return ListMethodKeys(interp, tablePtr, NULL, pattern, NSF_METHODTYPE_FORWARDER,
                        CallprotectionAllIdx, NSF_FALSE, NULL, NULL, NSF_FALSE);
}

/*
 *----------------------------------------------------------------------
 *
 * ListDefinedMethods --
 *
 *      Sets the interpreter result to the list of methods defined by the given
 *      object/class, optionally filtering by types, pattern,protection, etc.
 *
 * Results:
 *      A Tcl return code.
 *
 * Side effects:
 *      See description.
 *
 *----------------------------------------------------------------------
 */
static int
ListDefinedMethods(Tcl_Interp *interp, NsfObject *object, const char *pattern,
                   bool withPer_object, MethodtypeIdx_t methodType, CallprotectionIdx_t withCallprotection,
                   bool withPath) {
  Tcl_HashTable *cmdTablePtr;
  Tcl_DString ds, *dsPtr = NULL;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  if (pattern != NULL && *pattern == ':' && *(pattern + 1) == ':') {
    Namespace *nsPtr, *dummy1Ptr, *dummy2Ptr;
    const char *remainder;

    /*fprintf(stderr, "we have a colon pattern '%s' methodtype %.6x\n", pattern, methodType);*/

    TclGetNamespaceForQualName(interp, pattern, NULL, 0,
                               &nsPtr, &dummy1Ptr, &dummy2Ptr, &remainder);
    /*fprintf(stderr,
            "TclGetNamespaceForQualName with %s => (%p %s) (%p %s) (%p %s) (%p %s)\n",
            pattern,
            nsPtr, (nsPtr != NULL) ? nsPtr->fullName : "",
            dummy1Ptr, (dummy1Ptr != NULL) ? dummy1Ptr->fullName : "",
            dummy2Ptr, (dummy2Ptr != NULL) ? dummy2Ptr->fullName : "",
            remainder, (remainder != 0) ? remainder : "");*/
    if (nsPtr != NULL) {
      cmdTablePtr = Tcl_Namespace_cmdTablePtr(nsPtr);
      dsPtr = &ds;
      Tcl_DStringInit(dsPtr);
      Tcl_DStringAppend(dsPtr, nsPtr->fullName, -1);
      if (Tcl_DStringLength(dsPtr) > 2) {
        Tcl_DStringAppend(dsPtr, "::", 2);
      }
      pattern = remainder;
    } else {
      cmdTablePtr = NULL;
    }
  } else if (NsfObjectIsClass(object) && !withPer_object) {
    cmdTablePtr = Tcl_Namespace_cmdTablePtr(((NsfClass *)object)->nsPtr);
  } else {
    cmdTablePtr = (object->nsPtr != NULL) ? Tcl_Namespace_cmdTablePtr(object->nsPtr) : NULL;
  }

  if (cmdTablePtr != NULL) {
    ListMethodKeys(interp, cmdTablePtr, dsPtr, pattern, methodType, withCallprotection, withPath,
                   NULL, object, withPer_object);
    if (dsPtr != NULL) {
      Tcl_DStringFree(dsPtr);
    }
  }
  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ListSuperClasses --
 *
 *      Sets the interpreter result to the list of superclasses of a class,
 *      optionally including the entire superclass hierarchy, and optionally
 *      filtered by a pattern.
 *
 * Results:
 *      A Tcl return code.
 *
 * Side effects:
 *      See description.
 *
 *----------------------------------------------------------------------
 */

static int ListSuperClasses(Tcl_Interp *interp, NsfClass *class, Tcl_Obj *pattern, bool withClosure)
  nonnull(1) nonnull(2);

static int
ListSuperClasses(Tcl_Interp *interp, NsfClass *class, Tcl_Obj *pattern, bool withClosure) {

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);

  if (class->super != NULL) {
    NsfObject   *matchObject = NULL;
    Tcl_Obj     *outObjPtr, *patternObj = NULL;
    const char  *patternString = NULL;
    ClientData   clientData;
    bool         found;

    if (pattern != NULL
        && ConvertToObjpattern(interp, pattern, NULL, &clientData, &outObjPtr) == TCL_OK
        ) {
      patternObj = (Tcl_Obj *)clientData;

      if (GetMatchObject(interp, patternObj, pattern, &matchObject, &patternString) == -1) {
        /*
         * The pattern has no meta chars and does not correspond to an existing
         * object so it it can't be a superclass.
         */
        if (patternObj != NULL) {
          DECR_REF_COUNT2("patternObj", patternObj);
        }
        return TCL_OK;
      }
    }

    if (withClosure) {
      NsfClasses *pl = PrecedenceOrder(class);

      if (pl != NULL) {
        pl = pl->nextPtr;
      }
      found = AppendMatchingElementsFromClasses(interp, pl, patternString, matchObject);
    } else {
      NsfClasses *clSuper = NsfReverseClasses(class->super);

      found = AppendMatchingElementsFromClasses(interp, clSuper, patternString, matchObject);
      NsfClassListFree(clSuper);
    }

    if (matchObject != NULL) {
      Tcl_SetObjResult(interp, found ? matchObject->cmdName : NsfGlobalObjs[NSF_EMPTY]);
    }

    if (patternObj != NULL) {
      DECR_REF_COUNT2("patternObj", patternObj);
    }

  }
  return TCL_OK;
}


/********************************
 * End result setting commands
 ********************************/

/*
 *----------------------------------------------------------------------
 *
 * AliasIndex --
 *
 *      Returns a new Tcl_Obj owned by the caller and containing the alias
 *      index for the given name and method name The alias index is an internal
 *      data structure that keeps track of the contruction of aliases.
 *
 * Results:
 *      See description.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */
static Tcl_Obj *AliasIndex(Tcl_Obj *cmdName, const char *methodName, bool withPer_object)
  nonnull(1) nonnull(2) returns_nonnull;

static Tcl_Obj *
AliasIndex(Tcl_Obj *cmdName, const char *methodName, bool withPer_object) {
  Tcl_DString  ds, *dsPtr = &ds;
  Tcl_Obj     *resultObj;

  nonnull_assert(cmdName != NULL);
  nonnull_assert(methodName != NULL);

  Tcl_DStringInit(dsPtr);
  Tcl_DStringAppend(dsPtr,  ObjStr(cmdName), -1);
  Tcl_DStringAppend(dsPtr,  ",", 1);
  Tcl_DStringAppend(dsPtr,  methodName, -11);
  if (withPer_object) {
    Tcl_DStringAppend(dsPtr, ",1", 2);
  } else {
    Tcl_DStringAppend(dsPtr, ",0", 2);
  }
  /*fprintf(stderr, "AI %s\n", Tcl_DStringValue(dsPtr));*/
  resultObj = Tcl_NewStringObj(dsPtr->string, dsPtr->length);
  Tcl_DStringFree(dsPtr);

  return resultObj;
}

/*
 *----------------------------------------------------------------------
 *
 * AliasAdd --
 *
 *      Adds an entry to the alias index.
 *
 * Results:
 *      A Tcl return code.
 *
 * Side effects:
 *      See description.
 *
 *----------------------------------------------------------------------
 */
static int AliasAdd(Tcl_Interp *interp, Tcl_Obj *cmdName, const char *methodName, bool withPer_object,
         Tcl_Obj *cmdObj)
  nonnull(1) nonnull(2) nonnull(3) nonnull(5);

static int
AliasAdd(Tcl_Interp *interp, Tcl_Obj *cmdName, const char *methodName, bool withPer_object,
         Tcl_Obj *cmdObj) {
  Tcl_Obj    *indexObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(cmdName != NULL);
  nonnull_assert(methodName != NULL);
  nonnull_assert(cmdObj != NULL);



  indexObj = AliasIndex(cmdName, methodName, withPer_object);

  INCR_REF_COUNT(indexObj);
  Tcl_ObjSetVar2(interp, NsfGlobalObjs[NSF_ARRAY_ALIAS],
                 indexObj,
                 cmdObj,
                 TCL_GLOBAL_ONLY);
  DECR_REF_COUNT(indexObj);

  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * AliasDelete --
 *
 *      Deletes an alias from the index.
 *
 * Results:
 *      A Tcl return code.
 *
 * Side effects:
 *      See description.
 *
 *----------------------------------------------------------------------
 */
static int
AliasDelete(Tcl_Interp *interp, Tcl_Obj *cmdName, const char *methodName, bool withPer_object) {
  int         result;
  Tcl_Obj    *indexObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(cmdName != NULL);
  nonnull_assert(methodName != NULL);

  indexObj = AliasIndex(cmdName, methodName, withPer_object);
  INCR_REF_COUNT(indexObj);
  result = Tcl_UnsetVar2(interp, NsfGlobalStrings[NSF_ARRAY_ALIAS],
                         ObjStr(indexObj),
                         TCL_GLOBAL_ONLY);
  DECR_REF_COUNT(indexObj);

  /*fprintf(stderr, "aliasDelete ::nsf::alias(%s) returned %d (%d)\n",
    AliasIndex(dsPtr, cmdName, methodName, withPer_object), result);*/

  return result;
}

/*
 *----------------------------------------------------------------------
 *
 * AliasGet --
 *
 *      Returns from the alias index the entry for the given command and
 *      method, if found, and prints an error otherwise.
 *
 * Results:
 *      See description.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */
static Tcl_Obj *
AliasGet(Tcl_Interp *interp, Tcl_Obj *cmdName, const char *methodName, bool withPer_object, bool leaveError) {
  Tcl_Obj *obj, *indexObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(cmdName != NULL);
  nonnull_assert(methodName != NULL);

  indexObj = AliasIndex(cmdName, methodName, withPer_object);

  INCR_REF_COUNT(indexObj);
  obj = Tcl_ObjGetVar2(interp,
                       NsfGlobalObjs[NSF_ARRAY_ALIAS],
                       indexObj,
                       TCL_GLOBAL_ONLY);
  DECR_REF_COUNT(indexObj);

  /*fprintf(stderr, "aliasGet methodName '%s' returns %p\n", methodName, obj);*/

  if (obj == NULL && leaveError) {
    NsfPrintError(interp, "could not obtain alias definition for %s %s.",
                  ObjStr(cmdName), methodName);
  }

  return obj;
}


/*
 *----------------------------------------------------------------------
 * AliasDeleteObjectReference --
 *
 *    Deletes an alias to a referenced object but not the object itself,
 *    distinguishing between a sub-object and an alias to an object.  Such
 *    aliases are created by registering an alias to an object.
 *
 * Results:
 *    True if an alias is successfully deleted.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static bool
AliasDeleteObjectReference(Tcl_Interp *interp, Tcl_Command cmd) {
  NsfObject *referencedObject = NsfGetObjectFromCmdPtr(cmd);

  nonnull_assert(interp != NULL);
  nonnull_assert(cmd != NULL);
  nonnull_assert(referencedObject != NULL);

  /*fprintf(stderr, "AliasDeleteObjectReference on %p obj %p\n", cmd, referencedObject);*/
  if (referencedObject->refCount > 0
      && cmd != referencedObject->id) {
    /*
     * The cmd is an aliased object. Reduce the refCount of the object and
     * delete the cmd.
     */
    /*fprintf(stderr, "remove alias %s to %s\n",
      Tcl_GetCommandName(interp, cmd), ObjectName(referencedObject));*/
    NsfCleanupObject(referencedObject, "AliasDeleteObjectReference");
    Tcl_DeleteCommandFromToken(interp, cmd);
    return NSF_TRUE;
  }
  return NSF_FALSE;
}

/*
 *----------------------------------------------------------------------
 * AliasRefetch --
 *
 *    Refetches an epoch-aliased cmd and updates the AliasCmdClientData
 *    structure.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
static int
AliasRefetch(Tcl_Interp *interp, NsfObject *object, const char *methodName, AliasCmdClientData *tcd) {
  Tcl_Obj **listElements, *entryObj, *targetObj;
  int nrElements, withPer_object;
  NsfObject *defObject;
  Tcl_Command cmd;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodName != NULL);
  nonnull_assert(tcd != NULL);

  /*fprintf(stderr, "AliasRefetch %s\n", methodName);*/

  defObject = (tcd->class != NULL) ? &(tcd->class->object) : object;

  /*
   * Get targetObject. Currently, it can just be obtained via the alias array.
   */
  withPer_object = (tcd->class == NULL);
  entryObj = AliasGet(interp, defObject->cmdName, methodName, withPer_object, NSF_TRUE);
  if (unlikely(entryObj == NULL)) {
    return TCL_ERROR;
  }

  INCR_REF_COUNT(entryObj);
  Tcl_ListObjGetElements(interp, entryObj, &nrElements, &listElements);
  targetObj = listElements[nrElements-1];

  NsfLog(interp, NSF_LOG_NOTICE,
         "trying to refetch an epoched cmd %p as %s -- cmdName %s",
         (void *)tcd->aliasedCmd, methodName, ObjStr(targetObj));

  /*
   * Replace cmd and its objProc and clientData with a newly-fetched
   * version.
   */
  cmd = Tcl_GetCommandFromObj(interp, targetObj);
  if (cmd != NULL) {
    cmd = GetOriginalCommand(cmd);
    /*fprintf(stderr, "cmd %p epoch %d deleted %.6x\n",
      cmd,
      Tcl_Command_cmdEpoch(cmd),
      Tcl_Command_flags(cmd) & CMD_IS_DELETED);*/
    if (((unsigned int)Tcl_Command_flags(cmd) & CMD_IS_DELETED) != 0u) {
      cmd = NULL;
    }
  }
  if (cmd == NULL) {
    int result = NsfPrintError(interp, "target \"%s\" of alias %s apparently disappeared",
                               ObjStr(targetObj), methodName);
    DECR_REF_COUNT(entryObj);
    return result;
  }

  assert(Tcl_Command_objProc(cmd) != NULL);

  NsfCommandRelease(tcd->aliasedCmd);
  tcd->objProc    = Tcl_Command_objProc(cmd);
  tcd->aliasedCmd = cmd;
  tcd->clientData = Tcl_Command_objClientData(cmd);
  NsfCommandPreserve(tcd->aliasedCmd);

  DECR_REF_COUNT(entryObj);
  /*
   * Now there is a non-epoched aliasCmd, proceed as planned.
   */
  return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 * AliasDereference --
 *
 *    Dereferences a cmd with respect to the alias structure and returns the
 *    command or NULL.  Refetches the aliased command if necessary.
 *
 * Results:
 *    See description.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */
NSF_INLINE static Tcl_Command AliasDereference(Tcl_Interp *interp, NsfObject *object, const char *methodName, Tcl_Command cmd)
  nonnull(1) nonnull(2) nonnull(3) nonnull(4);

NSF_INLINE static Tcl_Command
AliasDereference(Tcl_Interp *interp, NsfObject *object, const char *methodName, Tcl_Command cmd) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodName != NULL);
  nonnull_assert(cmd != NULL);

  if (unlikely(Tcl_Command_objProc(cmd) == NsfProcAliasMethod)) {
    AliasCmdClientData *tcd = (AliasCmdClientData *)Tcl_Command_objClientData(cmd);

    assert(tcd != NULL);
    /*fprintf(stderr, "AliasDereference %s epoch %d\n", methodName, Tcl_Command_cmdEpoch(tcd->aliasedCmd));*/
    if (unlikely(Tcl_Command_cmdEpoch(tcd->aliasedCmd) != 0)) {

      /*fprintf(stderr, "NsfProcAliasMethod aliasedCmd %p epoch %p\n",
        tcd->aliasedCmd, Tcl_Command_cmdEpoch(tcd->aliasedCmd));*/

      if (AliasRefetch(interp, object, methodName, tcd) != TCL_OK) {
        return NULL;
      }
    }
    return tcd->aliasedCmd;
  }

  return cmd;
}

#if defined(NSF_ASSEMBLE)
# include "asm/nsfAssemble.c"
#else
static int
  NsfAsmMethodCreateCmd(Tcl_Interp *UNUSED(interp),
                        NsfObject *UNUSED(defObject),
                        int UNUSED(with_checkAlways),
                        int UNUSED(withInner_namespace),
                        int UNUSED(withPer_object),
                        NsfObject *UNUSED(regObject),
                        Tcl_Obj *UNUSED(nameObj),
                        Tcl_Obj *UNUSED(argumentsObj),
                        Tcl_Obj *UNUSED(bodyObj))
{
  /*
   * Dummy stub; used, when compiled without NSF_ASSEMBLE
   */
  return TCL_OK;
}
#endif

/*
 *----------------------------------------------------------------------
 * SetBooleanFlag --
 *
 *    Sets an unsigned int flag based on valueObj.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static int SetBooleanFlag(Tcl_Interp *interp, unsigned int *flagsPtr, unsigned int flag, Tcl_Obj *valueObj, int *flagValue)
  nonnull(1) nonnull(2) nonnull(4) nonnull(5);

static int
SetBooleanFlag(Tcl_Interp *interp, unsigned int *flagsPtr, unsigned int flag, Tcl_Obj *valueObj, int *flagValue) {
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(flagsPtr != NULL);
  nonnull_assert(valueObj != NULL);
  nonnull_assert(flagValue != NULL);

  result = Tcl_GetBooleanFromObj(interp, valueObj, flagValue);
  if (unlikely(result != TCL_OK)) {
    return result;
  }
  if (*flagValue) {
    *flagsPtr |= flag;
  } else {
    *flagsPtr &= ~flag;
  }
  return result;
}

/***********************************************************************
 * Begin generated Next Scripting commands
 ***********************************************************************/

/*
cmd __db_compile_epoch NsfDebugCompileEpoch {}
 */
static int NsfDebugCompileEpoch(Tcl_Interp *interp)
  nonnull(1);

static int
NsfDebugCompileEpoch(Tcl_Interp *interp) {

  nonnull_assert(interp != NULL);

  Tcl_SetObjResult(interp, Tcl_NewIntObj((int)(((Interp *)interp)->compileEpoch)));
  return TCL_OK;
}

/*
cmd __db_show_obj NsfDebugShowObj {
  {-argName "obj"    -required 1 -type tclobj}
}
*/
static int NsfDebugShowObj(Tcl_Interp *interp, Tcl_Obj *obj)
  nonnull(1) nonnull(2);

static int
NsfDebugShowObj(Tcl_Interp *interp, Tcl_Obj *obj) {

  nonnull_assert(interp != NULL);
  nonnull_assert(obj != NULL);

  fprintf(stderr, "*** obj %p refCount %d type <%s> ",
          (void *)obj, obj->refCount, ObjTypeStr(obj));

  if (obj->typePtr == &NsfObjectMethodObjType
      || obj->typePtr == &NsfInstanceMethodObjType
      ) {
    NsfMethodContext *mcPtr = obj->internalRep.twoPtrValue.ptr1;
    unsigned int currentMethodEpoch = obj->typePtr == &NsfObjectMethodObjType ?
      RUNTIME_STATE(interp)->objectMethodEpoch :
      RUNTIME_STATE(interp)->instanceMethodEpoch;
    Tcl_Command cmd = mcPtr->cmd;

    fprintf(stderr, "   method epoch %u max %u cmd %p objProc 0x%" PRIxPTR " flags %.6x",
            mcPtr->methodEpoch, currentMethodEpoch,
            (void *)cmd,
            (cmd != NULL) ? (unsigned long)PTR2UINT(((Command *)cmd)->objProc) : 0ul,
            mcPtr->flags);
    if (cmd != NULL) {
      fprintf(stderr, "... cmd %p flags %.6x\n", (void *)cmd, Tcl_Command_flags(cmd));
      assert(((Command *)cmd)->objProc != NULL);
    }
    assert(currentMethodEpoch >= mcPtr->methodEpoch);

  } else if (obj->typePtr == Nsf_OT_tclCmdNameType) {
    Tcl_Command cmd = Tcl_GetCommandFromObj(interp, obj);

    if (likely(cmd != NULL)) {
      Command    *procPtr = (Command *)cmd;
      const char *tail = Tcl_GetHashKey(procPtr->hPtr->tablePtr, procPtr->hPtr);

      fprintf(stderr, "... cmd %p flags %.6x name '%s' ns '%s' objProcName %s",
              (void *)cmd, Tcl_Command_flags(cmd), tail, procPtr->nsPtr->name,
              CmdObjProcName(cmd));
    }
  } else if ((obj->typePtr == Nsf_OT_byteArrayType)
             || (obj->typePtr == Nsf_OT_properByteArrayType)) {
    const char *bytes;
    int         i, length;

    bytes = (char *)Tcl_GetByteArrayFromObj(obj, &length);

    fprintf(stderr, "bytearray proper %d length %d string rep %p: ",
            (obj->typePtr == Nsf_OT_properByteArrayType),
            length, (void*)obj->bytes);
    for (i = 0; i < length; i++) {
      fprintf(stderr, "%.2x", (unsigned)(*(bytes+i)) & 0xff);
    }
  }
  fprintf(stderr, "\n");

  return TCL_OK;
}

/*
cmd __db_get_obj NsfDebugGetDict {
  {-argName "obj"    -required 1 -type tclobj}
}
*/
#define NSF_DEBUG_SHOW_BYTES 10u
static int NsfDebugGetDict(Tcl_Interp *interp, Tcl_Obj *obj)
  nonnull(1) nonnull(2);

static int
NsfDebugGetDict(Tcl_Interp *interp, Tcl_Obj *obj) {
  Tcl_Obj    *resultObj;
  const char *typeString;

  nonnull_assert(interp != NULL);
  nonnull_assert(obj != NULL);

  typeString = (obj->typePtr != NULL) ? obj->typePtr->name : "";

  resultObj = Tcl_NewListObj(0, NULL);
  Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj("type", -1));
  Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj(typeString, -1));
  Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj("refcount", -1));
  Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewIntObj(obj->refCount));
  Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj("length", -1));
  Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewIntObj(obj->length));
  Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj("hex", -1));

  if (obj->bytes != NULL) {
    size_t       i, objLength = (size_t)obj->length;
    char         trailer[3] = "...";
    char         buffer[NSF_DEBUG_SHOW_BYTES*2u + sizeof(trailer) + 1u];

    for (i = 0; i < NSF_DEBUG_SHOW_BYTES && i < objLength; i++) {
      snprintf(buffer + i*2, sizeof(buffer) - (i+1)*2, "%.2x", (unsigned)(*((obj->bytes)+i) & 0xff));
    }
    if (objLength > NSF_DEBUG_SHOW_BYTES) {
      strncat(buffer, trailer, sizeof(buffer) - strlen(buffer) - 1);
    }
    Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj(buffer, -1));

  } else {
    Tcl_ListObjAppendElement(interp, resultObj, Tcl_NewStringObj("", 0));
  }
  Tcl_SetObjResult(interp, resultObj);

  return TCL_OK;
}

/*
cmd __db_show_stack NsfShowStackCmd {}
*/
static int
NsfShowStackCmd(Tcl_Interp *interp) {

  nonnull_assert(interp != NULL);

  NsfShowStack(interp);
  return TCL_OK;
}

/*
cmd __db_run_assertions NsfDebugRunAssertionsCmd {}
*/
static int
NsfDebugRunAssertionsCmd(Tcl_Interp *interp) {
  NsfObjectSystem *osPtr;
  NsfCmdList      *instances = NULL, *entry;

  nonnull_assert(interp != NULL);

  /*
   * Collect all instances from all object systems.
   */
  for (osPtr = RUNTIME_STATE(interp)->objectSystems; osPtr != NULL; osPtr = osPtr->nextPtr) {
    GetAllInstances(interp, &instances, osPtr->rootClass);
  }

  for (entry = instances; entry != NULL; entry = entry->nextPtr) {
#if !defined(NDEBUG)
    NsfObject *object = (NsfObject *)entry->clorobj;
#endif

    assert(object != NULL);
    assert(object->refCount > 0);
    assert(object->cmdName->refCount > 0);
    assert(object->activationCount >= 0);

#if defined(CHECK_ACTIVATION_COUNTS)
    if (object->activationCount > 0) {
      Tcl_CallFrame *framePtr;
      int            count = 0;
      NsfClasses    *unstackedEntries = RUNTIME_STATE(interp)->cscList;

      /*fprintf(stderr, "DEBUG obj %p %s activationcount %d\n",
        object, ObjectName(object), object->activationCount);*/

      framePtr = (Tcl_CallFrame *)Tcl_Interp_framePtr(interp);
      for (; framePtr != NULL; framePtr = Tcl_CallFrame_callerPtr(framePtr)) {
        int                  frameFlags = Tcl_CallFrame_isProcCallFrame(framePtr);
        NsfCallStackContent *cscPtr =
          ((frameFlags & (FRAME_IS_NSF_METHOD|FRAME_IS_NSF_CMETHOD)) != 0u) ?
          ((NsfCallStackContent *)Tcl_CallFrame_clientData(framePtr)) : NULL;

        if (cscPtr != NULL && cscPtr->self == object) {
          count ++;
        }
        if (cscPtr != NULL && (NsfObject *)cscPtr->cl == object) {
          count ++;
        }
      }
      for (; unstackedEntries; unstackedEntries = unstackedEntries->nextPtr) {
        NsfCallStackContent *cscPtr = (NsfCallStackContent *)unstackedEntries->cl;

        if (cscPtr != NULL && cscPtr->self == object) {
          count ++;
        }
        if (cscPtr != NULL && (NsfObject *)cscPtr->cl == object) {
          count ++;
        }
      }

      if (count != object->activationCount) {
        fprintf(stderr, "DEBUG obj %p %s activationcount %d on stack %d; "
                "might be from non-stacked but active call-stack content\n",
                object, ObjectName(object), object->activationCount, count);
        fprintf(stderr, "fixed count %d\n", count);
        /*NsfShowStack(interp);*/
        /*return NsfPrintError(interp, "wrong activation count for object %s", ObjectName(object));*/
      }
    }
#endif

  }
  CmdListFree(&instances, NULL);
  /*fprintf(stderr, "all assertions passed\n");*/

  return TCL_OK;
}

/*
cmd __profile_clear_data NsfProfileClearDataStub {}
cmd __profile_get_data NsfProfileGetDataStub {}
cmd __profile_trace NsfProfileTraceStub {
  {-argName "-enable" -required 1 -nrargs 1 -type boolean}
  {-argName "-verbose" -required 0 -nrargs 1 -type boolean}
  {-argName "-dontsave" -required 0 -nrargs 1 -type boolean}
  {-argName "-builtins" -required 0 -nrargs 1 -type tclobj}
}
*/

static int NsfProfileClearDataStub(Tcl_Interp *interp)
  nonnull(1);
static int NsfProfileGetDataStub(Tcl_Interp *interp)
  nonnull(1);
static int NsfProfileTraceStub(Tcl_Interp *interp,
                               int withEnable, int withVerbose, int withDontsave,
                               Tcl_Obj *builtinsObj)
  NSF_nonnull(1);

#if defined(NSF_PROFILE)

static int
NsfProfileClearDataStub(Tcl_Interp *interp) {
  nonnull_assert(interp != NULL);
  NsfProfileClearData(interp);
  return TCL_OK;
}


static int
NsfProfileGetDataStub(Tcl_Interp *interp) {
  nonnull_assert(interp != NULL);
  NsfProfileGetData(interp);
  return TCL_OK;
}

static int
NsfProfileTraceStub(Tcl_Interp *interp, int withEnable, int withVerbose, int withDontsave, Tcl_Obj *builtinsObj) {
  nonnull_assert(interp != NULL);
  NsfProfileTrace(interp, withEnable, withVerbose, withDontsave, builtinsObj);
  return TCL_OK;
}

#else
static int NsfProfileClearDataStub(Tcl_Interp *UNUSED(interp)) {
  return TCL_OK;
}
static int NsfProfileGetDataStub(  Tcl_Interp *UNUSED(interp)) {
  return TCL_OK;
}
static int NsfProfileTraceStub(    Tcl_Interp *UNUSED(interp),
                    int UNUSED(withEnable),
                    int UNUSED(withVerbose),
                    int UNUSED(withDontsave),
                    Tcl_Obj *UNUSED(builtins)) {
  return TCL_OK;
}
#endif

/*
 * Valgrind/callgrind support.
 */
#if defined(NSF_VALGRIND)

#include <valgrind/callgrind.h>
/*
cmd __callgrind_dump_stats NsfCallgrindDumpStatsCmd {
  {-argName "-name" -required 0 -nrargs 1}
}
cmd __callgrind_start_instrumentation NsfCallgrindStartInstrumentationCmd {}
cmd __callgrind_stop_instrumentation NsfCallgrindStopInstrumentationCmd {}
cmd __callgrind_toggle_collect NsfCallgrindToggleCollectCmd {}
cmd __callgrind_zero_stats NsfCallgrindZeroStatsCmd {}
*/

static int
NsfCallgrindDumpStatsCmd(Tcl_Interp *UNUSED(interp), const char *nameString) {
  if (nameString == NULL) {
    CALLGRIND_DUMP_STATS;
  } else {
    CALLGRIND_DUMP_STATS_AT(nameString);
  }
  return TCL_OK;
}

static int
NsfCallgrindStartInstrumentationCmd(Tcl_Interp *UNUSED(interp)) {
  CALLGRIND_START_INSTRUMENTATION;
  return TCL_OK;
}

static int
NsfCallgrindStopInstrumentationCmd(Tcl_Interp *UNUSED(interp)) {
  CALLGRIND_STOP_INSTRUMENTATION;
  return TCL_OK;
}

static int
NsfCallgrindToggleCollectCmd(Tcl_Interp *UNUSED(interp)) {
  CALLGRIND_TOGGLE_COLLECT;
  return TCL_OK;
}

static int
NsfCallgrindZeroStatsCmd(Tcl_Interp *UNUSED(interp)) {
  CALLGRIND_ZERO_STATS;
  return TCL_OK;
}
#else

static int NsfCallgrindDumpStatsCmd(Tcl_Interp *UNUSED(interp), const char *UNUSED(nameString)) {
  return TCL_OK;
}
static int NsfCallgrindStartInstrumentationCmd(Tcl_Interp *UNUSED(interp)) {
  return TCL_OK;
}
static int NsfCallgrindStopInstrumentationCmd(Tcl_Interp *UNUSED(interp))  {
  return TCL_OK;
}
static int NsfCallgrindToggleCollectCmd(Tcl_Interp *UNUSED(interp))        {
  return TCL_OK;
}
static int NsfCallgrindZeroStatsCmd(Tcl_Interp *UNUSED(interp))            {
  return TCL_OK;
}

#endif

/*
 *----------------------------------------------------------------------
 * NsfUnsetUnknownArgsCmd --
*
 *    Unsets each variable that was set by ArgumentDefaults() to the default
 *    dummy value of an argument.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
/*
cmd __unset_unknown_args NsfUnsetUnknownArgsCmd {}
*/

static int
NsfUnsetUnknownArgsCmd(Tcl_Interp *interp) {
  CallFrame *varFramePtr;
  Proc      *proc;

  nonnull_assert(interp != NULL);

  varFramePtr = Tcl_Interp_varFramePtr(interp);
  proc = Tcl_CallFrame_procPtr(varFramePtr);

  if (likely(proc != NULL)) {
    const CompiledLocal *ap;
    const Var           *varPtr;
    int                  i;

    for (ap = proc->firstLocalPtr, i = 0; ap; ap = ap->nextPtr, i++) {
      if (!TclIsCompiledLocalArgument(ap)) {
        continue;
      }
      varPtr = &Tcl_CallFrame_compiledLocals(varFramePtr)[i];
      /*fprintf(stderr, "NsfUnsetUnknownArgsCmd var '%s' i %d fi %d var %p flags %.8x obj %p unk %p\n",
              ap->name, i, ap->frameIndex, varPtr, varPtr->flags, varPtr->value.objPtr,
              NsfGlobalObjs[NSF___UNKNOWN__]);*/
      if (varPtr->value.objPtr != NsfGlobalObjs[NSF___UNKNOWN__]) {
        continue;
      }
      /*fprintf(stderr, "NsfUnsetUnknownArgsCmd must unset %s\n", ap->name);*/
      Tcl_UnsetVar2(interp, ap->name, NULL, 0);
    }
  }

  return TCL_OK;
}

/*
cmd asmproc NsfAsmProcCmd {
  {-argName "-ad" -required 0  -nrargs 0 -type switch}
  {-argName "-checkalways" -required 0  -nrargs 0 -type switch}
  {-argName "procName" -required 1 -type tclobj}
  {-argName "arguments" -required 1 -type tclobj}
  {-argName "body" -required 1 -type tclobj}
}
*/
#if !defined(NSF_ASSEMBLE)
static int
NsfAsmProcCmd(Tcl_Interp *UNUSED(interp),
              int UNUSED(with_ad),
              int UNUSED(with_checkAlways),
              Tcl_Obj *UNUSED(nameObj),
              Tcl_Obj *UNUSED(arguments),
              Tcl_Obj *UNUSED(body))
{
  return TCL_OK;
}
#else
static int
NsfAsmProcCmd(Tcl_Interp *interp, int with_ad, int with_checkAlways, Tcl_Obj *nameObj, Tcl_Obj *arguments, Tcl_Obj *body) {
  NsfParsedParam parsedParam;
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(nameObj != NULL);
  nonnull_assert(arguments != NULL);
  nonnull_assert(body != NULL);

  /*
   * Parse "arguments" to determine if Nsf parameter handling is needed.
   */
  result = ParamDefsParse(interp, nameObj, arguments,
                          NSF_DISALLOWED_ARG_METHOD_PARAMETER, NSF_FALSE,
                          &parsedParam, NULL);
  if (unlikely(result != TCL_OK)) {
    return result;
  }

  if (parsedParam.paramDefs != NULL) {
    /*
     * Parameter handling is needed.
     */
    result = NsfAsmProcAddParam(interp, &parsedParam, nameObj, body, with_ad, with_checkAlways);

  } else {
    /*
     * No parameter handling needed.
     */
    result = NsfAsmProcAddArgs(interp, arguments, nameObj, body, with_ad, with_checkAlways);
  }

  return result;
}
#endif

/*
cmd "cmd::info" NsfCmdInfoCmd {
  {-argName "subcmd" -required 1 -typeName "methodgetcmd" -type "args|body|definition|exists|registrationhandle|definitionhandle|origin|parameter|syntax|type|precondition|postcondition|submethods|returns"}
  {-argName "-context" -required 0 -type object}
  {-argName "methodName" -required 1 -type tclobj}
  {-argName "pattern" -required 0}
} {-nxdoc 1}
*/
static int
NsfCmdInfoCmd(Tcl_Interp *interp, InfomethodsubcmdIdx_t subcmd, NsfObject *contextObject,
              Tcl_Obj *methodNameObj, const char *pattern) {

  nonnull_assert(interp != NULL);
  nonnull_assert(methodNameObj != NULL);

  return ListMethodResolve(interp, subcmd, contextObject, pattern, NULL, NULL, methodNameObj, NSF_FALSE);
}

/*
cmd configure NsfConfigureCmd {
  {-argName "option" -required 1 -type "debug|dtrace|filter|profile|softrecreate|objectsystems|keepcmds|checkresults|checkarguments"}
  {-argName "value" -required 0 -type tclobj}
}
*/
static int
NsfConfigureCmd(Tcl_Interp *interp, ConfigureoptionIdx_t option, Tcl_Obj *valueObj) {
  int boolVal;

  nonnull_assert(interp != NULL);
#if defined(NSF_DTRACE)
  if (NSF_DTRACE_CONFIGURE_PROBE_ENABLED()) {
    NSF_DTRACE_CONFIGURE_PROBE((char *)Nsf_Configureoption[option-1],
                               (valueObj != NULL) ? ObjStr(valueObj) : NULL);
  }
#endif

  if (option == ConfigureoptionObjectsystemsIdx) {
    NsfObjectSystem *osPtr;
    Tcl_Obj         *list = Tcl_NewListObj(0, NULL);

    for (osPtr = RUNTIME_STATE(interp)->objectSystems; osPtr != NULL; osPtr = osPtr->nextPtr) {
      Tcl_Obj *osObj = Tcl_NewListObj(0, NULL);
      Tcl_Obj *systemMethods = Tcl_NewListObj(0, NULL);
      int      idx;

      Tcl_ListObjAppendElement(interp, osObj, osPtr->rootClass->object.cmdName);
      Tcl_ListObjAppendElement(interp, osObj, osPtr->rootMetaClass->object.cmdName);

      for (idx = 0; Nsf_SystemMethodOpts[idx]; idx++) {
        /*fprintf(stderr, "opt %s %s\n", Nsf_SystemMethodOpts[idx],
          osPtr->methods[idx] ? ObjStr(osPtr->methods[idx]) : "NULL");*/
        if (osPtr->methods[idx] == NULL) {
          continue;
        }
        Tcl_ListObjAppendElement(interp, systemMethods, Tcl_NewStringObj(Nsf_SystemMethodOpts[idx], -1));
        if (osPtr->handles[idx] || osPtr->protected[idx]) {
          Tcl_Obj *listObj = Tcl_NewListObj(0, NULL);

          Tcl_ListObjAppendElement(interp, listObj, osPtr->methods[idx]);
          Tcl_ListObjAppendElement(interp, listObj, osPtr->handles[idx]);
          if (osPtr->protected[idx]) {
            Tcl_ListObjAppendElement(interp, listObj, Tcl_NewIntObj(1));
          }
          Tcl_ListObjAppendElement(interp, systemMethods, listObj);
        } else {
          Tcl_ListObjAppendElement(interp, systemMethods, osPtr->methods[idx]);
        }
      }
      Tcl_ListObjAppendElement(interp, osObj, systemMethods);
      Tcl_ListObjAppendElement(interp, list, osObj);
    }
    Tcl_SetObjResult(interp, list);
    return TCL_OK;
  }

  if (option == ConfigureoptionDebugIdx) {

    if (valueObj != NULL) {
      int level, result = Tcl_GetIntFromObj(interp, valueObj, &level);

      if (unlikely(result != TCL_OK)) {
        return result;
      }
      RUNTIME_STATE(interp)->logSeverity = level;
    }
    Tcl_SetIntObj(Tcl_GetObjResult(interp),
                  RUNTIME_STATE(interp)->logSeverity);

    return TCL_OK;
  }

  /*
   * All other configure options are boolean.
   */
  if (valueObj != NULL) {
    int result = Tcl_GetBooleanFromObj(interp, valueObj, &boolVal);
    if (unlikely(result != TCL_OK)) {
      return result;
    }
  }

  switch (option) {

  case ConfigureoptionDebugIdx: NSF_FALL_THROUGH; /* fall through */
  case ConfigureoptionObjectsystemsIdx:
    /*
     * Handled above.
     */
    break;

  case ConfigureoptionDtraceIdx:
    /*
     * Not implemented.
     */
    break;

  case ConfigureoptionNULL:
    /*
     * Detects whether an option was given.  Do nothing.
     */
    break;

  case ConfigureoptionFilterIdx:
    Tcl_SetBooleanObj(Tcl_GetObjResult(interp),
                      (RUNTIME_STATE(interp)->doFilters));
    if (valueObj != NULL) {
      RUNTIME_STATE(interp)->doFilters = boolVal;
    }
    break;

  case ConfigureoptionSoftrecreateIdx:
    Tcl_SetBooleanObj(Tcl_GetObjResult(interp),
                      (RUNTIME_STATE(interp)->doSoftrecreate));
    if (valueObj != NULL) {
      RUNTIME_STATE(interp)->doSoftrecreate = boolVal;
    }
    break;

  case ConfigureoptionKeepcmdsIdx:
    Tcl_SetBooleanObj(Tcl_GetObjResult(interp),
                      (RUNTIME_STATE(interp)->doKeepcmds));
    if (valueObj != NULL) {
      RUNTIME_STATE(interp)->doKeepcmds = boolVal;
    }
    break;

  case ConfigureoptionCheckresultsIdx:
    Tcl_SetBooleanObj(Tcl_GetObjResult(interp),
                      (RUNTIME_STATE(interp)->doCheckResults));
    if (valueObj != NULL) {
      RUNTIME_STATE(interp)->doCheckResults = (unsigned int)boolVal;
    }
    break;

  case ConfigureoptionCheckargumentsIdx:
    Tcl_SetBooleanObj(Tcl_GetObjResult(interp),
                      (RUNTIME_STATE(interp)->doCheckArguments) != 0);
    if (valueObj != NULL) {
      RUNTIME_STATE(interp)->doCheckArguments = (boolVal != 0) ? NSF_ARGPARSE_CHECK : 0;
    }
    break;

  }
  return TCL_OK;
}


/*
cmd colon NsfColonCmd {
  {-argName "args" -type allargs}
}
*/
static int
NsfColonCmd(Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
  const char *methodName = ObjStr(objv[0]);
  NsfObject  *self;
  int         result;

  nonnull_assert(interp != NULL);

  self = GetSelfObj(interp);
  if (unlikely(self == NULL)) {
    return NsfNoCurrentObjectError(interp, methodName);
  }
  /*fprintf(stderr, "Colon dispatch %s.%s (%d)\n",
    ObjectName(self), ObjStr(nobjv[0]), nobjc);*/

  if (likely(!(*methodName == ':' && *(methodName + 1) == '\0'))) {
    /*
     * ObjectDispatch() dispatches a method like ":foo".
     */
    result = ObjectDispatch(self, interp, objc, objv, NSF_CM_NO_SHIFT);

  } else {

    /*
     * The method name is a single colon and might have one or more arguments.
     */
    if (objc <= 1) {
      /*
       * Single colon with no arguments.
       */
      Tcl_SetObjResult(interp, self->cmdName);
      result = TCL_OK;

    } else {
      /*
       * Single colon with multiple arguments.
       */
      methodName = ObjStr(objv[1]);
      if (*methodName != '-') {
        /*
         * No need to parse arguments, e.g. local, intrinsic, etc.
         */
        result = ObjectDispatch(self, interp, objc, objv, 0u);
      } else {
        ParseContext pc;

        /*
         * Parse arguments using definitions from nsf::my.
         */
        result = ArgumentParse(interp, objc, objv, NULL, objv[0],
                               method_definitions[NsfMyCmdIdx].paramDefs,
                               method_definitions[NsfMyCmdIdx].nrParameters,
                               0, NSF_ARGPARSE_BUILTIN, &pc);
        if (likely(result == TCL_OK)) {
          int      withIntrinsic, withLocal, withSystem;
          Tcl_Obj *methodObj;

          withIntrinsic = (int)PTR2INT(pc.clientData[0]);
          withLocal     = (int)PTR2INT(pc.clientData[1]);
          withSystem    = (int)PTR2INT(pc.clientData[2]);
          methodObj     = (Tcl_Obj *)pc.clientData[3];

          assert(pc.status == 0);

          if ((withIntrinsic && withLocal)
              || (withIntrinsic && withSystem)
              || (withLocal && withSystem)) {
            result = NsfPrintError(interp, "flags '-intrinsic', '-local' and '-system' are mutual exclusive");
          } else {
            unsigned int flags;

            flags = NSF_CSC_IMMEDIATE;
            if (withIntrinsic != 0) {
              flags |= NSF_CM_INTRINSIC_METHOD;
            }
            if (withLocal != 0)     {
              flags |= NSF_CM_LOCAL_METHOD;
            }
            if (withSystem != 0)    {
              flags |= NSF_CM_SYSTEM_METHOD;
            }
            result = CallMethod(self, interp, methodObj, (objc - pc.lastObjc) + 2, objv + pc.lastObjc, flags);
          }
        }
      }
    }
  }
  return result;
}

/*
cmd "definitionnamespace" NsfDefinitionNamespaceCmd {
}
*/
static int
NsfDefinitionNamespaceCmd(Tcl_Interp *interp)
{
  Tcl_Namespace *nsPtr;

  nonnull_assert(interp != NULL);

  nsPtr = CallingNameSpace(interp);
  Tcl_SetObjResult(interp, Tcl_NewStringObj(nsPtr->fullName, -1));

  return TCL_OK;
}


/*
cmd "directdispatch" NsfDirectDispatchCmd {
  {-argName "object" -required 1 -type object}
  {-argName "-frame" -required 0 -nrargs 1 -type "method|object|default" -default "default"}
  {-argName "command" -required 1 -type tclobj}
  {-argName "args"  -type args}
}
*/
static int
NsfDirectDispatchCmd(Tcl_Interp *interp, NsfObject *object, FrameIdx_t withFrame,
                     Tcl_Obj *commandObj, int trailingObjc, Tcl_Obj *const trailingObjv[]) {
  int result;
  const char     *methodName;
  Tcl_Command     cmd, importedCmd;
  CallFrame       frame, *framePtr = &frame;
  Tcl_ObjCmdProc *proc;
  unsigned int    flags = 0u;
  bool            useCmdDispatch = NSF_TRUE;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(commandObj != NULL);

  /*fprintf(stderr, "NsfDirectDispatchCmd obj=%s, cmd m='%s' oc %d\n", ObjectName(object), methodName, nobjc);*/

  methodName = ObjStr(commandObj);
  if (unlikely(*methodName != ':')) {
    return NsfPrintError(interp, "method name '%s' must be fully qualified", methodName);
  }

  /*
   * A fully-qualified name of a Tcl command to be dispatched.
   */

  cmd = Tcl_GetCommandFromObj(interp, commandObj);
  if (likely(cmd != NULL)) {
    importedCmd = TclGetOriginalCommand(cmd);
    if (unlikely(importedCmd != NULL)) {
      cmd = importedCmd;
    }
  }

  if (unlikely(cmd == NULL)) {
    return NsfPrintError(interp, "cannot lookup command '%s'", methodName);
  }

  proc = Tcl_Command_objProc(cmd);
  if (proc == TclObjInterpProc ||
      proc == NsfForwardMethod ||
      proc == NsfObjscopedMethod ||
      proc == NsfSetterMethod ||
      CmdIsNsfObject(cmd)) {

    if (withFrame && withFrame != FrameDefaultIdx) {
      return NsfPrintError(interp, "cannot use -frame object|method in dispatch for command '%s'",
                           methodName);
    }
    useCmdDispatch = NSF_FALSE;
  } else {
    if (unlikely(withFrame == FrameMethodIdx)) {
      useCmdDispatch = NSF_FALSE;
    }
  }

  /*
   * If "withFrame == FrameObjectIdx" is given, push a call stack to make
   * instance variables accessible to the command.
   */
  if (unlikely(withFrame == FrameObjectIdx)) {
    Nsf_PushFrameObj(interp, object, framePtr);
    flags = NSF_CSC_IMMEDIATE;
  }
  /*
   * Since trailingObjv is the complete sequence of arguments, avoid a
   * memcopy() by including the cmd name in the objv.
   */
  if (useCmdDispatch) {

    if (NSF_DTRACE_METHOD_ENTRY_ENABLED()) {
      NSF_DTRACE_METHOD_ENTRY(ObjectName(object),
                              "",
                              (char *)methodName,
                              trailingObjc, (Tcl_Obj **)trailingObjv);
    }

    result = CmdMethodDispatch(object, interp, trailingObjc + 1, trailingObjv - 1,
                               object, cmd, NULL);
  } else {
    /*
     * If "withFrame == FrameMethodIdx" is given, a call-stack frame is pushed
     * to make instance variables accessible to the command.
     */
    if (unlikely(withFrame == FrameMethodIdx)) {
      flags = NSF_CSC_FORCE_FRAME|NSF_CSC_IMMEDIATE;
    }

    result = MethodDispatch(interp, trailingObjc + 1, trailingObjv - 1, cmd, object,
                            NULL /*NsfClass *cl*/,
                            Tcl_GetCommandName(interp, cmd),
                            NSF_CSC_TYPE_PLAIN, flags);
  }

  if (unlikely(withFrame == FrameObjectIdx)) {
    Nsf_PopFrameObj(interp, framePtr);
  }

  return result;
}


/*
cmd "dispatch" NsfDispatchCmd {
  {-argName "object" -required 1 -type object}
  {-argName "-intrinsic" -required 0 -nrargs 0}
  {-argName "-system" -required 0 -nrargs 0}
  {-argName "command" -required 1 -type tclobj}
  {-argName "args"  -type args}
}
*/
static int
NsfDispatchCmd(Tcl_Interp *interp, NsfObject *object,
               int withIntrinsic, int withSystem,
               Tcl_Obj *commandObj,
               int trailingObjc, Tcl_Obj *const trailingObjv[]) {
  unsigned int    flags = NSF_CM_NO_UNKNOWN|NSF_CSC_IMMEDIATE|NSF_CM_IGNORE_PERMISSIONS|NSF_CM_NO_SHIFT;
  Tcl_Obj *const *objv = trailingObjv-1;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(commandObj != NULL);

  /*
   * Use the construct "tclobj" + "args" in the spec to enforce that at least a
   * commandName is given, which allows empty "args" and can provide a nice
   * error message if cmdName is not given. Since commandObj is right before
   * "args" in objv, can decrement nobjv and increment nobjc to obtain objv.
   * Still, make sure that this assumption is correct.
   */
  assert(objv[0] == commandObj);
  assert(ISOBJ_(commandObj));

  trailingObjc++;

#if 0
  {int i;
  fprintf(stderr, "NsfDispatchCmd %s method %s oc %2d", ObjectName(object), ObjStr(commandObj), trailingObjc);
  for(i = 0; i < trailingObjc; i++) {fprintf(stderr, " [%d]=%s,", i, ObjStr(trailingObjv[i]));}
  fprintf(stderr, "\n");
  }
#endif

  if (unlikely(withIntrinsic && withSystem)) {
    return NsfPrintError(interp, "flags '-intrinsic' and '-system' are mutual exclusive");
  }

  /*
   * Dispatch the method from the precedence order, with filters etc., which
   * strictly speaking is unnecessary, but this function might be used to call
   * protected methods and provide the flags '-intrinsics' and '-system'.
   */

  if (withIntrinsic != 0) {
    flags |= NSF_CM_INTRINSIC_METHOD;
  }
  if (withSystem != 0) {
    flags |= NSF_CM_SYSTEM_METHOD;
  }

  /*
   * Since objv contains the complete sequence of arguments, avoid a memcopy()
   * by using nobjv-1 to include the cmd name that is in objv.
   */
  return ObjectDispatch(object, interp,  trailingObjc, objv, flags);
}

/*
cmd finalize NsfFinalizeCmd {
  {-argName "-keepvars" -required 0 -nrargs 0}
}
*/
static int
NsfFinalizeCmd(Tcl_Interp *interp, int withKeepvars) {
  int result;

  /* fprintf(stderr, "#### (%lx) NsfFinalizeCmd exitHandlerRound %d\n",
     (long)(void*)pthread_self(), RUNTIME_STATE(interp)->exitHandlerDestroyRound );*/

  nonnull_assert(interp != NULL);

#if defined(NSF_PROFILE)
  /*
   * Check whether profile trace is still running. If so, delete it here.
   * Interestingly, NsfLog() seems to be unavailable at this place.
   */
  if (RUNTIME_STATE(interp)->doTrace == 1) {
    NsfLog(interp, NSF_LOG_WARN, "tracing is still active; deactivate it due to cleanup.");
    NsfProfileTrace(interp, 0, 0, 0, NULL);
  }
#endif

#if defined(NSF_STACKCHECK)
  {NsfRuntimeState *rst = RUNTIME_STATE(interp);

    NsfLog(interp, NSF_LOG_WARN, "Stack max usage %ld",
           labs(rst->maxStack - rst->bottomOfStack));
  }
#endif

  /*fprintf(stderr, "+++ call tcl-defined exit handler (%x)\n", PTR2INT(pthread_self()));*/

  /*
   * Evaluate user-defined exit handler.
   */
  result = Tcl_Eval(interp, "::nsf::__exithandler");

  if (unlikely(result != TCL_OK)) {
    fprintf(stderr, "User defined exit handler contains errors!\n"
            "Error in line %d: %s\nExecution interrupted.\n",
            (int)Tcl_GetErrorLine(interp), ObjStr(Tcl_GetObjResult(interp)));
  }

  ObjectSystemsCleanup(interp, withKeepvars ? NSF_TRUE : NSF_FALSE);


#ifdef DO_CLEANUP
  {
    NsfRuntimeState *rst = RUNTIME_STATE(interp);

# if defined(CHECK_ACTIVATION_COUNTS)
    assert(rst->cscList == NULL);
# endif
    /*fprintf(stderr, "CLEANUP TOP NS\n");*/
    Tcl_Export(interp, rst->NsfNS, "", 1);
    if (rst->NsfClassesNS != NULL) {
      MEM_COUNT_FREE("TclNamespace", rst->NsfClassesNS);
      Tcl_DeleteNamespace(rst->NsfClassesNS);
    }
    if (rst->NsfNS != NULL) {
      MEM_COUNT_FREE("TclNamespace", rst->NsfNS);
      Tcl_DeleteNamespace(rst->NsfNS);
    }

    {
      NsfDList *dlPtr = &rst->freeDList;
      size_t    i;

#if defined(COLON_CMD_STATS)
      fprintf(stderr, "#### DList free size %lu avail %lu\n", dlPtr->size, dlPtr->avail);
#endif
      for (i = 0u; i < dlPtr->size; i++) {
        /*
           fprintf(stderr, "#### DList free data[%lu] %p: %p\n", i,
           (void*)&(dlPtr->data[i]), (void*)dlPtr->data[i]);
        */
        NsfColonCmdContextFree(dlPtr->data[i]);
      }
      NsfDListFree(dlPtr);
    }
  }
#endif
  return TCL_OK;
}


/*
cmd interp NsfInterpObjCmd {
  {-argName "name"}
  {-argName "args" -type allargs}
}
*/
/*
 * Creates a slave interp that calls Next Scripting Init.
 */
static int
NsfInterpObjCmd(Tcl_Interp *interp, const char *name, int objc, Tcl_Obj *const objv[]) {

  nonnull_assert(interp != NULL);
  nonnull_assert(name != NULL);

  /*
   * Create a fresh Tcl interpreter, or pass the command for an existing one.
   */
  if (unlikely(NsfCallCommand(interp, NSF_INTERP, objc, objv) != TCL_OK)) {
    return TCL_ERROR;
  }

  /*
   * Upon [interp create], run Nsf_Init() for the new interp.
   */

  if (isCreateString(name)) {
    Tcl_Obj    *slaveCmdObj;
    Tcl_Interp *slavePtr;

    /*
     * Tcl_InterpObjCmd() stores the newly-created child interp's command name
     * in the interp result store.
     */

    slaveCmdObj = Tcl_GetObjResult(interp);
    slavePtr = Tcl_GetSlave(interp, ObjStr(slaveCmdObj));

    if (slavePtr == NULL) {
      return NsfPrintError(interp, "creation of slave interpreter failed");
    }
    if (unlikely(Nsf_Init(slavePtr) == TCL_ERROR)) {
      return TCL_ERROR;
    }
  }
  return TCL_OK;
}

/*
cmd is NsfIsCmd {
  {-argName "-complain"  -nrargs 0}
  {-argName "-configure" -nrargs 0}
  {-argName "-name" -required 0}
  {-argName "constraint" -required 1 -type tclobj}
  {-argName "value" -required 1 -type tclobj}
} {-nxdoc 1}
*/
static int
NsfIsCmd(Tcl_Interp *interp,
         int withComplain,
         int withConfigure,
         const char *withName,
         Tcl_Obj *constraintObj,
         Tcl_Obj *valueObj) {
  Nsf_Param *paramPtr = NULL;
  int        result;

  nonnull_assert(interp != NULL);
  nonnull_assert(constraintObj != NULL);
  nonnull_assert(valueObj != NULL);

  result = ParameterCheck(interp, constraintObj, valueObj,
                          (withName != NULL) ? withName : "value:", 1,
                          (withName != NULL),
                          (withConfigure == 1),
                          &paramPtr,
                          Tcl_GetCurrentNamespace(interp)->fullName);

  if (unlikely(paramPtr == NULL)) {
    /*
     * Even with noComplain the arguments could not be converted.  Report the
     * invalid converter specification as an exception.
     */
    result = TCL_ERROR;

  } else {
    if (paramPtr->converter == ConvertViaCmd
        && (withComplain == 0 || result == TCL_OK)) {
      Tcl_ResetResult(interp);
    }

    if (withComplain == 0) {
      Tcl_SetIntObj(Tcl_GetObjResult(interp), (result == TCL_OK));
      result = TCL_OK;
    } else if (likely(result == TCL_OK)) {
      Tcl_SetIntObj(Tcl_GetObjResult(interp), 1);
    }
  }

  return result;
}

/*
cmd parseargs NsfParseArgsCmd {
  {-argName "argspec" -required 1 -type tclobj}
  {-argName "arglist" -required 1 -type tclobj}
} {-nxdoc 0}
*/
static int
NsfParseArgsCmd(Tcl_Interp *interp, Tcl_Obj *argspecObj, Tcl_Obj *arglistObj) {
  NsfParsedParam   parsedParam;
  Tcl_Obj        **objv;
  int              result, objc;

  result = ParamDefsParse(interp, NsfGlobalObjs[NSF_PARSE_ARGS], argspecObj,
                          NSF_DISALLOWED_ARG_METHOD_PARAMETER,
                          NSF_TRUE /* force use of param structure,
                                      even for Tcl-only params */,
                          &parsedParam, Tcl_GetCurrentNamespace(interp)->fullName);

  if (unlikely(result != TCL_OK)) {
    return result;
  }

  result = Tcl_ListObjGetElements(interp, arglistObj, &objc, &objv);

  if (likely(result == TCL_OK) && parsedParam.paramDefs != NULL) {
    ParseContext  pc;
    NsfParamDefs *paramDefs = parsedParam.paramDefs;
    unsigned int  processFlags = 0u;

    ParamDefsRefCountIncr(paramDefs);
    result = ArgumentParse(interp, objc, objv, NULL, NsfGlobalObjs[NSF_PARSE_ARGS],
                           paramDefs->paramsPtr, paramDefs->nrParams, paramDefs->serial,
                           processFlags|NSF_ARGPARSE_START_ZERO|RUNTIME_STATE(interp)->doCheckArguments,
                           &pc);

    if (result == TCL_OK) {
      Nsf_Param *paramPtr;
      Tcl_Obj   *resultObj;
      int        i;

      for (i = 0, paramPtr = paramDefs->paramsPtr; paramPtr->name != NULL; paramPtr++, i++) {
        Tcl_Obj *valueObj = pc.objv[i];

        if (valueObj != NsfGlobalObjs[NSF___UNKNOWN__]) {
          /*fprintf(stderr, "param %s -> <%s>\n", paramPtr->name,  ObjStr(valueObj));*/
          resultObj = Tcl_ObjSetVar2(interp, paramPtr->nameObj, NULL, valueObj, TCL_LEAVE_ERR_MSG);
          if (resultObj == NULL) {
            result = TCL_ERROR;
            break;
          }
        }
      }
    }
    ParamDefsRefCountDecr(paramDefs);
    ParseContextRelease(&pc);
  }
  return result;
}

/*
cmd method::alias NsfMethodAliasCmd {
  {-argName "object" -type object}
  {-argName "-per-object"}
  {-argName "methodName"}
  {-argName "-frame" -required 0 -nrargs 1 -type "method|object|default" -default "default"}
  {-argName "-protection" -required 0 -type "call-protected|redefine-protected|none" -default "none"}
  {-argName "cmdName" -required 1 -type tclobj}
}
*/
static int
NsfMethodAliasCmd(
    Tcl_Interp *interp, NsfObject *object, int withPer_object,
    const char *methodName, FrameIdx_t withFrame, ProtectionIdx_t withProtection,
    Tcl_Obj *cmdNameObj
) {
  Tcl_ObjCmdProc     *objProc, *newObjProc;
  Tcl_CmdDeleteProc  *deleteProc;
  AliasCmdClientData *tcd;
  Tcl_Command         cmd, oldCmd, newCmd;
  Tcl_Namespace      *nsPtr;
  int                 result;
  unsigned int        flags = 0u;
  const NsfClass     *class;
  NsfObject          *newTargetObject;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodName != NULL);
  assert(*methodName != ':');
  nonnull_assert(cmdNameObj != NULL);

  cmd = Tcl_GetCommandFromObj(interp, cmdNameObj);
  if (cmd == NULL) {
    return NsfPrintError(interp, "cannot lookup command '%s'", ObjStr(cmdNameObj));
  }

  cmd = GetOriginalCommand(cmd);
  objProc = Tcl_Command_objProc(cmd);
  assert(objProc != NULL);

  /*
   * objProc is either ...
   *
   *     NsfObjDispatch
   *
   *        A command for a Next Scripting object.
   *
   *     TclObjInterpProc
   *
   *       A command for a Tcl proc, including Next Scripting methods, verified
   *       through CmdIsProc() and to be wrapped by NsfProcAliasMethod().
   *
   *     NsfForwardMethod
   *       A Next Scripting forwarder.
   *
   *     NsfSetterMethod
   *        A Next Scripting setter.
   *
   *     Arbitrary Tcl commands (e.g. set, ..., ::nsf::relation, etc.
   *
   */

  if (withFrame == FrameObjectIdx) {
    newObjProc = NsfObjscopedMethod;
  } else {
    newObjProc = NULL;
  }

  /*
   * Just in case, look for a previously-defined object alias under the given
   * methodName.
   */
  class = (withPer_object || ! NsfObjectIsClass(object)) ? NULL : (NsfClass *)object;

  nsPtr = (class != NULL) ? class->nsPtr : object->nsPtr;
  oldCmd = (nsPtr != NULL) ? FindMethod(nsPtr, methodName) : NULL;
  newTargetObject = NsfGetObjectFromCmdPtr(cmd);

  if (oldCmd != NULL) {
#if 1
    /*
     * Old solution, which leads to a broken regression test with Tcl 8.7a1.
     * However, using Tcl_DeleteCommandFromToken() also leads to a crash with
     * earlier solutions when defining a recursive aliase.
     */
    NsfObject *oldTargetObject;

    /*fprintf(stderr, "... DELETE preexisting cmd %s in ns %s\n", methodName, nsPtr->fullName);*/

    oldTargetObject = NsfGetObjectFromCmdPtr(oldCmd);
    /* fprintf(stderr, "oldTargetObject %p flags %.6x newTargetObject %p\n",
       oldTargetObject, (oldTargetObject != NULL) ? oldTargetObject->flags : 0, newTargetObject);*/

    /*
     * It might be necessary to decrement the reference counter on a
     * previously- aliased object. Decrement the reference count to the old
     * aliased object only if it is not the new target Object.
     */

    if (oldTargetObject != NULL && oldTargetObject != newTargetObject) {
      /*fprintf(stderr, "--- releasing old target object %p refCount %d\n",
        oldTargetObject, oldTargetObject->refCount);*/
      assert(oldTargetObject->refCount > 0);
      AliasDeleteObjectReference(interp, oldCmd);
    }

#else
    Tcl_DeleteCommandFromToken(interp, oldCmd);
#endif

  }

  if (newTargetObject != NULL) {
    /*
     * For each alias to an object, set a stub proc to distinguish between
     * cases where the user wants to create a method and where
     * object-invocation via method interface might happen.
     */
    newObjProc = NsfProcAliasMethod;

  } else if (CmdIsProc(cmd)) {
    /*
     * For a Tcl proc|Nsf-method as an alias, use the wrapper, which is deleted
     * automatically when the original proc/method is deleted.
     */
    newObjProc = NsfProcAliasMethod;

    if (objProc == TclObjInterpProc) {
      /*
       * An alias to a Tcl proc.
       */
      Proc    *procPtr = (Proc *)Tcl_Command_objClientData(cmd);
      Tcl_Obj *bodyObj = (procPtr != NULL) ? procPtr->bodyPtr : NULL;

      if (bodyObj && bodyObj->typePtr == Nsf_OT_byteCodeType) {
        /*
         * Flush old byte code.
         */
        /*fprintf(stderr, "flush byte code\n");*/
        TclFreeIntRep(bodyObj);
      }
    }

    if (withFrame && withFrame != FrameDefaultIdx) {
      return NsfPrintError(interp,
                          "cannot use -frame object|method in alias for scripted command '%s'",
                           ObjStr(cmdNameObj));
    }
  }

  if (newObjProc != NULL) {
    /*
     * Add a wrapper.
     */
    /*fprintf(stderr, "NsfMethodAliasCmd add wrapper cmd %p\n", cmd);*/
    NsfCommandPreserve(cmd);
    tcd = NEW(AliasCmdClientData);
    tcd->cmdName    = object->cmdName;
    tcd->interp     = interp; /* just for deleting the alias */
    tcd->object     = NULL;
    tcd->class      = (class != NULL) ? (NsfClass *) object : NULL;
    tcd->objProc    = objProc;
    tcd->aliasedCmd = cmd;
    tcd->clientData = Tcl_Command_objClientData(cmd);

    objProc         = newObjProc;
    deleteProc      = AliasCmdDeleteProc;
    if (tcd->cmdName != NULL) {
      INCR_REF_COUNT(tcd->cmdName);
    }
  } else {
    /*
     * Call the command directly.  It must be implemented in C and not depend
     * on a volatile client data.
     */
    deleteProc = NULL;
    tcd = Tcl_Command_objClientData(cmd);
    /*fprintf(stderr, "NsfMethodAliasCmd no wrapper cmd %p\n", cmd);*/
  }

  switch (withProtection) {
  case ProtectionCall_protectedIdx:     flags = NSF_CMD_CALL_PROTECTED_METHOD; break;
  case ProtectionRedefine_protectedIdx: flags = NSF_CMD_REDEFINE_PROTECTED_METHOD; break;
  case ProtectionNoneIdx: NSF_FALL_THROUGH; /* fall through */
  case ProtectionNULL:
    flags = 0u;
    break;
  }

  if (class != NULL) {
    result = NsfAddClassMethod(interp, (Nsf_Class *)class, methodName,
                               objProc, tcd, deleteProc, flags);
    nsPtr = class->nsPtr;
  } else {
    result = NsfAddObjectMethod(interp, (Nsf_Object *)object, methodName,
                                objProc, tcd, deleteProc, flags);
    nsPtr = object->nsPtr;
  }

  if (likely(result == TCL_OK)) {
    newCmd = FindMethod(nsPtr, methodName);
  } else {
    newCmd = NULL;
  }

#if defined(WITH_IMPORT_REFS)
  if (newObjProc != NULL) {
    /*
     * Define the reference chain like 'namespace import' does, so deleting the
     * original command automatically deletes the alias.
     */
    ImportRef *refPtr = (ImportRef *) ckalloc((int)sizeof(ImportRef));

    refPtr->importedCmdPtr = (Command *) newCmd;
    refPtr->nextPtr = ((Command *) tcd->aliasedCmd)->importRefPtr;
    ((Command *) tcd->aliasedCmd)->importRefPtr = refPtr;
    tcd->aliasCmd = newCmd;
  }
#else
  if (newObjProc != NULL) {
    tcd->aliasCmd = newCmd;
  }
#endif

  if (newCmd != NULL) {
    AliasAdd(interp, object->cmdName, methodName, class == NULL, cmdNameObj);

    if (withFrame == FrameMethodIdx) {
      Tcl_Command_flags(newCmd) |= NSF_CMD_NONLEAF_METHOD;
      /*fprintf(stderr, "setting aliased for cmd %p %s flags %.6x, tcd = %p\n",
        newCmd, methodName, Tcl_Command_flags(newCmd), tcd);*/
    }

    Tcl_SetObjResult(interp, MethodHandleObj(object, class == NULL, methodName));
    result = TCL_OK;
  }

  return result;
}

/*
cmd method::assertion NsfMethodAssertionCmd {
  {-argName "object" -type object}
  {-argName "assertionsubcmd" -required 1 -type "check|object-invar|class-invar"}
  {-argName "arg" -required 0 -type tclobj}
}

  Make "::nsf::assertion" a cmd rather than a method so that, e.g. "method
  check options {...}" can be defined to reset the check options in case of a
  failed option, since assertion checking would be applied on the sketched
  method already.
*/

static int
NsfMethodAssertionCmd(Tcl_Interp *interp, NsfObject *object, AssertionsubcmdIdx_t subcmd, Tcl_Obj *argObj) {
#if defined(NSF_WITH_ASSERTIONS)
  NsfClass *class;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  switch (subcmd) {
  case AssertionsubcmdCheckIdx:
    if (argObj != NULL) {
      return AssertionSetCheckOptions(interp, object, argObj);
    } else {
      return AssertionListCheckOption(interp, object);
    }
    /*break; unreachable */

  case AssertionsubcmdObject_invarIdx:
    if (argObj != NULL) {
      NsfObjectOpt *opt = NsfRequireObjectOpt(object);

      AssertionSetInvariants(interp, &opt->assertions, argObj);
    } else {
      if (object->opt != NULL && object->opt->assertions != NULL) {
        Tcl_SetObjResult(interp, AssertionList(interp, object->opt->assertions->invariants));
      }
    }
    break;

  case AssertionsubcmdClass_invarIdx:

    if (!NsfObjectIsClass(object)) {
      return NsfPrintError(interp, "object is not a class");
    }

    class = (NsfClass *)object;
    if (argObj != NULL) {
      NsfClassOpt *opt = NsfRequireClassOpt(class);

      AssertionSetInvariants(interp, &opt->assertions, argObj);
    } else {
      if (class->opt != NULL && class->opt->assertions != NULL) {
        Tcl_SetObjResult(interp, AssertionList(interp, class->opt->assertions->invariants));
      }
    }

  case AssertionsubcmdNULL:
    /*
     * Do nothing.  Just detects whether the option was given.
     */
    break;
  }
#endif
  return TCL_OK;
}

/*
cmd method::create NsfMethodCreateCmd {
  {-argName "object" -required 1 -type object}
  {-argName "-checkalways" -required 0 -nrargs 0 -type switch}
  {-argName "-inner-namespace"}
  {-argName "-per-object"}
  {-argName "-reg-object" -required 0 -nrargs 1 -type object}
  {-argName "name" -required 1 -type tclobj}
  {-argName "arguments" -required 1 -type tclobj}
  {-argName "body" -required 1 -type tclobj}
  {-argName "-precondition"  -nrargs 1 -type tclobj}
  {-argName "-postcondition" -nrargs 1 -type tclobj}
}
*/
static int
NsfMethodCreateCmd(Tcl_Interp *interp, NsfObject *object,
                   int withCheckalways, int withInner_namespace,
                   int withPer_object, NsfObject *regObject,
                   Tcl_Obj *methodNameObj, Tcl_Obj *argumentsObj, Tcl_Obj *bodyObj,
                   Tcl_Obj *preconditionObj, Tcl_Obj *postconditionObj) {
  NsfClass *class;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodNameObj != NULL);
  nonnull_assert(argumentsObj != NULL);
  nonnull_assert(bodyObj != NULL);

  class = (withPer_object || ! NsfObjectIsClass(object)) ? NULL : (NsfClass *)object;
  if (class == NULL) {
    RequireObjNamespace(interp, object);

  }
  return MakeMethod(interp, object, regObject, class,
                    methodNameObj, argumentsObj, bodyObj,
                    preconditionObj, postconditionObj,
                    withInner_namespace, (withCheckalways != 0) ? NSF_ARGPARSE_CHECK : 0);
}

/*
cmd "method::delete" NsfMethodDeleteCmd {
  {-argName "object" -required 1 -type object}
  {-argName "-per-object"}
  {-argName "methodName" -required 1 -type tclobj}
}
*/
static int
NsfMethodDeleteCmd(Tcl_Interp *interp, NsfObject *object, int withPer_object,
                   Tcl_Obj *methodNameObj) {
  NsfObject      *regObject, *defObject;
  const char     *methodName1 = NULL;
  const NsfClass *class;
  bool            fromClassNS;
  int             result;
  Tcl_DString     ds, *dsPtr = &ds;
  Tcl_Command     cmd;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodNameObj != NULL);

  class = withPer_object == 0 && NsfObjectIsClass(object) ? (NsfClass *)object : NULL;
  fromClassNS = (class != NULL);

  Tcl_DStringInit(dsPtr);

  cmd = ResolveMethodName(interp, (class != NULL) ? class->nsPtr : object->nsPtr, methodNameObj,
                          dsPtr, &regObject, &defObject, &methodName1, &fromClassNS);

  /*fprintf(stderr,
          "NsfMethodDeleteCmd method %s '%s' object %p regObject %p defObject %p cl %p fromClass %d cmd %p\n",
          ObjStr(methodNameObj), methodName1, object, regObject, defObject, cl, fromClassNS, cmd);*/

  if (cmd != NULL) {
    methodName1 = Tcl_GetCommandName(interp, cmd);
    if (defObject != NULL) {
      class = (withPer_object == 0 && NsfObjectIsClass(defObject)) ? (NsfClass *)defObject : NULL;
    } else {
      defObject = object;
    }

    if (RUNTIME_STATE(interp)->exitHandlerDestroyRound == NSF_EXITHANDLER_OFF) {
      result = (class != NULL) ?
        NsfRemoveClassMethod(interp,  (Nsf_Class *)defObject, methodName1) :
        NsfRemoveObjectMethod(interp, (Nsf_Object *)defObject, methodName1);
    } else {
      result = TCL_OK;
    }

  } else {
    result = NsfPrintError(interp, "%s: %s method '%s' does not exist",
                           ObjectName_(object), (withPer_object == 1) ? "object specific" : "instance",
                           ObjStr(methodNameObj));
  }

  Tcl_DStringFree(dsPtr);

  return result;
}

/*
cmd method::forward NsfMethodForwardCmd {
  {-argName "object" -required 1 -type object}
  {-argName "-per-object" -required 0 -nrargs 0 -type switch}
  {-argName "method" -required 1 -type tclobj}
  {-argName "-default" -type tclobj}
  {-argName "-earlybinding" -nrargs 0}
  {-argName "-prefix" -type tclobj}
  {-argName "-frame" -nrargs 1 -type "object|method|default" -default default}
  {-argName "-verbose" -nrargs 0}
  {-argName "target" -type tclobj}
  {-argName "args" -type args}
}
*/
static int
NsfMethodForwardCmd(Tcl_Interp *interp,
                    NsfObject *object,
                    int withPer_object,
                    Tcl_Obj *methodObj,
                    Tcl_Obj *defaultObj,
                    int withEarlybinding,
                    Tcl_Obj *onerrorObj,
                    Tcl_Obj *prefixObj,
                    FrameIdx_t withFrame,
                    int withVerbose,
                    Tcl_Obj *targetObj,
                    int trailingObjc, Tcl_Obj *const trailingObjv[]) {
  ForwardCmdClientData *tcd = NULL;
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodObj != NULL);

  result = ForwardProcessOptions(interp,
                                 methodObj,
                                 defaultObj,
                                 withEarlybinding,
                                 onerrorObj,
                                 prefixObj,
                                 (int)withFrame,
                                 (withVerbose == 1),
                                 targetObj,
                                 trailingObjc, trailingObjv,
                                 &tcd);

  if (likely(result == TCL_OK)) {
    const char *methodName = NSTail(ObjStr(methodObj));
    NsfClass *class =
      (withPer_object || ! NsfObjectIsClass(object)) ?
      NULL : (NsfClass *)object;

    tcd->object = object;

    if (class == NULL) {
      result = NsfAddObjectMethod(interp, (Nsf_Object *)object, methodName,
                                  (Tcl_ObjCmdProc *)NsfForwardMethod,
                                  tcd, ForwardCmdDeleteProc, 0u);
    } else {
      result = NsfAddClassMethod(interp, (Nsf_Class *)class, methodName,
                                 (Tcl_ObjCmdProc *)NsfForwardMethod,
                                 tcd, ForwardCmdDeleteProc, 0u);
    }
    if (likely(result == TCL_OK)) {
      Tcl_SetObjResult(interp, MethodHandleObj(object, (class == NULL), methodName));
    }
  }

  if (result != TCL_OK && tcd != NULL) {
    ForwardCmdDeleteProc(tcd);
  }
  return result;
}


/*
cmd "method::forward::property" NsfForwardPropertyCmd {
  {-argName "object" -required 1 -type object}
  {-argName "-per-object" -required 0 -nrargs 0 -type switch}
  {-argName "methodName" -required 1 -type tclobj}
  {-argName "forwardProperty" -required 1 -type "target|verbose"}
  {-argName "value" -type tclobj}
}
*/
static int
NsfForwardPropertyCmd(Tcl_Interp *interp, NsfObject *object, int withPer_object,
                     Tcl_Obj *methodNameObj, ForwardpropertyIdx_t forwardProperty, Tcl_Obj *valueObj) {
  ForwardCmdClientData *tcd;
  Tcl_ObjCmdProc       *procPtr;
  Tcl_Command           cmd;
  NsfObject            *defObject;
  const NsfClass       *class;
  bool                  fromClassNS;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodNameObj != NULL);

  class = withPer_object == 0 && NsfObjectIsClass(object) ? (NsfClass *)object : NULL;
  fromClassNS = (class != NULL);

  cmd = ResolveMethodName(interp, (class != NULL) ? class->nsPtr : object->nsPtr, methodNameObj,
                          NULL, NULL, &defObject, NULL, &fromClassNS);

  if (unlikely(cmd == NULL)) {
    return NsfPrintError(interp, "cannot lookup %smethod '%s' for %s",
                         class == NULL ? "object " : "",
                         ObjStr(methodNameObj), ObjectName_(object));
  }

  procPtr = Tcl_Command_objProc(cmd);
  if (procPtr != NsfForwardMethod) {
    return NsfPrintError(interp, "%s is not a forwarder method",
                         ObjStr(methodNameObj));
  }

  tcd = (ForwardCmdClientData *)Tcl_Command_objClientData(cmd);
  if (tcd == NULL) {
    return NsfPrintError(interp, "forwarder method has no client data");
  }

  switch (forwardProperty) {
  case ForwardpropertyTargetIdx:
    if (valueObj != NULL) {
      DECR_REF_COUNT(tcd->cmdName);
      INCR_REF_COUNT(valueObj);
      tcd->cmdName = valueObj;
    }
    Tcl_SetObjResult(interp, tcd->cmdName);
    break;

  case ForwardpropertyPrefixIdx:
    if (valueObj != NULL) {
      DECR_REF_COUNT(tcd->prefix);
      INCR_REF_COUNT(valueObj);
      tcd->prefix = valueObj;
    }
    Tcl_SetObjResult(interp, tcd->prefix);
    break;

  case ForwardpropertyVerboseIdx:
    if (valueObj != NULL) {
      int boolValue;

      Tcl_GetBooleanFromObj(interp, valueObj, &boolValue);
      tcd->verbose = (boolValue != 0);
    }
    Tcl_SetObjResult(interp, Tcl_NewBooleanObj(tcd->verbose));
    break;

  case ForwardpropertyNULL:
    /*
     * Do nothing; just for detection if option was given.
     */
    break;
  }

  return TCL_OK;
}

/*
cmd ::method::property NsfMethodPropertyCmd {
  {-argName "object" -required 1 -type object}
  {-argName "-per-object"}
  {-argName "methodName" -required 1 -type tclobj}
  {-argName "methodProperty" -required 1 -type "class-only|call-private|call-protected|debug|deprecated|exists|redefine-protected|returns"}
  {-argName "value" -type tclobj}
}
*/
static int
NsfMethodPropertyCmd(Tcl_Interp *interp, NsfObject *object, int withPer_object,
                     Tcl_Obj *methodNameObj, MethodpropertyIdx_t methodProperty, Tcl_Obj *valueObj) {
  NsfObject      *defObject;
  Tcl_Command     cmd;
  const NsfClass *class;
  bool            fromClassNS;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(methodNameObj != NULL);

  class = withPer_object == 0 && NsfObjectIsClass(object) ? (NsfClass *)object : NULL;
  fromClassNS = (class != NULL);

  cmd = ResolveMethodName(interp,
                          (class != NULL) ? class->nsPtr : object->nsPtr,
                          methodNameObj, NULL, NULL, &defObject, NULL, &fromClassNS);
  /*fprintf(stderr, "methodProperty for method '%s' prop %d value %s => cl %p cmd %p\n",
    ObjStr(methodNameObj), methodproperty, (valueObj != NULL) ? ObjStr(valueObj) : "NULL", cl, cmd);*/


  if (unlikely(cmd == NULL)) {
    if (methodProperty == MethodpropertyExistsIdx) {
      Tcl_SetObjResult(interp, Tcl_NewIntObj(0));
      return TCL_OK;
    } else {
      return NsfPrintError(interp, "cannot lookup %smethod '%s' for %s",
                           class == NULL ? "object " : "",
                           ObjStr(methodNameObj), ObjectName_(object));
    }
  }

  switch (methodProperty) {
  case MethodpropertyExistsIdx:
    Tcl_SetObjResult(interp, Tcl_NewIntObj(1));
    break;
  case MethodpropertyClass_onlyIdx:          NSF_FALL_THROUGH; /* fall through */
  case MethodpropertyCall_privateIdx:        NSF_FALL_THROUGH; /* fall through */
  case MethodpropertyCall_protectedIdx:      NSF_FALL_THROUGH; /* fall through */
  case MethodpropertyDebugIdx:               NSF_FALL_THROUGH; /* fall through */
  case MethodpropertyDeprecatedIdx:          NSF_FALL_THROUGH; /* fall through */
  case MethodpropertyRedefine_protectedIdx:
    {
      int impliedSetFlag = 0, impliedClearFlag = 0;
      unsigned int flag;

      switch (methodProperty) {
      case MethodpropertyClass_onlyIdx:
        flag = NSF_CMD_CLASS_ONLY_METHOD;
        break;
      case MethodpropertyCall_privateIdx:
        flag = NSF_CMD_CALL_PRIVATE_METHOD;
        impliedSetFlag = NSF_CMD_CALL_PROTECTED_METHOD;
        break;
      case MethodpropertyCall_protectedIdx:
        impliedClearFlag = NSF_CMD_CALL_PRIVATE_METHOD;
        flag = NSF_CMD_CALL_PROTECTED_METHOD;
        break;
      case MethodpropertyDebugIdx:
        flag = NSF_CMD_DEBUG_METHOD;
        break;
      case MethodpropertyDeprecatedIdx:
        flag = NSF_CMD_DEPRECATED_METHOD;
        break;
      case MethodpropertyRedefine_protectedIdx:
        flag = NSF_CMD_REDEFINE_PROTECTED_METHOD;
        break;
      case MethodpropertyNULL:       NSF_FALL_THROUGH; /* fall through */
      case MethodpropertyReturnsIdx: NSF_FALL_THROUGH; /* fall through */
      case MethodpropertyExistsIdx:
        flag = 0u;
        break;
      }

      if (valueObj != NULL) {
        int boolVal, result;

        result = Tcl_GetBooleanFromObj(interp, valueObj, &boolVal);
        if (unlikely(result != TCL_OK)) {
          return result;
        }
        if (boolVal != 0) {

          /*
           * Set the flag.
           */
          Tcl_Command_flags(cmd) |= (int)flag;
          if (impliedSetFlag != 0) {
            Tcl_Command_flags(cmd) |= (int)impliedSetFlag;
          }
        } else {
          /*
           * Clear the flag.
           */
          Tcl_Command_flags(cmd) &= (int)~flag;
          if (impliedClearFlag != 0) {
            Tcl_Command_flags(cmd) &= (int)~impliedClearFlag;
          }
        }
        if (class != NULL) {
          NsfInstanceMethodEpochIncr("Permissions");
        } else {
          NsfObjectMethodEpochIncr("Permissions");
        }
      }
      Tcl_SetIntObj(Tcl_GetObjResult(interp), ((unsigned int)Tcl_Command_flags(cmd) & flag) != 0u);
    }
    break;

  case MethodpropertyReturnsIdx:
    {
      NsfProcContext *pCtx = ProcContextGet(cmd);

      /*fprintf(stderr, "MethodProperty, ParamDefsGet cmd %p paramDefs %p returns %p\n",
        cmd, paramDefs, (paramDefs != NULL) ? paramDefs->returns:NULL);*/

      if (valueObj == NULL) {
        /*
         * Return the actual value for "returns".
         */
        Tcl_Obj *resultObj;

        if (pCtx == NULL || pCtx->returnsObj == NULL) {
          resultObj = NsfGlobalObjs[NSF_EMPTY];
        } else {
          resultObj = pCtx->returnsObj;
        }
        Tcl_SetObjResult(interp, resultObj);

      } else {
        /*
         * Set the value of "returns".
         */
        const char *valueString = ObjStr(valueObj);

        if (pCtx == NULL) {
          pCtx = ProcContextRequire(cmd);
        }

        /*
         * Set a new value, freeing any existing value.
         */
        if (pCtx->returnsObj != NULL) {
          DECR_REF_COUNT2("returnsObj", pCtx->returnsObj);
        }
        if (*valueString == '\0') {
          /*
           * Set returnsObj to NULL
           */
          pCtx->returnsObj = NULL;
        } else {
          pCtx->returnsObj = valueObj;
          INCR_REF_COUNT2("returnsObj", pCtx->returnsObj);
        }
      }
    }
    break;

  case MethodpropertyNULL:
    /*
     * Do nothing.  Just detects whether the option was given.
     */
    break;
  }

  return TCL_OK;
}


/*
cmd "method::registered" NsfMethodRegisteredCmd {
  {-argName "handle" -required 1 -type tclobj}
}
*/
static int
NsfMethodRegisteredCmd(Tcl_Interp *interp, Tcl_Obj *handleObj) {
  NsfObject  *regObject;
  bool        fromClassNS = NSF_FALSE;
  Tcl_Command cmd;

  nonnull_assert(interp != NULL);
  nonnull_assert(handleObj != NULL);

  cmd = ResolveMethodName(interp, NULL, handleObj,
                          NULL, &regObject, NULL, NULL, &fromClassNS);

  /*
   * If the given cmd is fully-qualified and refers to a registered method, the
   * function returns the object for the method.
   */
  Tcl_SetObjResult(interp, ((cmd != NULL) && (regObject != NULL)) ? regObject->cmdName : NsfGlobalObjs[NSF_EMPTY]);

  return TCL_OK;
}

/*
cmd method::setter NsfMethodSetterCmd {
  {-argName "object" -required 1 -type object}
  {-argName "-per-object"}
  {-argName "parameter" -type tclobj}
  }
*/
static int
NsfMethodSetterCmd(Tcl_Interp *interp, NsfObject *object, int withPer_object, Tcl_Obj *parameterObj) {
  SetterCmdClientData *setterClientData;
  const NsfClass      *class;
  const char          *methodName;
  size_t               j, length;
  int                  result;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(parameterObj != NULL);

  methodName = ObjStr(parameterObj);
  if (unlikely(*methodName == '-' || *methodName == ':')) {
    return NsfPrintError(interp, "invalid setter name \"%s\" (must not start with a dash or colon)",
                         methodName);
  }

  setterClientData = NEW(SetterCmdClientData);
  setterClientData->object = NULL;
  setterClientData->paramsPtr = NULL;

  length = strlen(methodName);

  for (j = 0; j < length; j++) {
    if (methodName[j] == ':' || NsfHasTclSpace(&methodName[j])) {
      break;
    }
  }

  class = (withPer_object || ! NsfObjectIsClass(object)) ? NULL : (NsfClass *)object;

  if (j < length) {
    /*
     * There appears to be a parameter specification.
     */
    int rc, possibleUnknowns = 0, plainParams = 0, nrNonposArgs = 0;
    NsfObject *ctx = (class != NULL) ? (NsfObject *)class : object;
    Tcl_Namespace *nsPtr = Tcl_Command_nsPtr(ctx->id);

    setterClientData->paramsPtr = ParamsNew(1u);
    rc = ParamDefinitionParse(interp, NsfGlobalObjs[NSF_SETTER], parameterObj,
                              NSF_DISALLOWED_ARG_SETTER|NSF_ARG_HAS_DEFAULT,
                              setterClientData->paramsPtr, &possibleUnknowns,
                              &plainParams, &nrNonposArgs,
                              nsPtr != NULL ? nsPtr->fullName : NULL);

    if (unlikely(rc != TCL_OK)) {
      SetterCmdDeleteProc(setterClientData);
      return rc;
    }
    methodName = setterClientData->paramsPtr->name;
  } else {
    setterClientData->paramsPtr = NULL;
  }

  if (class != NULL) {
    result = NsfAddClassMethod(interp, (Nsf_Class *)class, methodName,
                               (Tcl_ObjCmdProc *)NsfSetterMethod,
                               setterClientData, SetterCmdDeleteProc, 0u);
  } else {
    result = NsfAddObjectMethod(interp, (Nsf_Object *)object, methodName,
                                (Tcl_ObjCmdProc *)NsfSetterMethod,
                                setterClientData, SetterCmdDeleteProc, 0u);
  }
  if (likely(result == TCL_OK)) {
    Tcl_SetObjResult(interp, MethodHandleObj(object, class == NULL, methodName));
  } else {
    SetterCmdDeleteProc(setterClientData);
  }
  return result;
}

/*
cmd "object::alloc" NsfObjectAllocCmd {
  {-argName "class" -required 1 -type class}
  {-argName "name" -required 1 -type tclobj}
  {-argName "initcmd" -required 0 -type tclobj}
}
*/
static int
NsfObjectAllocCmd(Tcl_Interp *interp, NsfClass *class, Tcl_Obj *nameObj, Tcl_Obj *initcmdObj) {
  Tcl_Obj *newNameObj = NULL;
  int      result;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(nameObj != NULL);

  /*
   * Make a new symbol if the given name is empty.
   */
  if (strlen(ObjStr(nameObj)) == 0) {
    Tcl_DString ds, *dsPtr = &ds;

    Tcl_DStringInit(dsPtr);
    Tcl_DStringAppend(dsPtr, autonamePrefix, (int)autonamePrefixLength);

    NewTclCommand(interp, dsPtr);

    newNameObj = Tcl_NewStringObj(Tcl_DStringValue(dsPtr), Tcl_DStringLength(dsPtr));
    INCR_REF_COUNT(newNameObj);
    Tcl_DStringFree(dsPtr);

    nameObj = newNameObj;
  }

  /*fprintf(stderr, "trying to alloc <%s>\n", ObjStr(nameObj));*/

  result = NsfCAllocMethod(interp, class, nameObj);

  if (result == TCL_OK && initcmdObj != NULL) {
    NsfObject *object;
    Tcl_Obj   *initNameObj = Tcl_GetObjResult(interp);

    INCR_REF_COUNT(initNameObj);
    if (unlikely(GetObjectFromObj(interp, initNameObj, &object) != TCL_OK)) {
      result = NsfPrintError(interp, "couldn't find result of alloc");
    } else {
      result = NsfDirectDispatchCmd(interp, object, 1,
                                    NsfGlobalObjs[NSF_EVAL],
                                    1, &initcmdObj);
      if (likely(result == TCL_OK)) {
        Tcl_SetObjResult(interp, initNameObj);
      }
    }
    DECR_REF_COUNT(initNameObj);
  }

  if (newNameObj != NULL) {
    DECR_REF_COUNT(newNameObj);
  }

  return result;
}

/*
cmd "object::exists" NsfObjectExistsCmd {
  {-argName "value" -required 1 -type tclobj}
}
*/
static int
NsfObjectExistsCmd(Tcl_Interp *interp, Tcl_Obj *valueObj) {
  NsfObject *object;

  nonnull_assert(interp != NULL);
  nonnull_assert(valueObj != NULL);

  /*
   * Pass the object as a Tcl_Obj, in order to not raise an error if the object
   * does not exist.
   */
  Tcl_SetBooleanObj(Tcl_GetObjResult(interp), GetObjectFromObj(interp, valueObj, &object) == TCL_OK);
  return TCL_OK;
}

/*
cmd "object::property" NsfObjectPropertyCmd {
  {-argName "object" -required 1 -type object}
  {-argName "objectproperty" -type "initialized|class|rootmetaclass|rootclass|volatile|autonamed|slotcontainer|hasperobjectslots|keepcallerself|perobjectdispatch" -required 1}
  {-argName "value" -required 0 -type tclobj}
}
*/

static int
NsfObjectPropertyCmd(Tcl_Interp *interp, NsfObject *object, ObjectpropertyIdx_t objectProperty, Tcl_Obj *valueObj) {
  unsigned int flags = 0u, allowSet = 0u;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  switch (objectProperty) {
  case ObjectpropertyAutonamedIdx: flags = NSF_IS_AUTONAMED; allowSet = 1; break;
  case ObjectpropertyInitializedIdx: flags = NSF_INIT_CALLED; allowSet = 1; break;
  case ObjectpropertyClassIdx: flags = NSF_IS_CLASS; break;
  case ObjectpropertyRootmetaclassIdx: flags = NSF_IS_ROOT_META_CLASS; break;
  case ObjectpropertyVolatileIdx:
    if (valueObj == NULL) {
      Tcl_SetObjResult(interp,
                       NsfGlobalObjs[object->opt != NULL && object->opt->volatileVarName ? NSF_ONE : NSF_ZERO]);
      return TCL_OK;
    }
    allowSet = 1;
    break;

    /*
     * Return the error below if a value is provided.
     */
  case ObjectpropertyRootclassIdx: flags = NSF_IS_ROOT_CLASS; break;
  case ObjectpropertySlotcontainerIdx: flags = NSF_IS_SLOT_CONTAINER; allowSet = 1; break;
  case ObjectpropertyKeepcallerselfIdx: flags = NSF_KEEP_CALLER_SELF; allowSet = 1; break;
  case ObjectpropertyPerobjectdispatchIdx: flags = NSF_PER_OBJECT_DISPATCH; allowSet = 1; break;
  case ObjectpropertyHasperobjectslotsIdx: flags = NSF_HAS_PER_OBJECT_SLOTS; allowSet = 1; break;
  case ObjectpropertyNULL:
    /*
     * Do nothing.  Just detects whether the option was given.
     */
    break;
  }

  if (valueObj != NULL) {
    if (likely(allowSet)) {
      int flagValue, result;

      result = SetBooleanFlag(interp, &object->flags, flags, valueObj, &flagValue);
      if (unlikely(result != TCL_OK)) {
        return result;
      }

      if (objectProperty == ObjectpropertySlotcontainerIdx) {
        assert(object->nsPtr != NULL);
        if (flagValue != 0) {
          /*
           * Turn on SlotContainerCmdResolver.
           */
          Tcl_SetNamespaceResolvers(object->nsPtr,
                                    (Tcl_ResolveCmdProc *)SlotContainerCmdResolver,
                                    NsColonVarResolver,
                                    (Tcl_ResolveCompiledVarProc *)NULL);
        } else {
          /*
           * Turn off SlotContainerCmdResolver.
           */
          Tcl_SetNamespaceResolvers(object->nsPtr,
                                    (Tcl_ResolveCmdProc *)NULL,
                                    NsColonVarResolver,
                                    (Tcl_ResolveCompiledVarProc *)NULL);
        }
      } else if (objectProperty == ObjectpropertyVolatileIdx) {
        bool objectIsVolatile = (object->opt != NULL && object->opt->volatileVarName != NULL);

        if (flagValue != 0 && !objectIsVolatile) {
          /*
           * Set volatile property.
           */

          /*NsfObjectSystem *osPtr = GetObjectSystem(object);*/
          /*fprintf(stderr, "change volatile ... make volatile %s\n",
            ObjectName(&osPtr->rootClass->object));*/
          result = VolatileMethod(interp, object, NSF_TRUE);

        } else if (flagValue == 0 && objectIsVolatile) {
          /*
           * Remove volatile property.
           */
          UnsetTracedVars(interp, object);
          object->opt->volatileVarName = NULL;
        } else {
          /*
           * Nothing to do.
           */
        }

        if (unlikely(result != TCL_OK)) {
          return result;
        }
      }
    } else {
      return NsfPrintError(interp, "object property is read only");
    }
  }

  Tcl_SetObjResult(interp,
                   NsfGlobalObjs[(object->flags & flags) ?
                                 NSF_ONE : NSF_ZERO]);
  return TCL_OK;
}

/*
cmd "object::qualify" NsfObjectQualifyCmd {
  {-argName "objectName" -required 1 -type tclobj}
}
*/
static int
NsfObjectQualifyCmd(Tcl_Interp *interp, Tcl_Obj *objectNameObj) {
  const char *nameString;

  nonnull_assert(interp != NULL);
  nonnull_assert(objectNameObj != NULL);

  nameString = ObjStr(objectNameObj);
  if (isAbsolutePath(nameString)) {
    Tcl_SetObjResult(interp, objectNameObj);
  } else {
    Tcl_SetObjResult(interp, NameInNamespaceObj(nameString, CallingNameSpace(interp)));
  }
  return TCL_OK;
}

/*
cmd "objectsystem::create" NsfObjectSystemCreateCmd {
  {-argName "rootClass" -required 1 -type tclobj}
  {-argName "rootMetaClass" -required 1 -type tclobj}
  {-argName "systemMethods" -required 0 -type tclobj}
}
*/
static int
NsfObjectSystemCreateCmd(Tcl_Interp *interp, Tcl_Obj *rootClassObj, Tcl_Obj *rootMetaClassObj, Tcl_Obj *systemMethodsObj) {
  NsfClass        *theobj = NULL, *thecls = NULL;
  Tcl_Obj         *object, *class;
  const char      *objectName, *className;
  NsfObjectSystem *osPtr;

  nonnull_assert(interp != NULL);
  nonnull_assert(rootClassObj != NULL);
  nonnull_assert(rootMetaClassObj != NULL);

  osPtr = NEW(NsfObjectSystem);
  memset(osPtr, 0, sizeof(NsfObjectSystem));

  objectName = ObjStr(rootClassObj);
  object = isAbsolutePath(objectName) ? rootClassObj :
    NameInNamespaceObj(objectName, CallingNameSpace(interp));

  className = ObjStr(rootMetaClassObj);
  class = isAbsolutePath(className) ? rootMetaClassObj :
    NameInNamespaceObj(className, CallingNameSpace(interp));

  GetClassFromObj(interp, object, &theobj, NSF_FALSE);
  GetClassFromObj(interp, class, &thecls, NSF_FALSE);

  if ((theobj != NULL) || (thecls != NULL)) {
    ObjectSystemFree(interp, osPtr);
    NsfLog(interp, NSF_LOG_WARN, "Base class '%s' exists already; ignoring definition",
           (theobj != NULL) ? objectName : className);
    return TCL_OK;
  }

  if (systemMethodsObj != NULL) {
    int       oc, idx;
    Tcl_Obj **ov;

    if ((Tcl_ListObjGetElements(interp, systemMethodsObj, &oc, &ov)) == TCL_OK) {
      int i;

      if (oc % 2) {
        ObjectSystemFree(interp, osPtr);
        return NsfPrintError(interp, "system methods must be provided as pairs");
      }
      for (i = 0; i < oc; i += 2) {
        Tcl_Obj *arg, **arg_ov = NULL;
        int      arg_oc = -1, result;

        arg = ov[i+1];
        result = Tcl_GetIndexFromObj(interp, ov[i], Nsf_SystemMethodOpts, "system method", 0, &idx);
        if (likely(result == TCL_OK)) {
          result = Tcl_ListObjGetElements(interp, arg, &arg_oc, &arg_ov);
        }
        if (unlikely(result != TCL_OK)) {
          ObjectSystemFree(interp, osPtr);
          return NsfPrintError(interp, "invalid system method '%s'", ObjStr(ov[i]));
        } else if (arg_oc < 1 || arg_oc > 3) {
          ObjectSystemFree(interp, osPtr);
          return NsfPrintError(interp, "invalid system method argument '%s'", ObjStr(ov[i]), ObjStr(arg));
        }
        /*fprintf(stderr, "NsfCreateObjectSystemCmd [%d] = %p %s (max %d, given %d)\n",
          idx, ov[i+1], ObjStr(ov[i+1]), NSF_s_set_idx, oc);*/

        if (arg_oc == 1) {
          osPtr->methods[idx] = arg;
          osPtr->methodNames[idx] = ObjStr(arg);
        } else { /* (arg_oc == 2) */
          osPtr->methods[idx] = arg_ov[0];
          osPtr->methodNames[idx] = ObjStr(arg_ov[0]);
          osPtr->handles[idx] = arg_ov[1];
          if  (arg_oc == 3) {
            int boolVal = 0;
            Tcl_GetBooleanFromObj(interp, arg_ov[2], &boolVal);
            osPtr->protected[idx] = (char)boolVal;
          }
          INCR_REF_COUNT(osPtr->handles[idx]);
        }
        INCR_REF_COUNT(osPtr->methods[idx]);
      }
    } else {
      ObjectSystemFree(interp, osPtr);
      return NsfPrintError(interp, "provided system methods are not a proper list");
    }
  }
  /*
   * Create a basic object system with the basic root-class Object and the
   * basic metaclass Class, and store them in the RUNTIME STATE if successful.
   */
  theobj = PrimitiveCCreate(interp, object, NULL, NULL);
  thecls = PrimitiveCCreate(interp, class, NULL, NULL);
  /* fprintf(stderr, "CreateObjectSystem created base classes \n"); */

  /*
   * Verify that Object and Class creation were successful.
   */
  if ((theobj == NULL) || (thecls == NULL)) {

    if (thecls != NULL) {
      PrimitiveCDestroy(thecls);
    }
    if (theobj != NULL) {
      PrimitiveCDestroy(theobj);
    }

    ObjectSystemFree(interp, osPtr);
    return NsfPrintError(interp, "creation of object system failed");
  }

  theobj->osPtr = osPtr;
  thecls->osPtr = osPtr;
  osPtr->rootClass = theobj;
  osPtr->rootMetaClass = thecls;

  theobj->object.flags |= (NSF_IS_ROOT_CLASS|NSF_INIT_CALLED);
  thecls->object.flags |= (NSF_IS_ROOT_META_CLASS|NSF_INIT_CALLED);

  ObjectSystemAdd(interp, osPtr);

  AddInstance((NsfObject *)theobj, thecls);
  AddInstance((NsfObject *)thecls, thecls);
  AddSuper(thecls, theobj);

  if (NSF_DTRACE_OBJECT_ALLOC_ENABLED()) {
    NSF_DTRACE_OBJECT_ALLOC(ObjectName((NsfObject *)theobj), ClassName(((NsfObject *)theobj)->cl));
    NSF_DTRACE_OBJECT_ALLOC(ObjectName((NsfObject *)thecls), ClassName(((NsfObject *)thecls)->cl));
  }

  return TCL_OK;
}


/*
cmd my NsfMyCmd {
  {-argName "-intrinsic" -nrargs 0}
  {-argName "-local" -nrargs 0}
  {-argName "-system" -nrargs 0}
  {-argName "method" -required 1 -type tclobj}
  {-argName "args" -type args}
}
*/
static int
NsfMyCmd(Tcl_Interp *interp,
         int withIntrinsic, int withLocal, int withSystem,
         Tcl_Obj *methodNameObj,
         int trailingObjc, Tcl_Obj *const trailingObjv[]) {
  NsfObject *self;
  int        result;

  nonnull_assert(interp != NULL);
  nonnull_assert(methodNameObj != NULL);

  self = GetSelfObj(interp);
  if (unlikely(self == NULL)) {
    result = NsfNoCurrentObjectError(interp, method_definitions[NsfMyCmdIdx].methodName);

  } else if ((withIntrinsic && withLocal)
             || (withIntrinsic && withSystem)
             || (withLocal && withSystem)) {
    result = NsfPrintError(interp, "flags '-intrinsic', '-local' and '-system' are mutual exclusive");

  } else {
    unsigned int  flags;
#if 0
    /* TODO attempt to make "my" NRE-enabled, failed so far (crash in mixinInheritanceTest) */
    NsfCallStackContent *cscPtr = CallStackGetTopFrame0(interp);

    if (cscPtr == NULL || self != cscPtr->self) {
      flags = NSF_CSC_IMMEDIATE;
    } else {
      flags = NsfImmediateFromCallerFlags(cscPtr->flags);
      fprintf(stderr, "XXX MY %s.%s frame has flags %.6x -> next-flags %.6x\n",
              ObjectName(self), ObjStr(methodNameObj), cscPtr->flags, flags);
    }
    if (withIntrinsic != 0) {flags |= NSF_CM_INTRINSIC_METHOD;}
    if (withLocal != 0)     {flags |= NSF_CM_LOCAL_METHOD;}
    if (withSystem != 0)    {flags |= NSF_CM_SYSTEM_METHOD;}
    result = CallMethod(self, interp, methodNameObj, trailingObjc+2, trailingObjv, flags);
#else
    flags = NSF_CSC_IMMEDIATE;
    if (withIntrinsic != 0) {flags |= NSF_CM_INTRINSIC_METHOD;}
    if (withLocal != 0)     {flags |= NSF_CM_LOCAL_METHOD;}
    if (withSystem != 0)    {flags |= NSF_CM_SYSTEM_METHOD;}
    result = CallMethod(self, interp, methodNameObj, trailingObjc+2, trailingObjv, flags);
#endif
  }

  return result;
}


/*
 *----------------------------------------------------------------------
 * NsfNextCmd --
 *
 *    Implementatin of nsf::next.  Calls the next overriden method passing it
 *    the arguments to the last invocation, or *argumentsObj if given.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    Arbitrary.
 *
 *----------------------------------------------------------------------
 */
/*
cmd next NsfNextCmd {
  {-argName "arguments" -required 0 -type tclobj}
}
*/
static int
NsfNextCmd(Tcl_Interp *interp, Tcl_Obj *argumentsObj) {
  int                  oc, nobjc = 0, result;
  bool                 freeArgumentVector;
  NsfCallStackContent *cscPtr = NULL;
  const char          *methodName = NULL;
  Tcl_Obj            **nobjv = NULL, **ov;

  nonnull_assert(interp != NULL);

  if (argumentsObj != NULL) {
    /*
     * Arguments were provided.
     */
    int rc = Tcl_ListObjGetElements(interp, argumentsObj, &oc, &ov);

    if (unlikely(rc != TCL_OK)) {
      return rc;
    }
  } else {
    /*
     * No arguments were provided.
     */
    oc = -1;
    ov = NULL;
  }

  result = NextGetArguments(interp, oc, ov, &cscPtr, &methodName,
                            &nobjc, &nobjv, &freeArgumentVector);
  if (likely(result == TCL_OK)) {
    assert(cscPtr != NULL);
    result = NextSearchAndInvoke(interp, methodName, nobjc, nobjv, cscPtr, freeArgumentVector);
  }
  return result;
}

/*
cmd nscopyvars NsfNSCopyVars {
  {-argName "fromNs" -required 1 -type tclobj}
  {-argName "toNs" -required 1 -type tclobj}
}
*/
static int
NsfNSCopyVarsCmd(Tcl_Interp *interp, Tcl_Obj *fromNsObj, Tcl_Obj *toNsObj) {
  Tcl_Namespace       *fromNsPtr = NULL, *toNsPtr;
  Var                 *varPtr = NULL;
  Tcl_HashSearch       hSrch;
  const Tcl_HashEntry *hPtr;
  TclVarHashTable     *varTablePtr;
  NsfObject           *destObject;
  const char          *destFullName;
  Tcl_Obj             *destFullNameObj;
  Tcl_CallFrame        frame, *framePtr = &frame;
  int                  result;

  nonnull_assert(interp != NULL);
  nonnull_assert(fromNsObj != NULL);
  nonnull_assert(toNsObj != NULL);

  TclGetNamespaceFromObj(interp, fromNsObj, &fromNsPtr);

  if (fromNsPtr != NULL) {
    if (TclGetNamespaceFromObj(interp, toNsObj, &toNsPtr) != TCL_OK) {
      return NsfPrintError(interp, "CopyVars: Destination namespace %s does not exist",
                           ObjStr(toNsObj));
    }

    destFullName = toNsPtr->fullName;
    destFullNameObj = Tcl_NewStringObj(destFullName, -1);
    INCR_REF_COUNT(destFullNameObj);
    varTablePtr = Tcl_Namespace_varTablePtr(fromNsPtr);
    Tcl_PushCallFrame(interp, (Tcl_CallFrame *)framePtr, toNsPtr, 0);
  } else {
    NsfObject *newObject, *object;

    if (GetObjectFromObj(interp, fromNsObj, &object) != TCL_OK) {
      return NsfPrintError(interp, "CopyVars: Origin object/namespace %s does not exist",
                           ObjStr(fromNsObj));

    } else if (GetObjectFromObj(interp, toNsObj, &newObject) != TCL_OK) {
      return NsfPrintError(interp, "CopyVars: Destination object/namespace %s does not exist",
                           ObjStr(toNsObj));
    } else {
      varTablePtr = object->varTablePtr;
      destFullNameObj = newObject->cmdName;
      destFullName = ObjStr(destFullNameObj);
    }
  }

  destObject = GetObjectFromString(interp, destFullName);
  result = TCL_OK;

  /*
   * Copy all variables in the namespace.
   */
  hPtr = (varTablePtr != NULL) ? Tcl_FirstHashEntry(TclVarHashTablePtr(varTablePtr), &hSrch) : NULL;
  while (hPtr != NULL) {
    Tcl_Obj *varNameObj, *resultObj;

    GetVarAndNameFromHash(hPtr, &varPtr, &varNameObj);
    INCR_REF_COUNT(varNameObj);

    if (!TclIsVarUndefined(varPtr) && !TclIsVarLink(varPtr)) {
      if (TclIsVarScalar(varPtr)) {
        /*
         * Copy the scalar variable, which might be either an instance or a
         * plain namespace variable, from the namespace.
         */

        if (destObject != NULL) {
          /* fprintf(stderr, "copy in obj %s var %s val '%s'\n", ObjectName(destObject), ObjStr(varNameObj),
             ObjStr(TclVarValue(Tcl_Obj, varPtr, objPtr)));*/

          resultObj = Nsf_ObjSetVar2((Nsf_Object *)destObject, interp, varNameObj, NULL,
                                     TclVarValue(Tcl_Obj, varPtr, objPtr), TCL_LEAVE_ERR_MSG);
        } else {
          resultObj = Tcl_ObjSetVar2(interp, varNameObj, NULL,
                                     TclVarValue(Tcl_Obj, varPtr, objPtr),
                                     TCL_NAMESPACE_ONLY|TCL_LEAVE_ERR_MSG);
        }
        if (unlikely(resultObj == NULL)) {
          DECR_REF_COUNT(varNameObj);
          result = TCL_ERROR;
          goto copy_done;
        }
      } else {
        if (TclIsVarArray(varPtr)) {
          /* HERE!! PRE85 Why not [array get/set] based? Let the core iterate */
          TclVarHashTable *aTable = TclVarValue(TclVarHashTable, varPtr, tablePtr);
          Tcl_HashSearch ahSrch;
          Tcl_HashEntry *ahPtr = (aTable != NULL) ? Tcl_FirstHashEntry(TclVarHashTablePtr(aTable), &ahSrch) : 0;

          for (; ahPtr != NULL; ahPtr = Tcl_NextHashEntry(&ahSrch)) {
            Tcl_Obj *eltNameObj;
            Var *eltVar;

            GetVarAndNameFromHash(ahPtr, &eltVar, &eltNameObj);
            INCR_REF_COUNT(eltNameObj);

            if (TclIsVarScalar(eltVar)) {
              if (destObject != NULL) {
                resultObj = Nsf_ObjSetVar2((Nsf_Object *)destObject, interp, varNameObj, eltNameObj,
                                           TclVarValue(Tcl_Obj, eltVar, objPtr), TCL_LEAVE_ERR_MSG);
              } else {
                resultObj = Tcl_ObjSetVar2(interp, varNameObj, eltNameObj,
                                           TclVarValue(Tcl_Obj, eltVar, objPtr),
                                           TCL_NAMESPACE_ONLY|TCL_LEAVE_ERR_MSG);
              }
              if (unlikely(resultObj == NULL)) {
                DECR_REF_COUNT(varNameObj);
                result = TCL_ERROR;
                goto copy_done;
              }
            }
            DECR_REF_COUNT(eltNameObj);
          }
        }
      }
    }
    DECR_REF_COUNT(varNameObj);
    hPtr = Tcl_NextHashEntry(&hSrch);
  }
 copy_done:
  if (fromNsPtr != NULL) {
    DECR_REF_COUNT(destFullNameObj);
    Tcl_PopCallFrame(interp);
  }
  return result;
}

/*
cmd parameter::info NsfParameterInfoCmd {
  {-argName "subcmd"   -typeName "parametersubcmd" -type "default|list|name|syntax|type" -required 1}
  {-argName "parameterspec"   -required 1 -type tclobj}
  {-argName "varname"         -required 0 -type tclobj}
}
*/
static int
NsfParameterInfoCmd(Tcl_Interp *interp, ParametersubcmdIdx_t subcmd, Tcl_Obj *specObj,  Tcl_Obj *varnameObj) {
  NsfParsedParam parsedParam;
  Tcl_Obj *paramsObj, *listObj = NULL;
  Nsf_Param *paramsPtr;
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(specObj != NULL);

  if (subcmd != ParametersubcmdDefaultIdx && varnameObj != NULL) {
    return NsfPrintError(interp, "parameter::info: provided third argument is only valid for querying defaults");
  }

  paramsObj = Tcl_NewListObj(1, &specObj);
  INCR_REF_COUNT(paramsObj);
  result = ParamDefsParse(interp, NULL, paramsObj,
                          NSF_DISALLOWED_ARG_OBJECT_PARAMETER, NSF_TRUE,
                          &parsedParam, NULL);
  DECR_REF_COUNT(paramsObj);

  if (unlikely(result != TCL_OK)) {
    return result;
  }

  assert(parsedParam.paramDefs != NULL);
  paramsPtr = parsedParam.paramDefs->paramsPtr;
  assert(paramsPtr != NULL);

  /*
   * Since information is being exacted from the parameter definition that is
   * in Tcl syntax it makes limited sense to provide a context object for
   * virtual parameter expansion, but so far this is not allowed.
   */

  switch (subcmd) {
  case ParametersubcmdDefaultIdx:
    if (paramsPtr->defaultValue != NULL) {
      if (varnameObj != NULL) {
        Tcl_Obj *resultObj = Tcl_ObjSetVar2(interp, varnameObj, NULL,
                                            paramsPtr->defaultValue,
                                            TCL_LEAVE_ERR_MSG);
        if (unlikely(resultObj == NULL)) {
          ParamDefsRefCountDecr(parsedParam.paramDefs);
          return TCL_ERROR;
        }
      }
      Tcl_SetObjResult(interp, NsfGlobalObjs[NSF_ONE]);
    } else {
      Tcl_SetObjResult(interp, NsfGlobalObjs[NSF_ZERO]);
    }
    break;

  case ParametersubcmdListIdx:
    listObj = ParamDefsList(interp, paramsPtr, NULL, NULL);
    Tcl_SetObjResult(interp, listObj);
    DECR_REF_COUNT2("paramDefsObj", listObj);
    break;

  case ParametersubcmdNameIdx:
    listObj = ParamDefsNames(interp, paramsPtr, NULL, NULL);
    Tcl_SetObjResult(interp, listObj);
    DECR_REF_COUNT2("paramDefsObj", listObj);
    break;

  case ParametersubcmdSyntaxIdx:
    listObj = NsfParamDefsSyntax(interp, paramsPtr, NULL, NULL);
    Tcl_SetObjResult(interp, listObj);
    DECR_REF_COUNT2("paramDefsObj", listObj);
    break;

  case ParametersubcmdTypeIdx:
    if (paramsPtr->type != NULL) {

      if (paramsPtr->converter == Nsf_ConvertToTclobj && paramsPtr->converterArg) {
        Tcl_SetObjResult(interp, paramsPtr->converterArg);

      } else {
        if (paramsPtr->converter == Nsf_ConvertToObject || paramsPtr->converter == Nsf_ConvertToClass) {
          const char *what = paramsPtr->type;
          /*
           * baseclass and metaclass are communicated via flags.
           */
          if (unlikely((paramsPtr->flags & NSF_ARG_BASECLASS) != 0u)) {
            what = "baseclass";
          } else if (unlikely((paramsPtr->flags & NSF_ARG_METACLASS) != 0u)) {
            what = "metaclass";
          }
          /*
           * The converterArg might contain a class for type checking.
           */
          if (paramsPtr->converterArg == NULL) {
            Tcl_SetObjResult(interp, Tcl_NewStringObj(what, -1));
          } else {
            Tcl_SetObjResult(interp, paramsPtr->converterArg);
          }
        } else {
          Tcl_SetObjResult(interp, Tcl_NewStringObj(paramsPtr->type, -1));
        }
      }
    } else {
      Tcl_SetObjResult(interp, NsfGlobalObjs[NSF_EMPTY]);
    }
    break;

  case ParametersubcmdNULL:
    /*
     * Do nothing.  Just detects whether the option was given.
     */
    break;
  }

  ParamDefsRefCountDecr(parsedParam.paramDefs);

  return TCL_OK;
}

/*
cmd parameter::cache::classinvalidate NsfParameterCacheClassInvalidateCmd {
  {-argName "class" -required 1 -type class}
}
*/
static int
NsfParameterCacheClassInvalidateCmd(Tcl_Interp *interp, NsfClass *class) {

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);

  /*
   * Increment the epoch if this is a parsedParam. The classParamPtrEpoch is
   * just used for PER_OBJECT_PARAMETER_CACHING
   */
#if defined(PER_OBJECT_PARAMETER_CACHING)
  if (unlikely(class->parsedParamPtr != NULL)) {
    NsfClassParamPtrEpochIncr("NsfParameterCacheClassInvalidateCmd");
  }
#endif

  /*
   * During shutdown no new objects are created so there is no need to to
   * invalidate the cached parsedParamPtr of the classes.
   */
  if (unlikely(RUNTIME_STATE(interp)->exitHandlerDestroyRound == NSF_EXITHANDLER_OFF)) {
    NsfClasses *dependentSubClasses;
    NsfClasses *clPtr;

    /*
     * Clear the cached parsedParam of the class and all depdendent classes.
     */

    dependentSubClasses = DependentSubClasses(class);
    if (dependentSubClasses != NULL) {

      for (clPtr = dependentSubClasses; clPtr != NULL; clPtr = clPtr->nextPtr) {
        NsfClass *subClass = clPtr->cl;

        if (subClass->parsedParamPtr != NULL) {
          ParsedParamFree(subClass->parsedParamPtr);
          subClass->parsedParamPtr = NULL;
        }

      }
      NsfClassListFree(dependentSubClasses);
    }

  }
  return TCL_OK;
}


/*
cmd parameter::cache::objectinvalidate NsfParameterCacheObjectInvalidateCmd {
  {-argName "object" -required 1 -type object}
}
*/
static int
NsfParameterCacheObjectInvalidateCmd(Tcl_Interp *UNUSED(interp), NsfObject *object) {

  nonnull_assert(object != NULL);

#if defined(PER_OBJECT_PARAMETER_CACHING)
  if (object->opt != NULL && object->opt->parsedParamPtr) {
    /*fprintf(stderr, "   %p %s invalidate %p\n", object,
      ObjectName(object),  object->opt->parsedParamPtr);*/
    ParsedParamFree(object->opt->parsedParamPtr);
    object->opt->parsedParamPtr = NULL;
  }
#endif
  return TCL_OK;
}

/*
cmd parameter::specs NsfParameterSpecsCmd {
  {-argName "-configure"  -nrargs 0 -required 0}
  {-argName "-nonposargs"  -nrargs 0 -required 0}
  {-argName "slotobjs"    -required 1 -type tclobj}
}
*/

static int
NsfParameterSpecsCmd(Tcl_Interp *interp, int withConfigure, int withNonposargs, Tcl_Obj *slotobjsObj) {
  NsfTclObjList *objList = NULL, *elt;
  Tcl_Obj **objv, *resultObj;
  int result = TCL_OK, i, objc;

  nonnull_assert(interp != NULL);
  nonnull_assert(slotobjsObj != NULL);

  if (Tcl_ListObjGetElements(interp, slotobjsObj, &objc, &objv) != TCL_OK) {
    return NsfPrintError(interp, "NsfParameterSpecsCmd: invalid slot object list");
  }

  /*
   * Obtain the position of the parameterSpec.
   */
  for (i = 0; i < objc; i++) {
    NsfObject *slotObject;
    Tcl_Obj *positionObj, *specObj = NULL;

    if (GetObjectFromObj(interp, objv[i], &slotObject) != TCL_OK) {
      return NsfPrintError(interp, "objectparameter: slot element is not a next scripting object");
    }
    assert(slotObject != NULL);

    /*
     * skip this parameter if withConfigure is true and either configure is not
     * set or configure == 0.
     */
    if (withConfigure != 0) {
      int configure = 0;
      Tcl_Obj *configureObj = Nsf_ObjGetVar2((Nsf_Object *)slotObject, interp,
                                             NsfGlobalObjs[NSF_CONFIGURABLE], NULL, 0);
      if (configureObj == NULL) {
        continue;
      }
      Tcl_GetBooleanFromObj(interp, configureObj, &configure);
      if (configure == 0) {
        continue;
      }
    }

    /*
     * Skip this parameter when withNonposargs is true and positional == 1.
     */
    if (withNonposargs != 0) {
      Tcl_Obj *positionalObj = Nsf_ObjGetVar2((Nsf_Object *)slotObject, interp,
                                             NsfGlobalObjs[NSF_POSITIONAL], NULL, 0);
      if (positionalObj != NULL) {
        int positional = 0;

        Tcl_GetBooleanFromObj(interp, positionalObj, &positional);
        if (positional != 0) {
          continue;
        }
      }
    }

    positionObj = Nsf_ObjGetVar2((Nsf_Object *)slotObject, interp,
                                 NsfGlobalObjs[NSF_POSITION], NULL, 0);
    specObj = Nsf_ObjGetVar2((Nsf_Object *)slotObject, interp,
                             NsfGlobalObjs[NSF_PARAMETERSPEC], NULL, 0);
    if (specObj == NULL) {
      result = CallMethod(slotObject, interp, NsfGlobalObjs[NSF_GET_PARAMETER_SPEC], 2, NULL,
                          NSF_CM_IGNORE_PERMISSIONS|NSF_CSC_IMMEDIATE);
      if (unlikely(result != TCL_OK)) {
        return NsfPrintError(interp, "objectparameter: %s %s returned error",
                             ObjectName_(slotObject),
                             NsfGlobalStrings[NSF_GET_PARAMETER_SPEC]);
      }
      specObj = Tcl_GetObjResult(interp);
    }
    /*fprintf(stderr, "NsfParameterSpecsCmd  slot obj = %s pos %s spec %s\n", ObjStr(objv[i]), (positionObj != NULL) ? ObjStr(positionObj) : "NONE", ObjStr(specObj)  );*/
    /*
     * Add the spec to the list at the given position.
     */
    TclObjListAdd(interp, &objList, positionObj, specObj);
  }

  /*
   * Flatten the per-position lists into a single resulting list.
   */
  resultObj = Tcl_NewListObj(0, NULL);
  for (elt = objList; elt != NULL; elt = elt->nextPtr) {
    Tcl_ListObjGetElements(interp, elt->payload, &objc, &objv);
    for (i = 0; i < objc; i++) {
      Tcl_ListObjAppendElement(interp, resultObj, objv[i]);

    }
  }

  Tcl_SetObjResult(interp, resultObj);
  if (objList != NULL) {
    TclObjListFreeList(objList);
  }

  return result;
}

/*
cmd proc NsfProcCmd {
  {-argName "-ad"          -required 0 -nrargs 0 -type switch}
  {-argName "-checkalways" -required 0 -nrargs 0 -type switch}
  {-argName "-debug"       -required 0 -nrargs 0 -type switch}
  {-argName "-deprecated"  -required 0 -nrargs 0 -type switch}
  {-argName "procName"     -required 1 -type tclobj}
  {-argName "arguments"    -required 1 -type tclobj}
  {-argName "body"         -required 1 -type tclobj}
}
*/
static int
NsfProcCmd(Tcl_Interp *interp, int withAd, int withCheckalways, int withDebug, int withDeprecated,
           Tcl_Obj *procNameObj, Tcl_Obj *argumentsObj, Tcl_Obj *bodyObj) {
  NsfParsedParam parsedParam;
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(procNameObj != NULL);
  nonnull_assert(argumentsObj != NULL);
  nonnull_assert(bodyObj != NULL);

  /*
   * Parse argument list "arguments" to determine whether to provide Nsf
   * parameter handling.
   */
  result = ParamDefsParse(interp, procNameObj, argumentsObj,
                          NSF_DISALLOWED_ARG_METHOD_PARAMETER, (withDebug != 0),
                          &parsedParam, Tcl_GetCurrentNamespace(interp)->fullName);
  if (unlikely(result != TCL_OK)) {
    return result;
  }

  if (parsedParam.paramDefs != NULL || withDebug != 0 || withDeprecated != 0) {
    /*
     * Parameter handling is required. Add a thin C-based layer that handles
     * the parameter passing and call the proc on dispatch.
     */
    result = NsfProcAdd(interp, &parsedParam, ObjStr(procNameObj), bodyObj,
                        withAd, withCheckalways, withDebug, withDeprecated);

  } else {
    /*
     * No parameter handling needed. Add a plain Tcl proc.
     */
    Tcl_Obj *ov[4];

    ov[0] = NULL;
    ov[1] = procNameObj;
    ov[2] = argumentsObj;
    ov[3] = bodyObj;
    result = Tcl_ProcObjCmd(0, interp, 4, ov);
  }

  return result;
}

/*
cmd relation::get NsfRelationGetCmd {
  {-argName "object" -type object}
  {-argName "type" -required 1 -typeName "relationtype" -type "object-mixin|class-mixin|object-filter|class-filter|class|superclass|rootclass"}
}
*/
static int
NsfRelationGetCmd(Tcl_Interp *interp, NsfObject *object, RelationtypeIdx_t type) {

  return NsfRelationSetCmd(interp, object, type, NULL);
}


/*
 *----------------------------------------------------------------------
 * NsfRelationClassMixinsSet --
 *
 *    Adds the given objects as mixins to the given class. This was factored
 *    into a separate routine to support undo/redo of these operations in case
 *    of a failure.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */
static int NsfRelationClassMixinsSet(Tcl_Interp *interp, NsfClass *class, Tcl_Obj *valueObj, int oc, Tcl_Obj **ov)
  nonnull(1) nonnull(2) nonnull(3);

static int
NsfRelationClassMixinsSet(Tcl_Interp *interp, NsfClass *class, Tcl_Obj *valueObj, int oc, Tcl_Obj **ov) {
  NsfCmdList  *newMixinCmdList = NULL, *cmds;
  NsfClasses  *subClasses;
  NsfClassOpt *clopt;
  int          i;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(valueObj != NULL);

  for (i = 0; i < oc; i++) {
    if (unlikely(MixinAdd(interp, &newMixinCmdList, ov[i]) != TCL_OK)) {
      CmdListFree(&newMixinCmdList, GuardDel);
      return TCL_ERROR;
    }
  }
  clopt = class->opt;
  assert(clopt != NULL);

  if (clopt->classMixins != NULL) {
    RemoveFromClassMixinsOf(class->object.id, clopt->classMixins);
    CmdListFree(&clopt->classMixins, GuardDel);
  }

  subClasses = DependentSubClasses(class);
  MixinInvalidateObjOrders(subClasses);

  /*
   * Filters must be invalidated since they might be methods of mixed-in
   * classes.
   */
  if (FiltersDefined(interp) > 0) {
    FilterInvalidateObjOrders(interp, subClasses);
  }
  NsfClassListFree(subClasses);

  /*
   * Mix in the new classes.
   */
  clopt->classMixins = newMixinCmdList;

  /*
   * Add this class to the list of objects each of those classes is mixed into.
   */
  for (cmds = newMixinCmdList; cmds; cmds = cmds->nextPtr) {
    NsfObject *nObject = NsfGetObjectFromCmdPtr(cmds->cmdPtr);

    if (nObject != NULL) {
      NsfClassOpt *nclopt = NsfRequireClassOpt((NsfClass *) nObject);

      CmdListAddSorted(&nclopt->isClassMixinOf, class->object.id, NULL);
    } else {
      NsfLog(interp, NSF_LOG_WARN,
             "Problem registering %s as a class mixin of %s\n",
             ObjStr(valueObj), ClassName_(class));
    }
  }

  return TCL_OK;
}


/*
cmd relation::set NsfRelationSetCmd {
  {-argName "object"  -required 1 -type object}
  {-argName "type" -required 1 -typeName "relationtype" -type "object-mixin|class-mixin|object-filter|class-filter|class|superclass|rootclass"}
  {-argName "value" -required 0 -type tclobj}
}
*/
static int
NsfRelationSetCmd(Tcl_Interp *interp, NsfObject *object, RelationtypeIdx_t type, Tcl_Obj *valueObj) {
  int            oc = 0, i;
  Tcl_Obj      **ov;
  NsfClass      *class = NULL;
  NsfObjectOpt  *objopt = NULL;
  NsfClassOpt   *clopt = NULL, *nclopt = NULL;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  /*fprintf(stderr, "NsfRelationSetCmd %s rel=%d val='%s'\n",
    ObjectName(object), relationtype, (valueObj != NULL) ? ObjStr(valueObj) : "NULL");*/

  if (type == RelationtypeClass_mixinIdx ||
      type == RelationtypeClass_filterIdx) {
    if (NsfObjectIsClass(object)) {
      class = (NsfClass *)object;
    } else {
      /*
       * Fall back to per-object case.
       */
      type = (type == RelationtypeClass_mixinIdx) ?
        RelationtypeObject_mixinIdx :
        RelationtypeObject_filterIdx ;
    }
  }

  /*
   * This switch just obtains objopt or clopt and handles other simple cases.
   */
  switch (type) {
  case RelationtypeObject_filterIdx: NSF_FALL_THROUGH; /* fall through */
  case RelationtypeObject_mixinIdx:
    if (valueObj == NULL) {
      objopt = object->opt;
      if (type == RelationtypeObject_mixinIdx) {
        return (objopt != NULL) ? MixinInfo(interp, objopt->objMixins, NULL, NSF_TRUE, NULL) : TCL_OK;
      } else /* (type == RelationtypeObject_filterIdx) */ {
        return (objopt != NULL) ? FilterInfo(interp, objopt->objFilters, NULL, NSF_TRUE, NSF_FALSE) : TCL_OK;
      }
    }
    if (unlikely(Tcl_ListObjGetElements(interp, valueObj, &oc, &ov) != TCL_OK)) {
      return TCL_ERROR;
    }
    objopt = NsfRequireObjectOpt(object);
    break;

  case RelationtypeClass_mixinIdx: NSF_FALL_THROUGH; /* fall through */
  case RelationtypeClass_filterIdx:
    assert(class != NULL);
    if (valueObj == NULL) {
      clopt = class->opt;
      if (type == RelationtypeClass_mixinIdx) {
        return (clopt != NULL) ? MixinInfo(interp, clopt->classMixins, NULL, NSF_TRUE, NULL) : TCL_OK;
      } else /* if (relationtype == RelationtypeClass_filterIdx) */ {
        return (clopt != NULL) ? FilterInfo(interp, clopt->classFilters, NULL, NSF_TRUE, NSF_FALSE) : TCL_OK;
      }
    }
    if (unlikely(Tcl_ListObjGetElements(interp, valueObj, &oc, &ov) != TCL_OK)) {
      return TCL_ERROR;
    }
    clopt = NsfRequireClassOpt(class);
    break;

  case RelationtypeSuperclassIdx:
    if (!NsfObjectIsClass(object)) {
      return NsfObjErrType(interp, "superclass", object->cmdName, "class", NULL);
    }
    class = (NsfClass *)object;
    if (valueObj == NULL) {
      return ListSuperClasses(interp, class, NULL, NSF_FALSE);
    }
    if (unlikely(Tcl_ListObjGetElements(interp, valueObj, &oc, &ov) != TCL_OK)) {
      return TCL_ERROR;
    }
    return SuperclassAdd(interp, class, oc, ov, valueObj);

  case RelationtypeClassIdx:
    if (valueObj == NULL) {
      Tcl_SetObjResult(interp, object->cl->object.cmdName);
      return TCL_OK;
    }
    GetClassFromObj(interp, valueObj, &class, NSF_TRUE);
    if (class == NULL) {
      return NsfObjErrType(interp, "class", valueObj, "a class", NULL);
    }
    i = ChangeClass(interp, object, class);
    if (i == TCL_OK) {
      Tcl_SetObjResult(interp, object->cl->object.cmdName);
    }
    return i;

  case RelationtypeRootclassIdx:
    {
    NsfClass *metaClass = NULL;

    if (!NsfObjectIsClass(object)) {
      return NsfObjErrType(interp, "rootclass", object->cmdName, "class", NULL);
    }
    class = (NsfClass *)object;

    if (valueObj == NULL) {
      return NsfPrintError(interp, "metaclass must be specified as third argument");
    }
    GetClassFromObj(interp, valueObj, &metaClass, NSF_FALSE);
    if (metaClass == NULL) {
      return NsfObjErrType(interp, "rootclass", valueObj, "class", NULL);
    }

    class->object.flags |= NSF_IS_ROOT_CLASS;
    metaClass->object.flags |= NSF_IS_ROOT_META_CLASS;

    return TCL_OK;

    /* TODO: Remove these properties?
       Allow deleting a class system at run time?
    */
    }

  case RelationtypeNULL:
    /* Do nothing.  Used to detect that the option was given. */
    return TCL_OK;
  }

  /*
   * This switch sets the relation.
   */

  switch (type) {
  case RelationtypeObject_mixinIdx:
    {
      NsfCmdList *newMixinCmdList = NULL, *cmds;

      /*
       * Mix in each given class.
       */
      for (i = 0; i < oc; i++) {
        if (unlikely(MixinAdd(interp, &newMixinCmdList, ov[i]) != TCL_OK)) {
          CmdListFree(&newMixinCmdList, GuardDel);
          return TCL_ERROR;
        }
      }

      if (objopt->objMixins != NULL) {
        NsfCmdList *cmdlist, *del;

        /*
         * Delete the old isObjectMixinOf lists.
         */
        for (cmdlist = objopt->objMixins; cmdlist != NULL; cmdlist = cmdlist->nextPtr) {
          class = NsfGetClassFromCmdPtr(cmdlist->cmdPtr);
          clopt = (class != NULL) ? class->opt : NULL;
          if (clopt != NULL) {
            del = CmdListFindCmdInList(object->id, clopt->isObjectMixinOf);
            if (del != NULL) {
              /* fprintf(stderr, "Removing object %s from isObjectMixinOf of class %s\n",
                 ObjectName(object), ObjStr(NsfGetClassFromCmdPtr(cmdlist->cmdPtr)->object.cmdName)); */
              del = CmdListRemoveFromList(&clopt->isObjectMixinOf, del);
              CmdListDeleteCmdListEntry(del, GuardDel);
            }
          }
        }
        CmdListFree(&objopt->objMixins, GuardDel);
      }

      /*
       * Invalidate some things on the object.
       */
      NsfParameterCacheObjectInvalidateCmd(interp, object);
      object->flags &= ~NSF_MIXIN_ORDER_VALID;
      /*
       * Invalidate filters since they might be mixed-in procedures.
       */
      object->flags &= ~NSF_FILTER_ORDER_VALID;

      /*
       * Assign the new list of mixed-in classes to the object.
       */
      objopt->objMixins = newMixinCmdList;

      for (cmds = newMixinCmdList; cmds; cmds = cmds->nextPtr) {
        NsfObject *nObject = NsfGetObjectFromCmdPtr(cmds->cmdPtr);

        if (nObject != NULL) {
          nclopt = NsfRequireClassOpt((NsfClass *) nObject);
          CmdListAddSorted(&nclopt->isObjectMixinOf, object->id, NULL);
        } else {
          NsfLog(interp, NSF_LOG_WARN,
                 "Problem registering %s as an object mixin of %s\n",
                 ObjStr(valueObj), ObjectName_(object));
        }
      }

      MixinComputeDefined(interp, object);
      FilterComputeDefined(interp, object);
    }
    break;

  case RelationtypeObject_filterIdx:
    {
      NsfCmdList *newFilterCmdList = NULL;

      for (i = 0; i < oc; i ++) {
        if (unlikely(FilterAdd(interp, &newFilterCmdList, ov[i], object, NULL) != TCL_OK)) {
          CmdListFree(&newFilterCmdList, GuardDel);
          return TCL_ERROR;
        }
      }

      if (objopt->objFilters != NULL) {
        CmdListFree(&objopt->objFilters, GuardDel);
      }

      object->flags &= ~NSF_FILTER_ORDER_VALID;
      objopt->objFilters = newFilterCmdList;

      /*FilterComputeDefined(interp, object);*/
    }
    break;

  case RelationtypeClass_mixinIdx:
    if (unlikely(NsfRelationClassMixinsSet(interp, class, valueObj, oc, ov) != TCL_OK)) {
      return TCL_ERROR;
    }
    break;

  case RelationtypeClass_filterIdx:
    {
      NsfCmdList *newFilterCmdList = NULL;

      for (i = 0; i < oc; i ++) {
        if (unlikely(FilterAdd(interp, &newFilterCmdList, ov[i], NULL, class) != TCL_OK)) {
          CmdListFree(&newFilterCmdList, GuardDel);
          return TCL_ERROR;
        }
      }

      if (clopt->classFilters != NULL) {
        CmdListFree(&clopt->classFilters, GuardDel);
      }

      if (FiltersDefined(interp) > 0) {
        NsfClasses *subClasses = DependentSubClasses(class);
        if (subClasses != NULL) {
          FilterInvalidateObjOrders(interp, subClasses);
          NsfClassListFree(subClasses);
        }
      }

      clopt->classFilters = newFilterCmdList;

    }
    break;

  case RelationtypeClassIdx:      NSF_FALL_THROUGH; /* fall through */
  case RelationtypeRootclassIdx:  NSF_FALL_THROUGH; /* fall through */
  case RelationtypeSuperclassIdx: NSF_FALL_THROUGH; /* fall through */
  case RelationtypeNULL:
    /* handled above */
    break;

  }

  /*
   * On success return the final setting.
   */
  NsfRelationSetCmd(interp, object, type, NULL);
  return TCL_OK;
}

/*
cmd current NsfCurrentCmd {
  {-argName "option" -required 0 -typeName "currentoption" -type "activelevel|activemixin|args|calledclass|calledmethod|calledproc|callingclass|callinglevel|callingmethod|callingobject|callingproc|class|filterreg|isnextcall|level|methodpath|method|nextmethod|object|proc" -default object}
}
*/
static int
NsfCurrentCmd(Tcl_Interp *interp, CurrentoptionIdx_t option) {
  NsfObject           *object;
  NsfCallStackContent *cscPtr;
  Tcl_CallFrame       *framePtr;
  int                  result = TCL_OK;

  nonnull_assert(interp != NULL);

  object = GetSelfObj(interp);

  /*
   * The first two cases can succeed even outside an Nsf context,
   * i.e. if no object is known. The commands are "nsf::current", "nsf::current
   * object", "nsf::current level", and "nsf::current activelevel".
   */
  if (option == CurrentoptionNULL || option == CurrentoptionObjectIdx) {
    if (likely(object != NULL)) {
      Tcl_SetObjResult(interp, object->cmdName);
    } else {
      result = NsfNoCurrentObjectError(interp, NULL);
    }
    return result;
  }

  if (unlikely(object == NULL)) {
    if (option == CurrentoptionCallinglevelIdx) {
      Tcl_SetIntObj(Tcl_GetObjResult(interp), 1);
    } else if (option == CurrentoptionLevelIdx) {
      /*
       * Not an Nsf level.  Return the empty string.
       */
      Tcl_ResetResult(interp);
    } else {
      result = NsfNoCurrentObjectError(interp, NULL);
    }
    return result;
  }

  /*
   * From here on there must be an object, i.e. a valid Nsf frame/level.
   */
  assert(object != NULL);

  switch (option) {
  case CurrentoptionMethodIdx: NSF_FALL_THROUGH; /* fall through */
  case CurrentoptionProcIdx:
    cscPtr = CallStackGetTopFrame0(interp);
    if (cscPtr != NULL) {
      const char *procName = Tcl_GetCommandName(interp, cscPtr->cmdPtr);
      Tcl_SetObjResult(interp, Tcl_NewStringObj(procName, -1));
    } else {
      /* TODO: Is this actually reachable? */
      return NsfPrintError(interp,  "can't find method");
    }
    break;

  case CurrentoptionMethodpathIdx:
    cscPtr = CallStackGetTopFrame0(interp);
    if (cscPtr != NULL) {
      Tcl_SetObjResult(interp, NsfMethodNamePath(interp,
                                                 CallStackGetTclFrame(interp, NULL, 1),
                                                 Tcl_GetCommandName(interp, cscPtr->cmdPtr)));
    } else {
      /* TODO: Is this actually reachable? */
      return NsfPrintError(interp,  "can't find method");
    }
    break;

  case CurrentoptionClassIdx: /* class subcommand */
    cscPtr = CallStackGetTopFrame0(interp);
    Tcl_SetObjResult(interp, (cscPtr != NULL && cscPtr->cl) ?
                     cscPtr->cl->object.cmdName : NsfGlobalObjs[NSF_EMPTY]);
    break;

  case CurrentoptionActivelevelIdx:
    Tcl_SetObjResult(interp, ComputeLevelObj(interp, ACTIVE_LEVEL));
    break;

  case CurrentoptionArgsIdx: {
    cscPtr = CallStackGetTopFrame(interp, &framePtr);

    if (cscPtr != NULL) {
      int nobjc;
      Tcl_Obj **nobjv;

      if (cscPtr->objv != NULL) {
        nobjc = cscPtr->objc;
        nobjv = (Tcl_Obj **)cscPtr->objv;
      } else {
        nobjc = Tcl_CallFrame_objc(framePtr);
        nobjv = (Tcl_Obj **)Tcl_CallFrame_objv(framePtr);
      }
      Tcl_SetObjResult(interp, Tcl_NewListObj(nobjc-1, nobjv+1));
    } else {
      return NsfPrintError(interp,  "can't find proc");
    }
    break;
  }

  case CurrentoptionActivemixinIdx: {
    NsfObject *cmdObject = NULL;

    if (RUNTIME_STATE(interp)->currentMixinCmdPtr) {
      cmdObject = NsfGetObjectFromCmdPtr(RUNTIME_STATE(interp)->currentMixinCmdPtr);
    }
    Tcl_SetObjResult(interp, (cmdObject != NULL) ? cmdObject->cmdName : NsfGlobalObjs[NSF_EMPTY]);
    break;
  }

  case CurrentoptionCalledprocIdx:
  case CurrentoptionCalledmethodIdx:
    cscPtr = CallStackFindActiveFilter(interp);
    if (cscPtr != NULL) {
      Tcl_SetObjResult(interp,
                       Tcl_NewStringObj(MethodName(cscPtr->filterStackEntry->calledProc), -1));
    } else {
      result = NsfPrintError(interp, "called from outside of a filter");
    }
    break;

  case CurrentoptionCalledclassIdx: {
    const NsfClass *class = FindCalledClass(interp, object);
    Tcl_SetObjResult(interp, (class != NULL) ? class->object.cmdName : NsfGlobalObjs[NSF_EMPTY]);
    break;
  }
  case CurrentoptionCallingmethodIdx:
  case CurrentoptionCallingprocIdx: {
    Tcl_Obj *resultObj;

    cscPtr = NsfCallStackFindLastInvocation(interp, 1, &framePtr);
    if ((cscPtr != NULL) && (cscPtr->cmdPtr != NULL)) {
      resultObj = NsfMethodNamePath(interp,
                                    CallStackGetTclFrame(interp, framePtr, 1),
                                    Tcl_GetCommandName(interp, cscPtr->cmdPtr));
    } else {
      resultObj = NsfGlobalObjs[NSF_EMPTY];
    }
    Tcl_SetObjResult(interp, resultObj);
    break;
  }
  case CurrentoptionCallingclassIdx:
    cscPtr = NsfCallStackFindLastInvocation(interp, 1, NULL);
    Tcl_SetObjResult(interp, (cscPtr != NULL && cscPtr->cl != NULL)
                     ? cscPtr->cl->object.cmdName
                     : NsfGlobalObjs[NSF_EMPTY]);
    break;

  case CurrentoptionCallinglevelIdx:
    /*
     * The special case of object==NULL is handled above.
     */
    Tcl_SetObjResult(interp, ComputeLevelObj(interp, CALLING_LEVEL));
    break;

  case CurrentoptionCallingobjectIdx:
    cscPtr = NsfCallStackFindLastInvocation(interp, 1, NULL);
    Tcl_SetObjResult(interp, (cscPtr != NULL) ? cscPtr->self->cmdName : NsfGlobalObjs[NSF_EMPTY]);
    break;

  case CurrentoptionFilterregIdx:
    cscPtr = CallStackFindActiveFilter(interp);
    if (cscPtr != NULL) {
      Tcl_SetObjResult(interp, FilterFindReg(interp, object, cscPtr->cmdPtr));
    } else {
      result = NsfPrintError(interp, "called from outside of a filter");
    }
    break;

  case CurrentoptionIsnextcallIdx: {

    cscPtr = CallStackGetTopFrame(interp, &framePtr);

    if ((cscPtr->frameType & NSF_CSC_TYPE_ENSEMBLE) != 0u) {
      (void)CallStackFindEnsembleCsc(framePtr, &framePtr);
    }

    framePtr = CallStackNextFrameOfType(Tcl_CallFrame_callerPtr(framePtr),
                                        FRAME_IS_NSF_METHOD|FRAME_IS_NSF_CMETHOD);
    cscPtr = (framePtr != NULL) ? Tcl_CallFrame_clientData(framePtr) : NULL;

    Tcl_SetBooleanObj(Tcl_GetObjResult(interp),
                      (cscPtr != NULL && ((cscPtr->flags & NSF_CSC_CALL_IS_NEXT) != 0u)));
    break;
  }

  case CurrentoptionLevelIdx:
    /*
     * There is an object so there is an Nsf frame/level, and "nsf level"
     * behaves like "info level" without arguments.
     */
    Tcl_SetObjResult(interp, Tcl_NewIntObj(Tcl_CallFrame_level(Tcl_Interp_varFramePtr(interp))));
    break;

  case CurrentoptionNextmethodIdx: {
    Tcl_Obj *methodHandle;

    cscPtr = CallStackGetTopFrame(interp, &framePtr);
    assert(cscPtr != NULL);

    methodHandle = FindNextMethod(interp, framePtr);
    if (methodHandle == NULL) {
      Tcl_ResetResult(interp);
    } else {
      Tcl_SetObjResult(interp, methodHandle);
    }

    break;
  }

  case CurrentoptionObjectIdx: NSF_FALL_THROUGH; /* fall through */
  case CurrentoptionNULL:
    /* handled above */
    break;
  }

  return result;
}

/*
cmd self NsfSelfCmd {
}
*/
static int
NsfSelfCmd(Tcl_Interp *interp) {
  NsfObject *object;

  nonnull_assert(interp != NULL);

  object = GetSelfObj(interp);
  if (likely(object != NULL)) {
    Tcl_SetObjResult(interp, object->cmdName);
    return TCL_OK;
  } else {
    return NsfNoCurrentObjectError(interp, NULL);
  }
}

/*
cmd var::exists NsfVarExistsCmd {
  {-argName "-array" -required 0 -nrargs 0}
  {-argName "object" -required 1 -type object}
  {-argName "varName" -required 1}
}
*/
static int
NsfVarExistsCmd(Tcl_Interp *interp, int withArray, NsfObject *object, const char *varName) {
  unsigned int flags =
    NSF_VAR_TRIGGER_TRACE|NSF_VAR_REQUIRE_DEFINED|
    ((withArray != 0) ? NSF_VAR_ISARRAY : 0u);

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(varName != NULL);

  if (unlikely(CheckVarName(interp, varName) != TCL_OK)) {
    return TCL_ERROR;
  }
  Tcl_SetIntObj(Tcl_GetObjResult(interp), VarExists(interp, object, varName, NULL, flags));

  return TCL_OK;
}

/*
cmd var::get NsfVarGetCmd {
  {-argName "-array" -required 0 -nrargs 0 -type switch}
  {-argName "-notrace" -required 0 -nrargs 0 -type switch}
  {-argName "object" -required 1 -type object}
  {-argName "varName" -required 1 -type tclobj}
}
*/
static int
NsfVarGetCmd(Tcl_Interp *interp, int withArray, int withNotrace,
             NsfObject *object, Tcl_Obj *varNameObj) {

  return NsfVarSetCmd(interp, withArray, withNotrace, object, varNameObj, NULL);
}

/*
cmd var::import NsfVarImportCmd {
  {-argName "object" -type object}
  {-argName "args" -type args}
}
*/
static int NsfVarImport(Tcl_Interp *interp, NsfObject *object, const char *cmdName,
                        int objc, Tcl_Obj *const objv[])
  nonnull(1) nonnull(2) nonnull(3) nonnull(5);

static int
NsfVarImport(Tcl_Interp *interp, NsfObject *object, const char *cmdName,
             int objc, Tcl_Obj *const objv[]) {
  int i, result = TCL_OK;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(cmdName != NULL);
  nonnull_assert(objv != NULL);

  for (i = 0; i < objc && result == TCL_OK; i++) {
    Tcl_Obj **ov;
    int oc;

    /*fprintf(stderr, "ListGetElements %p %s\n", objv[i], ObjStr(objv[i]));*/
    if ((result = Tcl_ListObjGetElements(interp, objv[i], &oc, &ov)) == TCL_OK) {
      Tcl_Obj *varName = NULL, *alias = NULL;
      switch (oc) {
      case 0:
        varName = objv[i];
        break;
      case 1:
        varName = ov[0];
        break;
      case 2:
        varName = ov[0];
        alias = ov[1];
        break;
      default:
        break;
      }
      if (likely(varName != NULL)) {
        result = ImportInstVarIntoCurrentScope(interp, cmdName, object, varName, alias);
      } else {
        assert(objv[i] != NULL);
        result = NsfPrintError(interp, "invalid variable specification '%s'", ObjStr(objv[i]));
      }
    }
  }

  return result;
}

static int
NsfVarImportCmd(Tcl_Interp *interp, NsfObject *object, int trailingObjc, Tcl_Obj *const trailingObjv[]) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  return NsfVarImport(interp, object, "importvar", trailingObjc, trailingObjv);
}

/*
cmd var::set NsfVarSetCmd {
  {-argName "-array" -required 0 -nrargs 0 -type switch}
  {-argName "-notrace" -required 0 -nrargs 0 -type switch}
  {-argName "object" -required 1 -type object}
  {-argName "varName" -required 1 -type tclobj}
  {-argName "value" -required 0 -type tclobj}
}
*/
static int
NsfVarSetCmd(Tcl_Interp *interp, int withArray, int withNotrace,
             NsfObject *object, Tcl_Obj *varNameObj, Tcl_Obj *valueObj) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(varNameObj != NULL);

  if (unlikely(CheckVarName(interp, ObjStr(varNameObj)) != TCL_OK)) {
    return TCL_ERROR;
  }

  if (withArray != 0) {
    return SetInstArray(interp, object, varNameObj, valueObj);
  } else {
    return SetInstVar(interp, object, varNameObj, valueObj, withNotrace ? 0 : NSF_VAR_TRIGGER_TRACE);
  }
}

/*
cmd var::unset NsfVarUnsetCmd {
  {-argName "-nocomplain" -required 0 -nrargs 0}
  {-argName "object" -required 1 -type object}
  {-argName "varName" -required 1 -type tclobj}
}
*/
static int
NsfVarUnsetCmd(Tcl_Interp *interp, int withNocomplain, NsfObject *object, Tcl_Obj *varNameObj) {
  const char *varName;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(varNameObj != NULL);

  varName = ObjStr(varNameObj);
  if (unlikely(CheckVarName(interp, varName) != TCL_OK)) {
    return TCL_ERROR;
  }

  return UnsetInstVar(interp, withNocomplain, object, varName);
}
/***********************************************************************
 * End generated Next Scripting  commands
 ***********************************************************************/

/*
 * Parameter support functions
 */

typedef struct NsfParamWrapper {
  Nsf_Param *paramPtr;
  int refCount;
  bool canFree;
} NsfParamWrapper;

static Tcl_DupInternalRepProc      ParamDupInteralRep;
static Tcl_FreeInternalRepProc     ParamFreeInternalRep;
static Tcl_UpdateStringProc        ParamUpdateString;

static void ParamUpdateString(Tcl_Obj *objPtr)
  nonnull(1);
static void ParamDupInteralRep(Tcl_Obj *srcPtr, Tcl_Obj *UNUSED(dupPtr))
  nonnull(1);
static void ParamFreeInternalRep(register Tcl_Obj *objPtr)
  nonnull(1);
static int ParamSetFromAny(Tcl_Interp *interp,        register Tcl_Obj *objPtr)
  nonnull(1) nonnull(2);
static int ParamSetFromAny2(Tcl_Interp *interp, const char *varNamePrefix,
                            bool allowObjectParameter, register Tcl_Obj *objPtr,
                            const char *qualifier)
  nonnull(1) nonnull(2) nonnull(4);

static void
ParamUpdateString(Tcl_Obj *objPtr) {
  nonnull_assert(objPtr != NULL);
  Tcl_Panic("%s of type %s should not be called", "updateStringProc",
            objPtr->typePtr->name);
}

static void
ParamDupInteralRep(Tcl_Obj *srcPtr, Tcl_Obj *UNUSED(dupPtr)) {
  nonnull_assert(srcPtr != NULL);
  Tcl_Panic("%s of type %s should not be called", "dupStringProc",
            srcPtr->typePtr->name);
}

static Tcl_ObjType paramObjType = {
    "nsfParam",                          /* name */
    ParamFreeInternalRep,                /* freeIntRepProc */
    ParamDupInteralRep,                  /* dupIntRepProc */
    ParamUpdateString,                   /* updateStringProc */
    ParamSetFromAny                      /* setFromAnyProc */
};

static void
ParamFreeInternalRep(
    register Tcl_Obj *objPtr)   /* Param structure object with internal
                                 * representation to free. */
{
  NsfParamWrapper *paramWrapperPtr;

  nonnull_assert(objPtr != NULL);

  paramWrapperPtr = (NsfParamWrapper *)objPtr->internalRep.twoPtrValue.ptr1;
  if (paramWrapperPtr != NULL) {
    /* fprintf(stderr, "ParamFreeInternalRep freeing wrapper %p paramPtr %p refCount %dcanFree %d\n",
            paramWrapperPtr, paramWrapperPtr->paramPtr, paramWrapperPtr->refCount,
            paramWrapperPtr->canFree);*/

    if (paramWrapperPtr->canFree) {
      ParamsFree(paramWrapperPtr->paramPtr);
      FREE(NsfParamWrapper, paramWrapperPtr);
    } else {
      paramWrapperPtr->refCount--;
    }
  }
}

/*
 *----------------------------------------------------------------------
 * ParamSetFromAny2 --
 *
 *    Converts the second argument, e.g. "x:integer", into the internal
 *    representation of a Tcl_Obj of the type paramObjType. The conversion is
 *    performed by the usual ParamDefinitionParse() function, used e.g. for the
 *    parameter passing for arguments.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    See description.
 *
 *----------------------------------------------------------------------
 */

static int
ParamSetFromAny2(
    Tcl_Interp *interp,               /* Used for error reporting if not NULL. */
    const char *varNamePrefix,        /* shows up as varName in error message */
    bool allowObjectParameter,        /* allow object parameters */
    register Tcl_Obj *objPtr,         /* The object to convert. */
    const char *qualifier)
{
  Tcl_Obj         *fullParamObj = Tcl_NewStringObj(varNamePrefix, -1);
  int              result, possibleUnknowns = 0, plainParams = 0, nrNonposArgs = 0;
  NsfParamWrapper *paramWrapperPtr = NEW(NsfParamWrapper);

  nonnull_assert(interp != NULL);
  nonnull_assert(varNamePrefix != NULL);
  nonnull_assert(objPtr != NULL);

  paramWrapperPtr->paramPtr = ParamsNew(1u);
  paramWrapperPtr->refCount = 1;
  paramWrapperPtr->canFree = NSF_FALSE;

  Tcl_AppendLimitedToObj(fullParamObj, ObjStr(objPtr), -1, INT_MAX, NULL);
  INCR_REF_COUNT(fullParamObj);

  result = ParamDefinitionParse(interp, NsfGlobalObjs[NSF_VALUECHECK], fullParamObj,
                                (allowObjectParameter ? NSF_DISALLOWED_ARG_OBJECT_PARAMETER : NSF_DISALLOWED_ARG_VALUECHECK),
                                paramWrapperPtr->paramPtr, &possibleUnknowns,
                                &plainParams, &nrNonposArgs, qualifier);
  /*
   * Treat currently-unknown user-level converters as error.
   */
  if (unlikely((paramWrapperPtr->paramPtr->flags & NSF_ARG_CURRENTLY_UNKNOWN) != 0u)) {
    result = TCL_ERROR;
  }

  if (likely(result == TCL_OK)) {
    /*
     * The allocated memory is freed when Tcl Tcl_Obj is freed.
     */
    paramWrapperPtr->paramPtr->flags |= NSF_ARG_UNNAMED;
    if (*(paramWrapperPtr->paramPtr->name) == 'r') {
      paramWrapperPtr->paramPtr->flags |= NSF_ARG_IS_RETURNVALUE;
    }
    TclFreeIntRep(objPtr);
    objPtr->internalRep.twoPtrValue.ptr1 = (void *)paramWrapperPtr;
    objPtr->internalRep.twoPtrValue.ptr2 = NULL;
    objPtr->typePtr = &paramObjType;
  } else {
    /*
     * Free the memory allocated above.
     */
    ParamsFree(paramWrapperPtr->paramPtr);
    FREE(NsfParamWrapper, paramWrapperPtr);
  }

  DECR_REF_COUNT(fullParamObj);
  return result;
}

static int
ParamSetFromAny(
    Tcl_Interp *interp,               /* Used for error reporting if not NULL. */
    register Tcl_Obj *objPtr)         /* The object to convert. */
{
  nonnull_assert(interp != NULL);
  nonnull_assert(objPtr != NULL);

  return ParamSetFromAny2(interp, "value:", NSF_FALSE, objPtr, NULL);
}

/*
 *----------------------------------------------------------------------
 * GetObjectParameterDefinition --
 *
 *    Calls "__objectparameter" to obtain the parameter definitions for an
 *    object if they aren't cached already, and stores a pointer to the parsed
 *    definitions in last argument.  Either "object" or "class" must be
 *    non-null. Results are cached on the class.  The cached values are used in
 *    case there are no object-specific slots.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    May Update cl->parsedParamPtr.
 *
 *----------------------------------------------------------------------
 */
static int
ComputeParameterDefinition(
    Tcl_Interp *interp, Tcl_Obj *procNameObj,
    NsfObject *object, NsfClass *class,
    NsfParsedParam *parsedParamPtr
) {
  int        result;
  Tcl_Obj   *methodObj;
  NsfObject *self;

  if (object != NULL) {
    methodObj = NsfMethodObj(object, NSF_o_configureparameter_idx);
    self = object;
  } else {
    assert(class != NULL);
    self = &class->object;
    methodObj = NsfMethodObj(self, NSF_c_configureparameter_idx);
  }

  if (methodObj == NULL) {
    result = TCL_OK;
  } else {
    /*fprintf(stderr, "calling %s %s\n", ObjectName(self), ObjStr(methodObj));*/
    result = CallMethod(self, interp, methodObj, 2, NULL,
                        NSF_CM_IGNORE_PERMISSIONS|NSF_CSC_IMMEDIATE);

    if (likely(result == TCL_OK)) {
      Tcl_Obj *rawConfArgs = Tcl_GetObjResult(interp);

      /*      fprintf(stderr, ".... rawConfArgs for %s => '%s'\n",
              ObjectName(self), ObjStr(rawConfArgs));*/
      INCR_REF_COUNT(rawConfArgs);

      /*
       * Parse the string representation to obtain the internal
       * representation.
       */
      result = ParamDefsParse(interp, procNameObj, rawConfArgs,
                              NSF_DISALLOWED_ARG_OBJECT_PARAMETER, NSF_TRUE,
                              parsedParamPtr, NULL);
      if (likely(result == TCL_OK)) {
        NsfParsedParam *ppDefPtr = NEW(NsfParsedParam);

        ppDefPtr->paramDefs = parsedParamPtr->paramDefs;
        ppDefPtr->possibleUnknowns = parsedParamPtr->possibleUnknowns;
        if (class != NULL) {
          assert(class->parsedParamPtr == NULL);
          class->parsedParamPtr = ppDefPtr;
#if defined(PER_OBJECT_PARAMETER_CACHING)
        } else if (object != NULL) {
          NsfObjectOpt *opt = NsfRequireObjectOpt(object);

          if (object->opt->parsedParamPtr != NULL) {
            NsfParameterCacheObjectInvalidateCmd(interp, object);
          }
          opt->parsedParamPtr = ppDefPtr;
          opt->classParamPtrEpoch = RUNTIME_STATE(interp)->classParamPtrEpoch;
          /*fprintf(stderr, "set obj param for obj %p %s epoch %d ppDefPtr %p\n",
            object, ObjectName(object), opt->classParamPtrEpoch, ppDefPtr);*/
#endif
        }
        if (ppDefPtr->paramDefs != NULL) {
          ParamDefsRefCountIncr(ppDefPtr->paramDefs);
        }
      }
      DECR_REF_COUNT(rawConfArgs);
    }
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 * GetObjectParameterDefinition --
 *
 *    Calls "__objectparameter" method to obtain the parameter definitions for
 *    an object if they aren't already cached, and stores a pointer to the
 *    parsed definitions in the last argument.  Results are cached on the
 *    class.  The cached values are used in case there are no object-specific
 *    slots.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    May update cl->parsedParamPtr.
 *
 *----------------------------------------------------------------------
 */
static int
GetObjectParameterDefinition(
    Tcl_Interp *interp, Tcl_Obj *procNameObj,
    NsfObject *object, NsfClass *class,
    NsfParsedParam *parsedParamPtr
) {
  int result = TCL_OK;

  nonnull_assert(interp != NULL);
  nonnull_assert(procNameObj != NULL);
  nonnull_assert(parsedParamPtr != NULL);

  parsedParamPtr->paramDefs = NULL;
  parsedParamPtr->possibleUnknowns = 0;

  if (class == NULL) {
    assert(object != NULL);
    if ((object->flags & NSF_HAS_PER_OBJECT_SLOTS) != 0u
        || (object->opt != NULL && object->opt->objMixins)
        ) {
      /*
       * There are object-specific parameters.  Do not use the per-class cache
       * and do not save the results in the per-class cache.
       */
      /*fprintf(stderr, "per-object configure obj %s flags %.6x\n",
        ObjectName(object), object->flags);*/
    } else {
      class = object->cl;
    }
  }

  /*
   * Parameter definitions are cached in the class for which instances are
   * created. The parameter definitions are flushed in the following
   * situations:
   *
   *     On class cleanup: ParsedParamFree(cl->parsedParamPtr).
   *
   *     On class structure changes.
   *
   *     When class-mixins are added.
   *
   *     When new slots are defined.
   *
   *     When slots are removed.
   *
   * When slot defaults or types change the slots must manually call
   * "::nsf::invalidateobjectparameter $domain".
   */

  /*
   * Are there already parameter definitions available for creating objects of
   * this class?
   */
  if (likely(class != NULL && class->parsedParamPtr != NULL)) {
    NsfParsedParam *clParsedParamPtr = class->parsedParamPtr;

    parsedParamPtr->paramDefs = clParsedParamPtr->paramDefs;
    parsedParamPtr->possibleUnknowns = clParsedParamPtr->possibleUnknowns;
    result = TCL_OK;

#if defined(PER_OBJECT_PARAMETER_CACHING)
  } else if (object != NULL && object->opt != NULL && object->opt->parsedParamPtr != NULL &&
             object->opt->classParamPtrEpoch == RUNTIME_STATE(interp)->classParamPtrEpoch) {
    NsfParsedParam *objParsedParamPtr = object->opt->parsedParamPtr;

    /*fprintf(stderr, "reuse obj param for obj %p  %s paramPtr %p\n",
      (void *)object, ObjectName(object), (void *)objParsedParamPtr);*/
    parsedParamPtr->paramDefs = objParsedParamPtr->paramDefs;
    parsedParamPtr->possibleUnknowns = objParsedParamPtr->possibleUnknowns;
    result = TCL_OK;
#endif

  } else {
    /*
     * There is parameter definition available. Produce new definitions from
     * the string representation.
     */
    result = ComputeParameterDefinition(interp, procNameObj,
                                        object, class,
                                        parsedParamPtr);
  }

  return result;
}

/*
 *----------------------------------------------------------------------
 * ParameterCheck --
 *
 *    Checks the given valueObj against the given parameter specification when
 *    doCheckArguments is true, and stores a pointer to the parsed parameter
 *    definition in *paramPtrPtr.  Used e.g. by nsf::is, where only the
 *    right-hand side of a parameter specification, i.e. the part after the
 *    colon, is given. argNamePrefix provides the argument name, i.e. the part
 *    before the colon in a parameter spec.
 *
 * Results:
 *    A Tcl return code.
 *
 * Side effects:
 *    May convert the type of paramObjPtr.
 *
 *----------------------------------------------------------------------
 */

static int
ParameterCheck(
    Tcl_Interp *interp, Tcl_Obj *paramObjPtr, Tcl_Obj *valueObj,
    const char *argNamePrefix, unsigned int doCheckArguments,
    bool isNamed, bool doConfigureParameter,
    Nsf_Param **paramPtrPtr, const char *qualifier
) {
  Nsf_Param       *paramPtr;
  NsfParamWrapper *paramWrapperPtr;
  Tcl_Obj         *outObjPtr;
  ClientData       checkedData;
  int              result;
  unsigned int     flags = 0u;

  nonnull_assert(interp != NULL);
  nonnull_assert(paramObjPtr != NULL);
  nonnull_assert(valueObj != NULL);

  /* fprintf(stderr, "ParameterCheck %s value %p %s\n",
     ObjStr(paramObjPtr), valueObj, ObjStr(valueObj)); */

  if (paramObjPtr->typePtr == &paramObjType) {
    paramWrapperPtr = (NsfParamWrapper *) paramObjPtr->internalRep.twoPtrValue.ptr1;
  } else {
    /*
     * Tcl_ConvertToType(..., &paramObjType) could be used  instead of checking
     * the type manually, but the goal is to pass the argNamePrefix explicitly.
     */
    result = ParamSetFromAny2(interp, argNamePrefix, doConfigureParameter, paramObjPtr, qualifier);
    if (likely(result == TCL_OK)) {
      paramWrapperPtr = (NsfParamWrapper *) paramObjPtr->internalRep.twoPtrValue.ptr1;
    } else {
      const char *errMsg = ObjStr(Tcl_GetObjResult(interp));

      Tcl_SetErrorCode(interp, "NSF", "VALUE", "CONSTRAINT", NULL);
      if (*errMsg == '\0') {
        return NsfPrintError(interp, "invalid value constraints \"%s\"",
                             ObjStr(paramObjPtr) );
      } else {
        return NsfPrintError(interp, "invalid value constraints \"%s\": %s",
                             ObjStr(paramObjPtr), errMsg);
      }
    }
  }
  paramPtr = paramWrapperPtr->paramPtr;
  if (paramPtrPtr != NULL) *paramPtrPtr = paramPtr;

  if (isNamed) {
    paramPtr->flags &= ~NSF_ARG_UNNAMED;
  }

  RUNTIME_STATE(interp)->doClassConverterOmitUnknown = 1;
  outObjPtr = NULL;
  result = ArgumentCheck(interp, valueObj, paramPtr, doCheckArguments, &flags, &checkedData, &outObjPtr);
  RUNTIME_STATE(interp)->doClassConverterOmitUnknown = 0;

  /*fprintf(stderr, "ParameterCheck paramPtr %p final refCount of wrapper %d can free %d flags %.6x\n",
    paramPtr, paramWrapperPtr->refCount,  paramWrapperPtr->canFree, flags);*/

  assert(paramWrapperPtr->refCount > 0);
  paramWrapperPtr->canFree = NSF_TRUE;

  if ((flags & NSF_PC_MUST_DECR) != 0u) {
    DECR_REF_COUNT2("valueObj", outObjPtr);
  }

  return result;
}



/***********************************************************************
 * Begin Object Methods
 ***********************************************************************/
/*
objectMethod autoname NsfOAutonameMethod {
  {-argName "-instance"}
  {-argName "-reset"}
  {-argName "name" -required 1 -type tclobj}
}
*/
static int
NsfOAutonameMethod(
    Tcl_Interp *interp, NsfObject *object, int withInstance, int withReset,
    Tcl_Obj *nameObj
) {
  Tcl_Obj *autonamedObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(nameObj != NULL);

  autonamedObj = AutonameIncr(interp, nameObj, object, withInstance, withReset);
  if (autonamedObj != NULL) {
    Tcl_SetObjResult(interp, autonamedObj);
    DECR_REF_COUNT2("autoname", autonamedObj);
    return TCL_OK;
  }

  return NsfPrintError(interp, "autoname failed. Probably format string (with %%) was not well-formed");
}

/*
objectMethod class NsfOClassMethod {
  {-argName "class" -required 0 -type tclobj}
}
*/
static int
NsfOClassMethod(Tcl_Interp *interp, NsfObject *object, Tcl_Obj *classObj) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  return NsfRelationSetCmd(interp, object, RelationtypeClassIdx, classObj);
}

/*
objectMethod cleanup NsfOCleanupMethod {
}
*/
static int
NsfOCleanupMethod(Tcl_Interp *interp, NsfObject *object) {
  NsfClass *class;
  Tcl_Obj  *savedNameObj;
  bool      softrecreate;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

#if defined(OBJDELETION_TRACE)
  fprintf(stderr, "+++ NsfOCleanupMethod\n");
#endif
  PRINTOBJ("NsfOCleanupMethod", object);

  savedNameObj = object->cmdName;
  INCR_REF_COUNT(savedNameObj);

  /*
   * Get the class before the object is destroyed.
   */
  class = NsfObjectToClass(object);
  /*
   * Save and pass around softrecreate.
   */
  softrecreate =
    ((object->flags & NSF_RECREATE) != 0u
     && RUNTIME_STATE(interp)->doSoftrecreate);

  CleanupDestroyObject(interp, object, softrecreate);
  CleanupInitObject(interp, object, object->cl, object->nsPtr, softrecreate);

  if (class != NULL) {
    CleanupDestroyClass(interp, class, softrecreate, NSF_TRUE);
    CleanupInitClass(interp, class, class->nsPtr, softrecreate, NSF_TRUE);
  }

  DECR_REF_COUNT(savedNameObj);
  return TCL_OK;
}

/*
objectMethod configure NsfOConfigureMethod {
  {-argName "args" -type allargs}
}
*/

static NsfObject* GetSlotObject(Tcl_Interp *interp, Tcl_Obj *slotObj)
  nonnull(1) nonnull(2);

static NsfObject*
GetSlotObject(Tcl_Interp *interp, Tcl_Obj *slotObj) {
  NsfObject *slotObject = NULL;

  nonnull_assert(interp != NULL);
  nonnull_assert(slotObj != NULL);

  if (unlikely(GetObjectFromObj(interp, slotObj, &slotObject) != TCL_OK || slotObject == NULL)) {
    NsfPrintError(interp, "couldn't resolve slot object %s", ObjStr(slotObj));
  }

  return slotObject;
}


static int
NsfOConfigureMethod(Tcl_Interp *interp, NsfObject *object, int objc, Tcl_Obj *const objv[], Tcl_Obj *objv0) {
  int result, i;
  NsfParsedParam  parsedParam;
  Nsf_Param      *paramPtr;
  NsfParamDefs   *paramDefs;
  Tcl_Obj        *newValue, *initMethodObj;
  const char     *initString;
  ParseContext    pc;
  CallFrame       frame, *framePtr = &frame, *uplevelVarFramePtr;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(objv != NULL);
  nonnull_assert(objv0 != NULL);

#if 0
  fprintf(stderr, "NsfOConfigureMethod %s.%s flags %.6x oc %2d", ObjectName(object), ObjStr(objv0), object->flags, objc);
  for(i = 0; i < objc; i++) {fprintf(stderr, " [%d]=%s,", i, ObjStr(objv[i]));}
  fprintf(stderr, "\n");
#endif

  /*
   * Get the object parameter definition.
   */
  result = GetObjectParameterDefinition(interp, objv0, object, NULL, &parsedParam);

  if (result != TCL_OK || parsedParam.paramDefs == NULL) {
    /*fprintf(stderr, "... nothing to do for method %s\n", ObjStr(objv0));*/
    return result;
  }

  /*
   * Get the initMethodObj/initString outside the loop iterating over the
   * arguments.
   */
  if (CallDirectly(interp, object, NSF_o_init_idx, &initMethodObj)) {
    initString = NULL;
  } else {
    initString = ObjStr(initMethodObj);
  }

  /*
   * The effective call site of the configure() method, e.g. for a proc or a
   * method, can result from up-leveling the object creation procedure.
   * Therefore, the *effective* call site can deviate from the *declaring* call
   * site,  e.g. as in XOTcl2's unknown method. In such a scenario, the
   * configure() dispatch finds itself in a particular call-stack
   * configuration: interp->framePtr indicates the top-most frame, while
   * interp->varFramePtr is at a lower call-stack level and indicates the
   * effective call site.
   *
   * Since configure pushes an object frame in order to access the instance
   * variables, and sometimes a CMETHOD frame for method invocations, record a)
   * whether there was a preceding uplevel, which can be determined through
   * comparing interp->framePtr and interp->varFramePtr, and b) the ruling
   * variable frame context. The preserved call-frame reference can later be
   * used to restore the uplevel'ed call frame context.
   */

  uplevelVarFramePtr =
    (Tcl_CallFrame *)Tcl_Interp_varFramePtr(interp) != Tcl_Interp_framePtr(interp)
    ? Tcl_Interp_varFramePtr(interp)
    : NULL;

  /*
   * Push frame to allow for [self] and make instance variables of the object
   * accessible as locals.
   */
  Nsf_PushFrameObj(interp, object, framePtr);

  /*
   * Process the actual arguments based on the parameter definitions.
   */
  paramDefs = parsedParam.paramDefs;
  ParamDefsRefCountIncr(paramDefs);

#if 0
  if (parsedParam.paramDefs != NULL) {
    Tcl_Obj *listObj = ParamDefsList(interp, paramDefs->paramsPtr, NULL, NULL);
    fprintf(stderr, "... got params <%s>\n", ObjStr(listObj));
  }
#endif

  result = ProcessMethodArguments(&pc, interp, object,
                                  NSF_ARGPARSE_START_ZERO, paramDefs,
                                  NsfGlobalObjs[NSF_CONFIGURE], objc, objv);

  if (unlikely(result != TCL_OK)) {
    Nsf_PopFrameObj(interp, framePtr);
    goto configure_exit;
  }

  /*
   * The arguments have now been verified valid according to the parameter
   * definitions, and the defaults set. Apply the arguments, mostly setting
   * instance variables.
   */

#if defined(CONFIGURE_ARGS_TRACE)
  fprintf(stderr, "*** POPULATE OBJ '%s': nr of parsed args %d\n", ObjectName(object), pc.objc);
#endif
  for (i = 1, paramPtr = paramDefs->paramsPtr;
       paramPtr->name != NULL;
       paramPtr++, i++) {

    /*
     * If the new value is given, set it.  If the default value is used, do not
     * overwrite already existing values, which might have been set via
     * parameter alias.
     */
    /*fprintf(stderr, "[%d] param %s, object init called %d is default %d value = '%s' nrArgs %d\n",
            i, paramPtr->name, (object->flags & NSF_INIT_CALLED),
            (pc.flags[i-1] & NSF_PC_IS_DEFAULT),
            ObjStr(pc.full_objv[i]), paramPtr->nrArgs);*/

    if ((pc.flags[i-1] & NSF_PC_IS_DEFAULT)) {
      /*
       * Object parameter method calls, i.e. calls with the flag
       * NSF_ARG_METHOD_INVOCATION set, do not set instance variables, so don't
       * check for existing variables.
       */
      if ((paramPtr->flags & NSF_ARG_METHOD_INVOCATION) == 0u) {
        Tcl_Obj *varObj = Tcl_ObjGetVar2(interp, paramPtr->nameObj, NULL, 0);

        if (varObj != NULL) {
          /*
           * The value exists already.  Ignore this parameter.
           */
          /*fprintf(stderr, "a variable for %s exists already, "
                  "ignore param flags %.6x valueObj %p\n",
                  paramPtr->name, paramPtr->flags, pc.full_objv[i]);*/
          continue;
        }
      } else if ((object->flags & NSF_INIT_CALLED) != 0u) {
        /*
         * The object is already initialized. Don't use the default since it
         * might change part of the state back to the original default.  This
         * might happen when e.g. configure is called on a class manually
         * and "superclass" has a default.
         */
        /*fprintf(stderr, "%s skip default %s in configure\n",
          ObjectName(object), ObjStr(pc.full_objv[i]));*/
        continue;
      }
    } else if (unlikely((paramPtr->flags & NSF_ARG_REQUIRED) != 0u
                        && pc.full_objv[i] == NsfGlobalObjs[NSF___UNKNOWN__])) {

      /* Previous versions contained a test for
       *   (object->flags & NSF_INIT_CALLED)
       *
       * to perform required testing only in the non-initialized state.  2.0b5
       * switched to checking for the existence of the associated instance
       * variable, which works under the assumption that the instance variable
       * has the same name and that e.g. a required alias parameter sets this
       * variable. There is a similar assumption in the default handling.
       * Future versions might use a more general approach to handle the
       * parameter states.
       */

      Tcl_Obj *varObj = Tcl_ObjGetVar2(interp, paramPtr->nameObj, NULL, 0);
      if (unlikely(varObj == NULL)) {
        Tcl_Obj *paramDefsObj = NsfParamDefsSyntax(interp, paramDefs->paramsPtr, object, NULL);

        NsfPrintError(interp, "required argument '%s' is missing, should be:\n        %s%s%s %s", (paramPtr->nameObj != NULL) ? ObjStr(paramPtr->nameObj) : paramPtr->name, (pc.object != NULL) ? ObjectName(pc.object) : "", (pc.object != NULL) ? " " : "",
                      ObjStr(pc.full_objv[0]),
                      ObjStr(paramDefsObj));
        DECR_REF_COUNT2("paramDefsObj", paramDefsObj);

        Nsf_PopFrameObj(interp, framePtr);
        result = TCL_ERROR;
        goto configure_exit;
      }
    }

    newValue = pc.full_objv[i];
    /*fprintf(stderr, "     new Value of %s = [%d] %p '%s', type %s addr %p\n",
            ObjStr(paramPtr->nameObj), i,
            newValue, (newValue != NULL) ? ObjStr(newValue) : "(null)", paramPtr->type,
            &(pc.full_objv[i]));*/

    /*
     * Handle slot initialization.
     */
    if ((paramPtr->flags & NSF_ARG_SLOTINITIALIZE) != 0u) {
      NsfObject *slotObject = GetSlotObject(interp, paramPtr->slotObj);

      if (likely(slotObject != NULL)) {
        Tcl_Obj *ov[1];

        ov[0] = paramPtr->nameObj;
        result = NsfCallMethodWithArgs(interp, (Nsf_Object *)slotObject, NsfGlobalObjs[NSF_INITIALIZE],
                                       object->cmdName, 2, ov,
                                       NSF_CSC_IMMEDIATE|NSF_CM_IGNORE_PERMISSIONS);

      }
      if (unlikely(result != TCL_OK)) {
        /*
         * The error message was set either by GetSlotObject or by ...CallMethod...
         */
        Nsf_PopFrameObj(interp, framePtr);
        goto configure_exit;
      }
    }

    /*
     * Special setter methods for invoking method calls, which handle
     * "cmd", "initcmd", "alias" and "forward".
     */
    if ((paramPtr->flags & NSF_ARG_METHOD_INVOCATION) != 0u) {
      int consuming = (*paramPtr->name == '-' || paramPtr->nrArgs > 0);

      if (consuming && newValue == NsfGlobalObjs[NSF___UNKNOWN__]) {
        /*
         * If there is consuming parameter but no value provided and no
         * default, there is no reason to call the invocation parameter.
         */
        /*fprintf(stderr, "%s consuming nrargs %d no value\n", paramPtr->name, paramPtr->nrArgs);*/
        continue;
      }

      if ((paramPtr->flags & NSF_ARG_INITCMD) != 0u) {

        if (paramPtr->defaultValue != NULL) {
          /*
           * The "defaultValue" holds the initcmd to be evaluated.
           */
          Tcl_Obj *varObj = Tcl_ObjGetVar2(interp, NsfGlobalObjs[NSF_ARRAY_INITCMD],
                                           paramPtr->nameObj, 0);

          /*fprintf(stderr, "### NSF_ARRAY_INITCMD %s has a value %s\n",
                  NsfGlobalStrings[NSF_ARRAY_INITCMD],
                  ObjStr(paramPtr->defaultValue));*/

          if (varObj == NULL) {
            /*
             * The variable is not set. Assume that initcmd must be
             * executed.  On success, note the execution in the
             * NSF_ARRAY_INITCMD variable, usually __initcmd(name).
             */
            result = ParameterMethodDispatch(interp, object, paramPtr, paramPtr->defaultValue,
                                             uplevelVarFramePtr, initString,
                                             (Tcl_Obj **)&objv[pc.lastObjc],
                                             objc - pc.lastObjc);

            if (unlikely(result != TCL_OK)) {
              Nsf_PopFrameObj(interp, framePtr);
              goto configure_exit;
            }
            if (unlikely(Tcl_ObjSetVar2(interp, NsfGlobalObjs[NSF_ARRAY_INITCMD],
                                        paramPtr->nameObj, Tcl_NewIntObj(1), TCL_LEAVE_ERR_MSG) == NULL)) {
              Nsf_PopFrameObj(interp, framePtr);
              goto configure_exit;
            }
          }

        } else {
          /*
           * Consider requiring a default.
           */
        }
        /*
         * Proceed to setvars if there is a new actual value.
         */
        if ((pc.flags[i-1] & NSF_PC_IS_DEFAULT) == 0) {
          goto setvars;
        }
        continue;
      }
      /*
       * lastObjc points to the first "unprocessed" argument, so the argument
       * before should be valid if lastObjc > 1
       */
      if (pc.lastObjc > 1) {
        assert(ISOBJ(objv[pc.lastObjc-1]));
      }
      result = ParameterMethodDispatch(interp, object, paramPtr, newValue,
                                       uplevelVarFramePtr, initString,
                                       (Tcl_Obj **)&objv[pc.lastObjc],
                                       objc - pc.lastObjc);
      if (unlikely(result != TCL_OK)) {
        Nsf_PopFrameObj(interp, framePtr);
        goto configure_exit;
      }
      continue;
    }

  setvars:
    if (newValue == NsfGlobalObjs[NSF___UNKNOWN__]) {
      /*
       * Nothing to do.  There a value setter but no value was given and no
       * default was provided.
       */
      continue;
    }

    if (i < paramDefs->nrParams || (!pc.varArgs)) {
        /*
         * The last argument of the definition is not varArgs.  Set the
         * instance variable.
         */

#if defined(CONFIGURE_ARGS_TRACE)
      fprintf(stderr, "*** %s SET %s '%s' // %p\n",
              ObjectName(object), ObjStr(paramPtr->nameObj), ObjStr(newValue), paramPtr->slotObj);
#endif
      /*
       * Use the default value if no value was given.  If needed call the
       * setter, which is typically a forwarder to the slot object.
       */

      if ((paramPtr->flags & NSF_ARG_SLOTSET) != 0u) {
        NsfObject *slotObject = GetSlotObject(interp, paramPtr->slotObj);

        if (likely(slotObject != NULL)) {
          Tcl_Obj *ov[2];
          Tcl_Obj *methodObj = NsfMethodObj(object, NSF_s_set_idx);

          ov[0] = (paramPtr->method != NULL) ? paramPtr->method : paramPtr->nameObj;
          ov[1] = newValue;

          /*fprintf(stderr, "SLOTSET %s %s %s %s %s idx %d %p\n", ObjectName(slotObject),
                  ObjStr(NsfGlobalObjs[NSF_SET]), ObjStr(object->cmdName),
                  ObjStr(paramPtr->nameObj), ObjStr(newValue),
                  NSF_s_set_idx, methodObj);*/

          result = NsfCallMethodWithArgs(interp, (Nsf_Object *)slotObject,
                                         (methodObj != NULL) ? methodObj : NsfGlobalObjs[NSF_SLOT_SET],
                                         object->cmdName, 3, ov, NSF_CSC_IMMEDIATE);
        }
        if (unlikely(result != TCL_OK)) {
          /*
           * The error message was set either by GetSlotObject or by ...CallMethod...
           */
          Nsf_PopFrameObj(interp, framePtr);
          goto configure_exit;
        }
      } else {
        Tcl_Obj *resultObj;
        /*
         * Call the standard Tcl variable setting routine.
         */
        resultObj = Tcl_ObjSetVar2(interp, paramPtr->nameObj, NULL, newValue, TCL_LEAVE_ERR_MSG);
        if (unlikely(resultObj == NULL)) {
          /*
           * If setting failed, e.g. because of variable traces, report the
           * error.
           */
          result = TCL_ERROR;
          Nsf_PopFrameObj(interp, framePtr);
          goto configure_exit;
        }
      }
    }
  }

  Nsf_PopFrameObj(interp, framePtr);

 configure_exit:

  ParamDefsRefCountDecr(paramDefs);
  ParseContextRelease(&pc);

  if (likely(result == TCL_OK)) {
    Tcl_ResetResult(interp);
  }
  return result;
}

/*
objectMethod cget NsfOCgetMethod {
  {-argName "name" -type tclobj -required 1}
}
*/
static int
NsfOCgetMethod(Tcl_Interp *interp, NsfObject *object, Tcl_Obj *nameObj) {
  int              result;
  NsfParsedParam   parsedParam;
  const Nsf_Param *paramPtr = NULL;
  CallFrame        frame, *framePtr = &frame, *uplevelVarFramePtr;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(nameObj != NULL);

  /*
   * Get the object parameter definition.
   */

  result = GetObjectParameterDefinition(interp, NsfGlobalObjs[NSF_EMPTY],
                                        object, NULL, &parsedParam);
  if (unlikely(result != TCL_OK)) {
    return result;
  }

  /*
   * GetObjectParameterDefinition() returned TCL_OK, so the paramdefs have
   * been set.
   */
  assert(parsedParam.paramDefs != NULL);

  /*
   * For the time being pass NULL as cscPtr to ParameterMethodForwardDispatch
   * instead of pushing an NSF_CSC_TYPE_PLAIN frame, as NsfOConfigureMethod
   * does, even though it might be necessary for full compatibility. TODO:
   * Check and compare with configure stack setup.
   */

  /*
   * The uplevel handling is exactly the same as in NsfOConfigureMethod(), and
   * is needed when methods that use upvar are called.
   */
  uplevelVarFramePtr =
    (Tcl_CallFrame *)Tcl_Interp_varFramePtr(interp) != Tcl_Interp_framePtr(interp)
    ? Tcl_Interp_varFramePtr(interp)
    : NULL;

  /*
   * Push frame to allow invocations of [self] and to make instance variables
   * of the object accessible as locals.
   */
  Nsf_PushFrameObj(interp, object, framePtr);
  ParamDefsRefCountIncr(parsedParam.paramDefs);

  result = CGetParamLookup(interp, nameObj, parsedParam.paramDefs, &paramPtr);
  if (result != TCL_OK) {
    /*
     * Error message is already set by CGetParamLookup().
     */
  } else if (paramPtr == NULL) {
    result = NsfPrintError(interp, "cget: unknown configure parameter %s", ObjStr(nameObj));

  } else {

    /*
     * Is there a slot invocation?
     */
    if (paramPtr->slotObj != NULL) {
      NsfObject *slotObject = GetSlotObject(interp, paramPtr->slotObj);
      Tcl_Obj   *methodObj = NsfMethodObj(object, NSF_s_get_idx);
      Tcl_Obj   *ov[1];

      /*
       * Get instance variable via the slot.
       */
      if (uplevelVarFramePtr != NULL) {
        Tcl_Interp_varFramePtr(interp) = uplevelVarFramePtr;
      }
      ov[0] = (paramPtr->method != NULL) ? paramPtr->method : paramPtr->nameObj;

      /*fprintf(stderr, "SLOTGET %s idx %d %p method %s\n", ObjectName(slotObject),
        NSF_s_get_idx, (void *)methodObj, ObjStr(ov[0]));*/

      result = NsfCallMethodWithArgs(interp, (Nsf_Object *)slotObject,
                                     (methodObj != NULL) ? methodObj : NsfGlobalObjs[NSF_SLOT_GET],
                                     object->cmdName, 2, ov, NSF_CSC_IMMEDIATE);
    } else {
      /*
       * Proceed without a slot.
       */
      if ((paramPtr->flags & NSF_ARG_METHOD_CALL) != 0u) {
        if ((paramPtr->flags & NSF_ARG_ALIAS) != 0u) {
          /*
           * It is a parameter associated with an aliased method. Invoke the
           * method without an argument.
           */
          Tcl_Obj *methodObj = (paramPtr->method != NULL) ? paramPtr->method : paramPtr->nameObj;

          if (uplevelVarFramePtr != NULL) {
            Tcl_Interp_varFramePtr(interp) = uplevelVarFramePtr;
          }

          result = CallMethod(object, interp, methodObj, 2, NULL, NSF_CSC_IMMEDIATE);
        } else {
          /*
           * Must be NSF_ARG_FORWARD.
           */
          assert((paramPtr->flags & NSF_ARG_FORWARD) != 0u);

          /*
           * Since there is no cscPtr, pass NULL.
           */
          result = ParameterMethodForwardDispatch(interp, object,
                                                  paramPtr, NULL, NULL /* cscPtr */);
        }
      } else {
      /*
       * It must must be a parameter associated with a variable.
       */
        unsigned int flags = (object->nsPtr != NULL) ? (TCL_LEAVE_ERR_MSG|TCL_NAMESPACE_ONLY) : TCL_LEAVE_ERR_MSG;
        Tcl_Obj     *resultObj = Tcl_ObjGetVar2(interp, paramPtr->nameObj, NULL, (int)flags);

        if (resultObj != NULL) {
          /*
           * The value exists.
           */
          Tcl_SetObjResult(interp, resultObj);
        }
      }
    }
  }

  Nsf_PopFrameObj(interp, framePtr);
  ParamDefsRefCountDecr(parsedParam.paramDefs);

  return result;
}

/*
objectMethod destroy NsfODestroyMethod {
}
*/
static int
NsfODestroyMethod(Tcl_Interp *interp, NsfObject *object) {
  PRINTOBJ("NsfODestroyMethod", object);

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  /*
   * Provide protection against destroy on base classes.
   */
  if (unlikely(IsBaseClass(object))) {
    if (RUNTIME_STATE(interp)->exitHandlerDestroyRound != NSF_EXITHANDLER_ON_SOFT_DESTROY) {
      return NsfPrintError(interp, "cannot destroy base class %s", ObjectName_(object));
    }
  }

  /*fprintf(stderr, "NsfODestroyMethod %p %s flags %.6x activation %d cmd %p cmd->flags %.6x\n",
          object, ((Command *)object->id)->flags == 0 ? ObjectName(object) : "(deleted)",
          object->flags, object->activationCount, object->id, ((Command *)object->id)->flags);*/

  /*
   * NSF_DESTROY_CALLED might be set already by DispatchDestroyMethod() for the
   * implicit destroy calls, but it is necessary to set it here for the
   * explicit destroy calls in the script which reach the Object->destroy.
   */

  if ((object->flags & NSF_DESTROY_CALLED) == 0u) {
    object->flags |= NSF_DESTROY_CALLED;
    /*fprintf(stderr, "NsfODestroyMethod %p sets DESTROY_CALLED %.6x\n", object, object->flags);*/
  }
  object->flags |= NSF_DESTROY_CALLED_SUCCESS;

  if (likely((object->flags & NSF_DURING_DELETE) == 0u)) {
    int result;
    Tcl_Obj *methodObj;

    /*fprintf(stderr, "   call dealloc on %p %s\n", object,
      ((Command *)object->id)->flags == 0u ? ObjectName(object) : "(deleted)");*/

    if (CallDirectly(interp, &object->cl->object, NSF_c_dealloc_idx, &methodObj)) {
      NSF_PROFILE_TIME_DATA;
      NSF_PROFILE_CALL(interp, &object->cl->object, Nsf_SystemMethodOpts[NSF_c_dealloc_idx]);
      result = DoDealloc(interp, object);
      NSF_PROFILE_EXIT(interp, &object->cl->object, Nsf_SystemMethodOpts[NSF_c_dealloc_idx]);
    } else {
      result = NsfCallMethodWithArgs(interp, (Nsf_Object *)object->cl, methodObj,
                                     object->cmdName, 1, NULL,
                                     NSF_CSC_IMMEDIATE|NSF_CM_IGNORE_PERMISSIONS);
      if (unlikely(result != TCL_OK)) {
        /*
         * If the call of the dealloc method has failed above, e.g. NS_DYING,
         * call dealloc manually to prevent a memory leak.
         */
        /*fprintf(stderr, "*** dealloc failed for %p %s flags %.6x, retry\n",
          object, ObjectName(object), object->flags);*/
        result = DoDealloc(interp, object);
      }
    }
    return result;
  } else {
#if defined(OBJDELETION_TRACE)
    fprintf(stderr, "  Object->destroy already during delete, don't call dealloc %p\n", object);
#endif
  }
  return TCL_OK;
}

/*
objectMethod exists NsfOExistsMethod {
  {-argName "varName" -required 1}
}
*/
static int
NsfOExistsMethod(Tcl_Interp *interp, NsfObject *object, const char *varName) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(varName != NULL);

  Tcl_SetIntObj(Tcl_GetObjResult(interp),
                VarExists(interp, object, varName, NULL,
                          NSF_VAR_TRIGGER_TRACE|NSF_VAR_REQUIRE_DEFINED));
  return TCL_OK;
}

/*
objectMethod filterguard NsfOFilterGuardMethod {
  {-argName "filter" -required 1}
  {-argName "guard" -required 1 -type tclobj}
}
*/

static int
NsfOFilterGuardMethod(Tcl_Interp *interp, NsfObject *object, const char *filter, Tcl_Obj *guardObj) {
  NsfObjectOpt *opt;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(filter != NULL);
  nonnull_assert(guardObj != NULL);

  opt = object->opt;
  if (opt != NULL && opt->objFilters) {
    NsfCmdList *h;

    h = CmdListFindNameInList(interp, filter, opt->objFilters);
    if (h != NULL) {
      if (h->clientData != NULL) {
        GuardDel((NsfCmdList *) h);
      }
      GuardAdd(h, guardObj);
      object->flags &= ~NSF_FILTER_ORDER_VALID;
      return TCL_OK;
    }
  }

  return NsfPrintError(interp, "filterguard: can't find filter %s on %s",
                       filter, ObjectName_(object));
}

/*
objectMethod instvar NsfOInstvarMethod {
  {-argName "args" -type allargs}
}
*/

static int
NsfOInstvarMethod(Tcl_Interp *interp, NsfObject *object, int objc, Tcl_Obj *const objv[]) {
  callFrameContext ctx = {NULL, NULL, 0};
  int              result;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  if ((object->filterStack != NULL) || (object->mixinStack != NULL)) {
    CallStackUseActiveFrame(interp, &ctx);
  }

  if (unlikely(Tcl_Interp_varFramePtr(interp) == NULL)) {
    CallStackRestoreSavedFrames(interp, &ctx);
    return NsfPrintError(interp, "instvar used on %s, but call-stack is not in procedure scope",
                         ObjectName_(object));
  }

  result = NsfVarImport(interp, object, ObjStr(objv[0]), objc-1, objv+1);
  CallStackRestoreSavedFrames(interp, &ctx);

  return result;
}

/*
objectMethod mixinguard NsfOMixinGuardMethod {
  {-argName "mixin" -required 1 -type tclobj}
  {-argName "guard" -required 1 -type tclobj}
}
*/

static int
NsfOMixinGuardMethod(Tcl_Interp *interp, NsfObject *object, Tcl_Obj *mixinObj, Tcl_Obj *guardObj) {
  NsfObjectOpt *opt;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(mixinObj != NULL);
  nonnull_assert(guardObj != NULL);

  opt = object->opt;
  if (opt != NULL && opt->objMixins) {
    const Tcl_Command mixinCmd = Tcl_GetCommandFromObj(interp, mixinObj);

    if (mixinCmd != NULL) {
      const NsfClass *mixinClass = NsfGetClassFromCmdPtr(mixinCmd);

      if (mixinClass != NULL) {
        NsfCmdList *h = CmdListFindCmdInList(mixinCmd, opt->objMixins);

        if (h != NULL) {
          if (h->clientData != NULL) {
            GuardDel((NsfCmdList *) h);
          }
          GuardAdd(h, guardObj);
          object->flags &= ~NSF_MIXIN_ORDER_VALID;
          return TCL_OK;
        }
      }
    }
  }

  return NsfPrintError(interp, "mixinguard: can't find mixin %s on %s",
                       ObjStr(mixinObj), ObjectName_(object));
}

/*
objectMethod noinit NsfONoinitMethod {
}
*/
static int
NsfONoinitMethod(Tcl_Interp *UNUSED(interp), NsfObject *object) {

  nonnull_assert(object != NULL);

  object->flags |= NSF_INIT_CALLED;
  return TCL_OK;
}

/*
objectMethod requirenamespace NsfORequireNamespaceMethod {
}
*/
static int
NsfORequireNamespaceMethod(Tcl_Interp *interp, NsfObject *object) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  RequireObjNamespace(interp, object);
  return TCL_OK;
}

/*
objectMethod residualargs NsfOResidualargsMethod {
  {-argName "args" -type allargs}
}
*/
static int
NsfOResidualargsMethod(Tcl_Interp *interp, NsfObject *object, int objc, Tcl_Obj *const objv[]) {
  int          i, start = 1, argc, nextArgc, normalArgs, result = TCL_OK;
  dashArgType  isdasharg = NO_DASH;
  const char  *methodName, *nextMethodName, *initString = NULL;
  Tcl_Obj    **argv = NULL, **nextArgv;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

#if 0
  fprintf(stderr, "NsfOResidualargsMethod %s %2d ", ObjectName_(object), objc);
  for(i = 0; i < objc; i++) {fprintf(stderr, " [%d]=%p %s,", i, &objv[i], ObjStr(objv[i]));}
  fprintf(stderr, "\n");
#endif

  /*
   * Skip arguments without leading dash.
   */
  for (i = start; i < objc; i++) {
    if ((isdasharg = IsDashArg(interp, objv[i], 1, &methodName, &argc, &argv))) {
      break;
    }
  }
  normalArgs = i-1;

  /*
   * Get the init string before entering the loop.  If initString is not
   * obtainable, i.e. not configured in the object system, don't call the
   * "init" method in the loop.
   */
  if (i < objc) {
    NsfObjectSystem *osPtr   = GetObjectSystem(object);
    Tcl_Obj         *initObj = osPtr->methods[NSF_o_init_idx];

    if (initObj != NULL) {
      initString = osPtr->methodNames[NSF_o_init_idx];
      assert(initString != NULL);
    }
  }


  for( ; i < objc;  argc = nextArgc, argv = nextArgv, methodName = nextMethodName) {

    Tcl_ResetResult(interp);

    switch (isdasharg) {
    case SCALAR_DASH:    /* Argument is a scalar with a leading dash */
      { int j;

        nextMethodName = NULL;
        nextArgv = NULL;
        nextArgc = 0;

        for (j = i+1; j < objc; j++, argc++) {
          if ((isdasharg = IsDashArg(interp, objv[j], 1, &nextMethodName, &nextArgc, &nextArgv))) {
            break;
          }
        }
        if (initString != NULL) {
          result = CallConfigureMethod(interp, object, initString, methodName, argc+1, objv+i+1);
          if (unlikely(result != TCL_OK)) {
            return result;
          }
        }
        i += argc;
        break;
      }

    case LIST_DASH:  /* Argument is a list with a leading dash, grouping determined by list */
      i++;
      nextMethodName = NULL;

      if (i < objc) {
        isdasharg = IsDashArg(interp, objv[i], 1, &nextMethodName, &nextArgc, &nextArgv);
      } else {
        nextMethodName = NULL;
        nextArgv = NULL;
        nextArgc = 0;
      }
      if (initString != NULL) {
        result = CallConfigureMethod(interp, object, initString, methodName, argc+1, argv+1);
        if (unlikely(result != TCL_OK)) {
          return result;
        }
      }
      break;

    case NO_DASH:
      nextArgc = 0;
      return NsfPrintError(interp, "%s configure: unexpected argument '%s' between parameters",
                             ObjectName_(object), ObjStr(objv[i]));
    }
  }

  /*
   * Call init with residual args in case it was not called yet.
   */
  result = DispatchInitMethod(interp, object, normalArgs, objv+1, 0u);

  if (likely(result == TCL_OK)) {
    /*
     * Return the non-processed leading arguments unless there was an error
     * (XOTcl convention).
     */
    Tcl_SetObjResult(interp, Tcl_NewListObj(normalArgs, objv+1));
  }

  return result;
}

/*
objectMethod uplevel NsfOUplevelMethod {
  {-argName "args" -type allargs}
}
*/
static int
NsfOUplevelMethod(Tcl_Interp *interp, NsfObject *object, int objc, Tcl_Obj *const objv[]) {
  int        result, getFrameResult = 0;
  CallFrame *requestedFramePtr = NULL;

  nonnull_assert(interp != NULL);
  nonnull_assert(objv != NULL);

  if (objc < 2) {
    result = NsfPrintError(interp,
                         "wrong # args: should be \"%s %s ?level? command ?arg ...?\"",
                         ObjectName_(object),
                         NsfMethodName(objv[0]));

  } else  if (objc == 2) {
    result = TCL_OK;

  } else {
    /*
     * TclObjGetFrame returns:
     *  0
     *      A syntactically invalid level specifier or no level specifier
     *      was given.
     *  1
     *      A syntactically valid level specifier with corresponding frame
     *      was found.
     * -1
     *      A syntactically valid level specifier was given, but an error
     *      occurred while finding the frame, leaving an error msg, "bad
     *      level", in the interpreter.
     */
    getFrameResult = TclObjGetFrame(interp, objv[1], &requestedFramePtr);
    result = unlikely(getFrameResult == -1) ? TCL_ERROR : TCL_OK;
  }

  if (likely(result == TCL_OK)) {
    Tcl_CallFrame *framePtr, *savedVarFramePtr;

    objc -= getFrameResult + 1;
    objv += getFrameResult + 1;

    if (getFrameResult == 0) {
      /*
       * TclObjGetFrame returns 0 when an invalid level specifer or no level
       * specifier is given, in which case objv[0] is interpreted as a command
       * word and the default level is computed.
       */
      Tcl_CallFrame *callingFramePtr = NULL;

      framePtr = NULL;
      NsfCallStackFindCallingContext(interp, 1, &framePtr, &callingFramePtr);

      if (framePtr == NULL) {
        /*
         * No proc frame was found.  Default to parent frame.
         */
        framePtr = callingFramePtr;
      }
    } else {
      /*
       * Use the requested frame corresponding to the (valid) level specifier.
       */
      framePtr = (Tcl_CallFrame *)requestedFramePtr;
    }

    assert(framePtr != NULL);

    savedVarFramePtr = (Tcl_CallFrame *)Tcl_Interp_varFramePtr(interp);
    Tcl_Interp_varFramePtr(interp) = (CallFrame *)framePtr;

    /*
     * Execute the residual arguments as a command.
     */

    if (objc == 1) {
      result = Tcl_EvalObjEx(interp, objv[0], TCL_EVAL_DIRECT);
    } else {
      /*
       * Concatenate multiple arguments together delimited by the space
       * character and then then evaluate the result.  Tcl_EvalObjEx() deletes
       * the object when it decrements its refCount after evaluating it.
       */
      Tcl_Obj *objPtr = Tcl_ConcatObj(objc, objv);

      result = Tcl_EvalObjEx(interp, objPtr, TCL_EVAL_DIRECT);
    }

    if (unlikely(result == TCL_ERROR)) {
      Tcl_AppendObjToErrorInfo(interp,
                               Tcl_ObjPrintf("\n    (\"uplevel\" body line %d)",
                                             Tcl_GetErrorLine(interp)));
    }

    /*
     * Restore the variable frame and return.
     */
    Tcl_Interp_varFramePtr(interp) = (CallFrame *)savedVarFramePtr;
  }

  return result;
}

/*
objectMethod upvar NsfOUpvarMethod {
  {-argName "args" -type allargs}
}
*/
static int
NsfOUpvarMethod(Tcl_Interp *interp, NsfObject *object, int objc, Tcl_Obj *const objv[]) {
  Tcl_Obj         *frameInfoObj;
  int              i, result = TCL_ERROR;
  const char      *frameInfo;
  callFrameContext ctx = {NULL, NULL, 0};

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  if (objc < 3) {
    return NsfPrintError(interp,
                         "wrong # args: should be \"%s %s "
                         "?level? otherVar localVar ?otherVar localVar ...?\"",
                         ObjectName_(object),
                         NsfMethodName(objv[0]));
  }

  if (objc % 2 == 0) {
    /*
     * There is an even number of arguments including the method name so the
     * level specifier is the first argument.
     */
    frameInfoObj = NULL;
    frameInfo = ObjStr(objv[1]);
    i = 2;
  } else {
    /*
     * Odd number of arguments including the method name so the level
     * specifier is absent and must be computed.
     */
    frameInfoObj = ComputeLevelObj(interp, CALLING_LEVEL);
    INCR_REF_COUNT(frameInfoObj);
    frameInfo = ObjStr(frameInfoObj);
    i = 1;
  }

  if ((object->filterStack != NULL) || (object->mixinStack != NULL)) {
    CallStackUseActiveFrame(interp, &ctx);
  }

  for ( ;  i < objc;  i += 2) {
    result = Tcl_UpVar2(interp, frameInfo, ObjStr(objv[i]), NULL,
                        ObjStr(objv[i+1]), 0 /*flags*/);
    if (unlikely(result != TCL_OK)) {
      break;
    }
  }

  if (frameInfoObj != NULL) {
    DECR_REF_COUNT(frameInfoObj);
  }
  CallStackRestoreSavedFrames(interp, &ctx);
  return result;

}

/*
objectMethod volatile NsfOVolatileMethod {
}
objectMethod volatile1 NsfOVolatile1Method {
}
*/
static int
VolatileMethod(Tcl_Interp *interp, NsfObject *object, bool shallow) {
  int               result = TCL_ERROR;
  Tcl_Obj          *objPtr;
  const char       *fullName, *vn;
  callFrameContext  ctx = {NULL, NULL, 0};

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  if (unlikely(RUNTIME_STATE(interp)->exitHandlerDestroyRound != NSF_EXITHANDLER_OFF)) {
    return NsfPrintError(interp, "can't make objects volatile during shutdown");
  }

  if (shallow) {
    CallStackUseActiveFrame(interp, &ctx);

  } else {
    NsfObjectSystem *osPtr = GetObjectSystem(object);
    Tcl_CallFrame   *invocationFrame;

    /*
     * XOTcl1 style.
     */
    /*NsfShowStack(interp);*/

    CallStackUseActiveFrame(interp, &ctx);

    /*fprintf(stderr, "active varframe %p\n", (void*)Tcl_Interp_varFramePtr(interp));*/
    invocationFrame = (Tcl_CallFrame *)Tcl_Interp_varFramePtr(interp);

    while (1) {

      if (((unsigned int)Tcl_CallFrame_isProcCallFrame(invocationFrame)
        & (FRAME_IS_NSF_METHOD|FRAME_IS_NSF_CMETHOD)) != 0u) {

        NsfCallStackContent *cscPtr;

        cscPtr = ((NsfCallStackContent *)Tcl_CallFrame_clientData(invocationFrame));
        if (cscPtr == NULL) {
          /*
           * Not called from an Nsf frame.
           */
          break;
        }


        /*
         * Walk up the stack of invocations of the current object to skip
         * e.g. overloaded internally-called methods like "configure".
         */
        /*fprintf(stderr, "compare object %p == %p\n", (void*)object, (void*)cscPtr->self);*/
        if (cscPtr->self == object) {
          invocationFrame =  Tcl_CallFrame_callerPtr(invocationFrame);
          /*fprintf(stderr, "same object, continue with %p\n", (void*)invocationFrame);*/
          continue;
        }

        /*
         * If this was a "next" call, continue to walk up.
         */
        if ((cscPtr->flags & NSF_CSC_CALL_IS_NEXT) != 0u) {
          invocationFrame =  Tcl_CallFrame_callerPtr(invocationFrame);
          /*fprintf(stderr, "next call with %p\n", (void*)invocationFrame);*/
          continue;
        }

        /*
         * Final special case for conforming to XOTcl1: Skip this frame as well
         * if called from an "unknown" method.
         */
        /*fprintf(stderr, "cmd %s\n", Tcl_GetCommandName(interp, cscPtr->cmdPtr));*/
        if (strcmp(osPtr->methodNames[NSF_o_unknown_idx], Tcl_GetCommandName(interp, cscPtr->cmdPtr)) == 0) {
          invocationFrame =  Tcl_CallFrame_callerPtr(invocationFrame);
          /*fprintf(stderr, "have unknown, continue with %p\n", (void*)invocationFrame);*/
          continue;
        }

      }
      break;
    }
    /*
     * Finally, set the invocation frame. The original frame context was
     * already saved by CallStackUseActiveFrame() and is restored later.
     */
    Tcl_Interp_varFramePtr(interp) = (CallFrame *)invocationFrame;

  }

  objPtr = object->cmdName;
  fullName = ObjStr(objPtr);
  vn = NSTail(fullName);

  if (Tcl_SetVar2(interp, vn, NULL, fullName, 0)) {
    NsfObjectOpt *opt = NsfRequireObjectOpt(object);

    /*fprintf(stderr, "### setting trace for %s on frame %p\n", fullName,
      Tcl_Interp_varFramePtr(interp));
      NsfShowStack(interp);*/
    result = Tcl_TraceVar(interp, vn, TCL_TRACE_UNSETS,
                          (Tcl_VarTraceProc *)NsfUnsetTrace,
                          objPtr);
    opt->volatileVarName = vn;
  }
  CallStackRestoreSavedFrames(interp, &ctx);

  if (likely(result == TCL_OK)) {
    INCR_REF_COUNT(objPtr);
  }
  return result;
}

static int
NsfOVolatileMethod(Tcl_Interp *interp, NsfObject *object) {

  return VolatileMethod(interp, object, NSF_TRUE);
}

static int
NsfOVolatile1Method(Tcl_Interp *interp, NsfObject *object) {

  return VolatileMethod(interp, object, NSF_FALSE);
}

/***********************************************************************
 * End Object Methods
 ***********************************************************************/


/***********************************************************************
 * Begin Class Methods
 ***********************************************************************/

static int
NsfCAllocMethod_(
  Tcl_Interp *interp,
  NsfClass *class,
  Tcl_Obj *nameObj,
  Tcl_Namespace *parentNsPtr)
{
  const char *nameString;
  NsfObject  *newObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(nameObj != NULL);

  nameString = ObjStr(nameObj);
  assert(isAbsolutePath(nameString));
  assert(NSValidObjectName(nameString, 0) != 0);

  /*
   * Create a new object from scratch.
   */
  if (! IsMetaClass(interp, class, NSF_TRUE)) {
    /*
     * If the base class is an ordinary class, create an object.
     */
    newObj = PrimitiveOCreate(interp, nameObj, parentNsPtr, class);

  } else {
    /*
     * If the base class is a metaclass, create a class.
     */
    newObj = (NsfObject *)PrimitiveCCreate(interp, nameObj, parentNsPtr, class);
  }

  if (unlikely(newObj == NULL)) {
    return NsfPrintError(interp, "alloc failed to create '%s' "
                         "(possibly parent namespace does not exist)",
                         nameString);
  }

  if (NSF_DTRACE_OBJECT_ALLOC_ENABLED()) {
    NSF_DTRACE_OBJECT_ALLOC(ObjectName(newObj), ClassName(class));
  }

  /*fprintf(stderr, "PrimitiveCCreate returns nameObj %p typePtr %p %s\n",
          nameObj, nameObj->typePtr,
          ObjTypeStr(nameObj)); */
  Tcl_SetObjResult(interp, nameObj);

  return TCL_OK;
}

/*
classMethod alloc NsfCAllocMethod {
  {-argName "name" -required 1 -type tclobj}
}
*/
static int
NsfCAllocMethod(Tcl_Interp *interp, NsfClass *class, Tcl_Obj *nameObj) {
  const char *nameString;
  int         result, nameLength = 0;

  /*
   * Create a new object from scratch.
   */

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(nameObj != NULL);

  nameString = TclGetStringFromObj(nameObj, &nameLength);
  if (unlikely(NSValidObjectName(nameString, (size_t)nameLength) == 0)) {
    result = NsfPrintError(interp, "cannot allocate object - illegal name '%s'", nameString);
  } else {
    Tcl_Namespace *parentNsPtr;
    Tcl_Obj       *tmpName;

    /*
     * Name is valid. Fully-qualify it.
     */
    if (isAbsolutePath(nameString)) {
      parentNsPtr = NULL;
      tmpName = NULL;
    } else {
      parentNsPtr = CallingNameSpace(interp);
      nameObj = tmpName = NameInNamespaceObj(nameString, parentNsPtr);
      if (strchr(nameString, ':')) {
        parentNsPtr = NULL;
      }
      INCR_REF_COUNT(tmpName);
      /*fprintf(stderr, " **** NoAbsoluteName for '%s' -> determined = '%s' parentNs %s\n",
        nameString, ObjStr(tmpName), parentNsPtr->fullName);*/
    }

    result = NsfCAllocMethod_(interp, class, nameObj, parentNsPtr);

    if (tmpName != NULL) {
      DECR_REF_COUNT(tmpName);
    }
  }
  return result;
}

/*
classMethod create NsfCCreateMethod {
  {-argName "name" -required 1}
  {-argName "args" -type allargs}
}
*/
static int
NsfCCreateMethod(Tcl_Interp *interp, NsfClass *class, Tcl_Obj *nameObj, int objc, Tcl_Obj *const objv[]) {
  NsfObject     *newObject = NULL;
  Tcl_Obj       *actualNameObj, *methodObj, *tmpObj = NULL;
  int            result, nameLength = 0;
  bool           autoNameCreate;
  const char    *nameString;
  Tcl_Namespace *parentNsPtr;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(nameObj != NULL);
  nonnull_assert(objv != NULL);

  nameString = TclGetStringFromObj(nameObj, &nameLength);
#if 0
  { int i;
    fprintf(stderr, "NsfCCreateMethod %s create <%s> oc %d ", ClassName(class), ObjStr(nameObj), objc);
    for(i = 0; i < objc; i++) {fprintf(stderr, " [%d]=%s,", i, ObjStr(objv[i]));}
    fprintf(stderr, "\n");
  }
#endif

  if (unlikely(RUNTIME_STATE(interp)->exitHandlerDestroyRound != NSF_EXITHANDLER_OFF)) {
    fprintf(stderr, "### Can't create instance %s of class %s during interp shutdown.\n",
            ObjStr(nameObj), ClassName_(class));
    /*
     * Don't fail if this happens during destroy.  It might be canceled.
     */
    return TCL_OK;
  }

  if (unlikely(NSValidObjectName(nameString, (size_t)nameLength) == 0)) {
    result = NsfPrintError(interp, "cannot allocate object - illegal name '%s'", nameString);
    goto create_method_exit;
  }

  /*fprintf(stderr, "NsfCCreateMethod specifiedName %s\n", nameString);*/
  if (!isAbsolutePath(nameString)) {
   /*
    * Fully-qualify the name.
    */
    parentNsPtr = CallingNameSpace(interp);
    tmpObj = NameInNamespaceObj(nameString, parentNsPtr);
    /*
     * If the name contains colons, parentNsPtr is not appropriate for
     * determining the parent.
     */
    if (strchr(nameString, ':')) {
      parentNsPtr = NULL;
    }
    nameString = ObjStr(tmpObj);
    /* fprintf(stderr, " **** fixed name is '%s'\n", nameString); */
    INCR_REF_COUNT(tmpObj);
    actualNameObj = tmpObj;
    autoNameCreate = NSF_FALSE;

  } else {
    parentNsPtr = NULL;
    actualNameObj = nameObj;
    /* fprintf(stderr, " **** used specified name is '%s'\n", nameString); */

    /*
     * Does the name contain the autoname prefix?  The autoname prefix is
     * absolute so it is sufficient to test here.
     */
    autoNameCreate = (strncmp(autonamePrefix, nameString, autonamePrefixLength) == 0);
  }

  /*
   * Is it necessary to call recreate, e.g. when the object exists already?
   */
  {
    Tcl_Command cmd = NSFindCommand(interp, nameString);
    if (cmd != NULL) {
      newObject = NsfGetObjectFromCmdPtr(cmd);
      if (newObject == NULL) {
        /*
         * The command exists but it is not an object.  Don't overwrite it
         * with an Nsf object.
         */
        result = NsfPrintError(interp, "refuse to overwrite cmd %s; delete/rename it before overwriting", nameString);
        goto create_method_exit;
      }
    }
  }

  /*fprintf(stderr, "+++ createspecifiedName '%s', nameString '%s', newObject=%p ismeta(%s) %d, ismeta(%s) %d\n",
          ObjStr(specifiedNameObj), nameString, newObject,
          ClassName(class), IsMetaClass(interp, class, NSF_TRUE),
          (newObject != NULL) ? ClassName(newObject->cl) : "NULL",
          (newObject != NULL) ? IsMetaClass(interp, newObject->cl, NSF_TRUE) : 0
          );*/

  /*
   * Provide protection against recreation of base classes.
   */
  if (unlikely(newObject != NULL && unlikely(IsBaseClass(newObject)))) {
    result = NsfPrintError(interp, "cannot recreate base class %s", ObjectName(newObject));
    goto create_method_exit;
  }

  /*
   * An object may not be recreated as a class, a class may not be recreated as
   * an object, and an object may not be recreated in a different object
   * system.  In these cases destroy the object and create a new one instead.
   */

  if ((newObject != NULL)
      && (IsMetaClass(interp, class, NSF_TRUE) == IsMetaClass(interp, newObject->cl, NSF_TRUE))
      && GetObjectSystem(newObject) == class->osPtr) {

    /*fprintf(stderr, "%%%% recreate, call recreate method ... %s, objc=%d oldOs %p != newOs %p EQ %d\n",
            ObjStr(actualNameObj), objc+1,
            GetObjectSystem(newObject), cl->osPtr,
            GetObjectSystem(newObject) != cl->osPtr
            );*/


    /*
     * Recreate the object, which also initializes it.
     */
    if (CallDirectly(interp, &class->object, NSF_c_recreate_idx, &methodObj)) {
      NSF_PROFILE_TIME_DATA;
      NSF_PROFILE_CALL(interp, &class->object, Nsf_SystemMethodOpts[NSF_c_recreate_idx]);
      result = RecreateObject(interp, class, newObject, objc, objv);
      NSF_PROFILE_EXIT(interp, &class->object, Nsf_SystemMethodOpts[NSF_c_recreate_idx]);

    } else {
      ALLOC_ON_STACK(Tcl_Obj*, objc+3, xov);

      xov[0] = NULL; /* just a placeholder for passing conventions in ObjectDispatch() */
      xov[1] = methodObj;
      xov[2] = actualNameObj;
      if (objc >= 1) {
        memcpy(xov+3, objv, sizeof(Tcl_Obj *) * (size_t)objc);
      }
      result = ObjectDispatch(class, interp, objc+3, xov, NSF_CM_IGNORE_PERMISSIONS|NSF_CSC_IMMEDIATE);

      FREE_ON_STACK(Tcl_Obj *, xov);
    }

    if (unlikely(result != TCL_OK)) {
      goto create_method_exit;
    }

    Tcl_SetObjResult(interp, newObject->cmdName);
    ObjTrace("RECREATE", newObject);

  } else {
    /*
     * "newObject" might exist here but is automatically destroyed by alloc.
     */

    if (CallDirectly(interp, &class->object, NSF_c_alloc_idx, &methodObj)) {
      NSF_PROFILE_TIME_DATA;
      NSF_PROFILE_CALL(interp, &class->object, Nsf_SystemMethodOpts[NSF_c_alloc_idx]);
      result = NsfCAllocMethod_(interp, class, actualNameObj, parentNsPtr);
      NSF_PROFILE_EXIT(interp, &class->object, Nsf_SystemMethodOpts[NSF_c_alloc_idx]);
    } else {
      result = CallMethod(class, interp, methodObj,
                          3, &actualNameObj, NSF_CSC_IMMEDIATE);
    }

    if (unlikely(result != TCL_OK)) {
      goto create_method_exit;
    }
    actualNameObj = Tcl_GetObjResult(interp);

    if (unlikely(GetObjectFromObj(interp, actualNameObj, &newObject) != TCL_OK)) {
      result = NsfPrintError(interp, "couldn't find result of alloc");
      goto create_method_exit;
    }

    ObjTrace("CREATE", newObject);

    if (autoNameCreate) {
      newObject->flags |= NSF_IS_AUTONAMED;
    }

    /*
     * Increment the refCount in case the object is destroyed during
     * initialization.
     */
    INCR_REF_COUNT(actualNameObj);
    result = DoObjInitialization(interp, newObject, objc, objv);
    DECR_REF_COUNT(actualNameObj);
  }
 create_method_exit:

  if (tmpObj != NULL) {
    DECR_REF_COUNT(tmpObj);
  }
  return result;
}

/*
classMethod dealloc NsfCDeallocMethod {
  {-argName "object" -required 1 -type tclobj}
}
*/

static int
NsfCDeallocMethod(Tcl_Interp *interp, NsfClass *UNUSED(class), Tcl_Obj *objectObj) {
  NsfObject *object;

  nonnull_assert(interp != NULL);

  if (GetObjectFromObj(interp, objectObj, &object) != TCL_OK) {
    return NsfPrintError(interp, "can't destroy object %s that does not exist",
                         ObjStr(objectObj));
  }

  return DoDealloc(interp, object);
}

/*
classMethod filterguard NsfCFilterGuardMethod {
  {-argName "filter" -required 1}
  {-argName "guard" -required 1 -type tclobj}
}
*/

static int
NsfCFilterGuardMethod(Tcl_Interp *interp, NsfClass *class,
                      const char *filter, Tcl_Obj *guardObj) {
  NsfClassOpt *opt;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(filter != NULL);
  nonnull_assert(guardObj != NULL);

  opt = class->opt;
  if (opt != NULL && opt->classFilters) {
    NsfCmdList *h = CmdListFindNameInList(interp, filter, opt->classFilters);

    if (h != NULL) {
      NsfClasses *subClasses = DependentSubClasses(class);

      if (h->clientData != NULL) {
        GuardDel(h);
      }
      GuardAdd(h, guardObj);

      if (subClasses != NULL) {
        FilterInvalidateObjOrders(interp, subClasses);
        NsfClassListFree(subClasses);
      }

      return TCL_OK;
    }
  }

  return NsfPrintError(interp, "filterguard: can't find filter %s on %s",
                       filter, ClassName_(class));
}

/*
classMethod getCachedParameters NsfCGetCachendParametersMethod {
}
*/
static int
NsfCGetCachendParametersMethod(Tcl_Interp *interp, NsfClass *class) {

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);

  if (likely(class->parsedParamPtr != NULL && class->parsedParamPtr->paramDefs != NULL)) {
    Tcl_Obj *listObj;

    listObj = ListParamDefs(interp, class->parsedParamPtr->paramDefs->paramsPtr,
                            NULL, NULL, NSF_PARAMS_PARAMETER);
    Tcl_SetObjResult(interp, listObj);
    DECR_REF_COUNT2("paramDefsObj", listObj);
  }
  return TCL_OK;
}

/*
classMethod mixinguard NsfCMixinGuardMethod {
  {-argName "mixin" -required 1 -type tclobj}
  {-argName "guard" -required 1 -type tclobj}
}
*/
static int
NsfCMixinGuardMethod(Tcl_Interp *interp, NsfClass *class, Tcl_Obj *mixinObj, Tcl_Obj *guardObj) {
  NsfClassOpt *opt;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(mixinObj != NULL);
  nonnull_assert(guardObj != NULL);

  opt = class->opt;
  if (opt != NULL && opt->classMixins != NULL) {
    const Tcl_Command mixinCmd = Tcl_GetCommandFromObj(interp, mixinObj);

    if (mixinCmd != NULL) {
     const NsfClass *mixinClass = NsfGetClassFromCmdPtr(mixinCmd);

      if (mixinClass != NULL) {
        NsfCmdList *h = CmdListFindCmdInList(mixinCmd, opt->classMixins);

        if (h != NULL) {
          NsfClasses *subClasses;

          if (h->clientData != NULL) {
            GuardDel((NsfCmdList *) h);
          }
          GuardAdd(h, guardObj);
          subClasses = DependentSubClasses(class);
          MixinInvalidateObjOrders(subClasses);
          NsfClassListFree(subClasses);
          return TCL_OK;
        }
      }
    }
  }

  return NsfPrintError(interp, "mixinguard: can't find mixin %s on %s",
                       ObjStr(mixinObj), ClassName_(class));
}

/*
classMethod new NsfCNewMethod {
  {-argName "-childof" -required 0 -type tclobj}
  {-argName "args" -required 0 -type args}
}
*/

static int
NsfCNewMethod(Tcl_Interp *interp, NsfClass *class, Tcl_Obj *childofObj,
              int trailingObjc, Tcl_Obj *const trailingObjv[]) {
  Tcl_Obj     *fullnameObj;
  Tcl_DString  dFullname, *dsPtr = &dFullname;
  int          result;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);

#if 0
  { int i;
    fprintf(stderr, "NsfCNewMethod %s withChildof %p oc %d ", ClassName(class), childofObj, trailingObjc);
    for(i = 0; i < trailingObjc; i++) {fprintf(stderr, " [%d]=%s,", i, ObjStr(trailingObjv[i]));}
    fprintf(stderr, "\n");
  }
#endif

  Tcl_DStringInit(dsPtr);
  if (childofObj != 0) {
    const char *parentName = ObjStr(childofObj);

    /*
     * If "parentName" is fully qualified, use it as the prefix.  Otherwise,
     * prepend the CallingNameSpace() to be compatible with the object name
     * completion.
     */
    if (*parentName == ':' && *(parentName + 1) == ':') {
      /*
       * Prepend parentName only if it is not "::"
       */
      if (*(parentName + 2) != '\0') {
        Tcl_DStringAppend(dsPtr, parentName, -1);
      }
    } else {
      Tcl_Obj    *tmpName = NameInNamespaceObj(parentName, CallingNameSpace(interp));
      const char *completedParentName;

      INCR_REF_COUNT(tmpName);
      completedParentName = ObjStr(tmpName);
      if (strcmp(completedParentName, "::")) {
        Tcl_DStringAppend(dsPtr, ObjStr(tmpName), -1);
      }
      DECR_REF_COUNT(tmpName);
    }
    Tcl_DStringAppend(dsPtr, "::__#", 5);
  } else {
    Tcl_DStringAppend(dsPtr, autonamePrefix, (int)autonamePrefixLength);
  }

  NewTclCommand(interp, dsPtr);

  fullnameObj = Tcl_NewStringObj(Tcl_DStringValue(dsPtr), Tcl_DStringLength(dsPtr));
  INCR_REF_COUNT(fullnameObj);

  {
    Tcl_Obj *methodObj;
    int      callDirectly;

    callDirectly = CallDirectly(interp, &class->object, NSF_c_create_idx, &methodObj);

    if (callDirectly != 0) {
      NSF_PROFILE_TIME_DATA;
      NSF_PROFILE_CALL(interp, &class->object, Nsf_SystemMethodOpts[NSF_c_create_idx]);
      result = NsfCCreateMethod(interp, class, fullnameObj, trailingObjc, trailingObjv);
      NSF_PROFILE_EXIT(interp, &class->object, Nsf_SystemMethodOpts[NSF_c_create_idx]);
    } else {
      ALLOC_ON_STACK(Tcl_Obj*, trailingObjc+3, ov);

      ov[0] = NULL; /* just a placeholder for passing conventions in ObjectDispatch() */
      ov[1] = methodObj;
      ov[2] = fullnameObj;
      if (trailingObjc >= 1) {
        memcpy(ov+3, trailingObjv, sizeof(Tcl_Obj *) * (size_t)trailingObjc);
      }
      result = ObjectDispatch(class, interp, trailingObjc+3, ov, NSF_CSC_IMMEDIATE);
      FREE_ON_STACK(Tcl_Obj *, ov);
    }
  }

  DECR_REF_COUNT(fullnameObj);
  Tcl_DStringFree(dsPtr);

  return result;
}

/*
classMethod recreate NsfCRecreateMethod {
  {-argName "objectName" -required 1 -type tclobj}
  {-argName "args" -type virtualclassargs}
}
*/
static int
RecreateObject(Tcl_Interp *interp, NsfClass *class, NsfObject *object,
               int objc, Tcl_Obj *const objv[]) {
  int result;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(objv != NULL);

  object->flags |= NSF_RECREATE;

  /*
   * First, clean up the data from the object.
   *
   * If the object is pending destruction mark it as undestroyed so that the
   * recreated object and isn't destroyed on a POP.
   */
  MarkUndestroyed(object);

  /*
   * Set the correct class for the object.
   */
  result = ChangeClass(interp, object, class);

  if (likely(result == TCL_OK)) {
    Tcl_Obj *methodObj;

    /*
     * Dispatch the cleanup method.
     */
    if (CallDirectly(interp, object, NSF_o_cleanup_idx, &methodObj)) {
      NSF_PROFILE_TIME_DATA;
      /*fprintf(stderr, "RECREATE calls cleanup directly for object %s\n", ObjectName(object));*/
      NSF_PROFILE_CALL(interp, object, Nsf_SystemMethodOpts[NSF_o_cleanup_idx]);
      result = NsfOCleanupMethod(interp, object);
      NSF_PROFILE_EXIT(interp, object, Nsf_SystemMethodOpts[NSF_o_cleanup_idx]);
    } else {
      /*NsfObjectSystem *osPtr = GetObjectSystem(object);
      fprintf(stderr, "RECREATE calls method cleanup for object %p %s OS %s\n",
              object, ObjectName(object), ObjectName(&osPtr->rootClass->object));*/
      result = CallMethod(object, interp, methodObj,
                          2, NULL, NSF_CM_IGNORE_PERMISSIONS|NSF_CSC_IMMEDIATE);
    }
  }

  /*
   * Second: Initialize the object as usual if cleanup was successful.
   */
  if (likely(result == TCL_OK)) {
    result = DoObjInitialization(interp, object, objc, objv);
    if (likely(result == TCL_OK)) {
      Tcl_SetObjResult(interp, object->cmdName);
    } else {
      /* fprintf(stderr, "recreate DoObjInitialization returned %d\n", result);*/
    }
  }
  return result;
}

static int
NsfCRecreateMethod(Tcl_Interp *interp, NsfClass *class, Tcl_Obj *objectNameObj,
                   int trailingObjc, Tcl_Obj *const trailingObjv[]) {
  NsfObject *object;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(objectNameObj != NULL);

  if (GetObjectFromObj(interp, objectNameObj, &object) != TCL_OK) {
    return NsfPrintError(interp, "can't recreate non existing object %s", ObjStr(objectNameObj));
  }
  return RecreateObject(interp, class, object, trailingObjc, trailingObjv);
}

/*
classMethod superclass NsfCSuperclassMethod {
  {-argName "superclasses" -required 0 -type tclobj}
}
*/
static int
NsfCSuperclassMethod(Tcl_Interp *interp, NsfClass *class, Tcl_Obj *superclassesObj) {

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);

  return NsfRelationSetCmd(interp, &class->object, RelationtypeSuperclassIdx, superclassesObj);
}

/***********************************************************************
 * End Class Methods
 ***********************************************************************/

static MethodtypeIdx_t
AggregatedMethodType(MethodtypeIdx_t methodType) {
  switch (methodType) {
  case MethodtypeNULL: NSF_FALL_THROUGH; /* fall through */
  case MethodtypeAllIdx:
    methodType = NSF_METHODTYPE_ALL;
    break;
  case MethodtypeScriptedIdx:
    /*methodType = NSF_METHODTYPE_SCRIPTED|NSF_METHODTYPE_ALIAS;*/
    methodType = NSF_METHODTYPE_SCRIPTED;
    break;
  case MethodtypeBuiltinIdx:
    methodType = NSF_METHODTYPE_BUILTIN|NSF_METHODTYPE_OBJECT;
    break;
  case MethodtypeForwarderIdx:
    methodType = NSF_METHODTYPE_FORWARDER;
    break;
  case MethodtypeAliasIdx:
    methodType = NSF_METHODTYPE_ALIAS;
    break;
  case MethodtypeSetterIdx:
    methodType = NSF_METHODTYPE_SETTER;
    break;
  case MethodtypeObjectIdx:
    methodType = NSF_METHODTYPE_OBJECT;
    break;
  case MethodtypeNsfprocIdx:
    methodType = NSF_METHODTYPE_NSFPROC;
    break;
  }

  return methodType;
}

/***********************************************************************
 * Begin Object Info Methods
 ***********************************************************************/
/*
objectInfoMethod baseclass NsfObjInfoBaseclassMethod {
}
*/

static int
NsfObjInfoBaseclassMethod(Tcl_Interp *interp, NsfObject *object) {
  NsfObjectSystem *osPtr;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  osPtr = GetObjectSystem(object);
  assert(osPtr != NULL);

  Tcl_SetObjResult(interp, osPtr->rootClass->object.cmdName);

  return TCL_OK;
}
/*
objectInfoMethod children NsfObjInfoChildrenMethod {
  {-argName "-type" -required 0 -nrargs 1 -type class}
  {-argName "pattern" -required 0}
}
*/
static int
NsfObjInfoChildrenMethod(Tcl_Interp *interp, NsfObject *object, NsfClass *typeClass, const char *pattern) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  return ListChildren(interp, object, pattern, NSF_FALSE, typeClass);
}

/*
objectInfoMethod class NsfObjInfoClassMethod {
}
*/
static int
NsfObjInfoClassMethod(Tcl_Interp *interp, NsfObject *object) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  Tcl_SetObjResult(interp, object->cl->object.cmdName);
  return TCL_OK;
}

/*
objectInfoMethod filterguard NsfObjInfoFilterguardMethod {
  {-argName "filter" -required 1}
}
*/
static int
NsfObjInfoFilterguardMethod(Tcl_Interp *interp, NsfObject *object, const char *filter) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(filter != NULL);

  return (object->opt != NULL) ? GuardList(interp, object->opt->objFilters, filter) : TCL_OK;
}

/*
objectInfoMethod filters NsfObjInfoFiltersMethod {
  {-argName "-guards" -nrargs 0 -type switch}
  {-argName "pattern"}
}
*/
static int
NsfObjInfoFiltersMethod(Tcl_Interp *interp, NsfObject *object, int withGuards,
                        const char *pattern) {
  NsfObjectOpt *opt;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  opt = object->opt;
  return (opt != NULL) ? FilterInfo(interp, opt->objFilters, pattern, (withGuards == 1), NSF_FALSE) : TCL_OK;
}

/*
objectInfoMethod forward NsfObjInfoForwardMethod {
  {-argName "-definition"}
  {-argName "pattern"}
}
*/
static int
NsfObjInfoForwardMethod(Tcl_Interp *interp, NsfObject *object, int withDefinition, const char *pattern) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  return (object->nsPtr != NULL) ?
    ListForward(interp, Tcl_Namespace_cmdTablePtr(object->nsPtr), pattern, withDefinition) :
    TCL_OK;
}

/*
objectInfoMethod hasmixin NsfObjInfoHasMixinMethod {
  {-argName "class" -required 1 -type class}
}
*/
static int
NsfObjInfoHasMixinMethod(Tcl_Interp *interp, NsfObject *object, NsfClass *class) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(class != NULL);

  Tcl_SetBooleanObj(Tcl_GetObjResult(interp), (int)(HasMixin(interp, object, class)));
  return TCL_OK;
}

/*
objectInfoMethod hasnamespace NsfObjInfoHasnamespaceMethod {
}
*/
static int
NsfObjInfoHasnamespaceMethod(Tcl_Interp *interp, NsfObject *object) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  Tcl_SetBooleanObj(Tcl_GetObjResult(interp), object->nsPtr != NULL);
  return TCL_OK;
}

/*
objectInfoMethod hastype NsfObjInfoHasTypeMethod {
  {-argName "class" -required 1 -type class}
}
*/
static int
NsfObjInfoHasTypeMethod(Tcl_Interp *interp, NsfObject *object, NsfClass *class) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(class != NULL);

  Tcl_SetBooleanObj(Tcl_GetObjResult(interp), (int)(IsSubType(object->cl, class)));
  return TCL_OK;
}

/*
objectInfoMethod lookupfilter NsfObjInfoLookupFilterMethod {
  {-argName "filter" -required 1}
}
*/
static int
NsfObjInfoLookupFilterMethod(Tcl_Interp *interp, NsfObject *object, const char *filter) {
  const char *filterName;
  NsfCmdList *cmdList;
  NsfClass *fcl;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(filter != NULL);

  /*
   * Search for filter on [self] and return either its fully-qualified name or
   * the empty string.
   */
  Tcl_ResetResult(interp);

  if ((object->flags & NSF_FILTER_ORDER_VALID) == 0u) {
    FilterComputeDefined(interp, object);
  }
  if ((object->flags & NSF_FILTER_ORDER_DEFINED) == 0u) {
    return TCL_OK;
  }
  for (cmdList = object->filterOrder; cmdList;  cmdList = cmdList->nextPtr) {
    filterName = Tcl_GetCommandName(interp, cmdList->cmdPtr);
    if (filterName[0] == filter[0] && !strcmp(filterName, filter)) {
      break;
    }
  }

  if (cmdList == NULL) {
    return TCL_OK;
  }
  fcl = cmdList->clorobj;
  Tcl_SetObjResult(interp, MethodHandleObj((NsfObject *)fcl, !NsfObjectIsClass(&fcl->object), filterName));
  return TCL_OK;
}


/*
objectInfoMethod lookupfilters NsfObjInfoLookupFiltersMethod {
  {-argName "-guards" -nrargs 0 -type switch}
  {-argName "pattern"}
}
*/
static int
NsfObjInfoLookupFiltersMethod(Tcl_Interp *interp, NsfObject *object, int withGuards, const char *pattern) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  if ((object->flags & NSF_FILTER_ORDER_VALID) == 0u) {
    FilterComputeDefined(interp, object);
  }
  return FilterInfo(interp, object->filterOrder, pattern, (withGuards == 1), NSF_TRUE);
}

/*
objectInfoMethod lookupmethod NsfObjInfoLookupMethodMethod {
  {-argName "name" -required 1 -type tclobj}
}
*/
static int
NsfObjInfoLookupMethodMethod(Tcl_Interp *interp, NsfObject *object, Tcl_Obj *nameObj) {
  NsfClass *classPtr = NULL;
  Tcl_Command cmd;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(nameObj != NULL);

  cmd = ObjectFindMethod(interp, object, nameObj, &classPtr);
  if (likely(cmd != NULL)) {
    NsfObject *pobj = (classPtr != NULL) ? &classPtr->object : object;
    int perObject = (classPtr == NULL);

    ListMethod(interp, pobj, pobj, ObjStr(nameObj), cmd,
               InfomethodsubcmdRegistrationhandleIdx,
               NULL, NULL, (perObject == 1));
  }
  return TCL_OK;
}


static int ListMethodKeysClassList(Tcl_Interp *interp, NsfClasses *classListPtr,
                        DefinitionsourceIdx_t withSource, const char *pattern,
                        MethodtypeIdx_t methodType, CallprotectionIdx_t withCallprotection,
                        bool withPath, Tcl_HashTable *dups,
                        NsfObject *object, bool withPer_object)
  nonnull(1) nonnull(8) nonnull(9);

static int
ListMethodKeysClassList(Tcl_Interp *interp, NsfClasses *classListPtr,
                        DefinitionsourceIdx_t withSource, const char *pattern,
                        MethodtypeIdx_t methodType, CallprotectionIdx_t withCallprotection,
                        bool withPath, Tcl_HashTable *dups,
                        NsfObject *object, bool withPer_object) {

  nonnull_assert(interp != NULL);
  nonnull_assert(dups != NULL);
  nonnull_assert(object != NULL);

  /*
   * Append method keys from inheritance order
   */
  for (; classListPtr != NULL; classListPtr = classListPtr->nextPtr) {
    Tcl_HashTable *cmdTablePtr = Tcl_Namespace_cmdTablePtr(classListPtr->cl->nsPtr);

    if (!MethodSourceMatches(withSource, classListPtr->cl, NULL)) {
      continue;
    }

    ListMethodKeys(interp, cmdTablePtr, NULL, pattern, methodType,
                   withCallprotection, withPath,
                   dups, object, withPer_object);
  }
  return TCL_OK;
}

/*
objectInfoMethod lookupmethods NsfObjInfoLookupMethodsMethod {
  {-argName "-callprotection" -type "all|public|protected|private" -default all}
  {-argName "-incontext" -nrargs 0}
  {-argName "-type" -typeName "methodtype" -type "all|scripted|builtin|alias|forwarder|object|setter|nsfproc"}
  {-argName "-nomixins" -nrargs 0}
  {-argName "-path" -nrargs 0}
  {-argName "-source" -type "all|application|system" -default all}
  {-argName "pattern" -required 0}
}
*/
static int
NsfObjInfoLookupMethodsMethod(Tcl_Interp *interp, NsfObject *object,
                              CallprotectionIdx_t withCallprotection,
                              int withIncontext,
                              MethodtypeIdx_t withType,
                              int withNomixins,
                              int withPath,
                              DefinitionsourceIdx_t withSource,
                              const char *pattern) {
  int             result;
  bool            withPer_object = NSF_TRUE;
  Tcl_HashTable   dupsTable, *dups = &dupsTable;
  MethodtypeIdx_t methodType = AggregatedMethodType(withType);

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  /*
   * TODO: This could be made faster for patterns without meta characters by
   * letting ListMethodKeys() signal when an entry was found.  Wait until the
   * decision is made about "info methods defined" vs. "info method search" vs.
   * "info defined" etc.
   */
  if (withCallprotection == CallprotectionNULL) {
    withCallprotection = CallprotectionPublicIdx;
  }
  if (withSource == DefinitionsourceNULL) {
    withSource = DefinitionsourceAllIdx;
  }

  Tcl_InitHashTable(dups, TCL_STRING_KEYS);
  if (object->nsPtr != NULL) {
    Tcl_HashTable *cmdTablePtr = Tcl_Namespace_cmdTablePtr(object->nsPtr);

    if (MethodSourceMatches(withSource, NULL, object)) {
      ListMethodKeys(interp, cmdTablePtr, NULL, pattern, methodType,
                     withCallprotection, (withPath == 1),
                     dups, object, withPer_object);
    }
  }

  if (withNomixins == 0) {
    if ((object->flags & NSF_MIXIN_ORDER_VALID) == 0u) {
      MixinComputeDefined(interp, object);
    }
    if ((object->flags & NSF_MIXIN_ORDER_DEFINED_AND_VALID) != 0u) {
      NsfCmdList *ml;

      for (ml = object->mixinOrder; ml; ml = ml->nextPtr) {
        int guardOk = TCL_OK;
        NsfClass *mixin = NsfGetClassFromCmdPtr(ml->cmdPtr);

        assert(mixin != NULL);
        if (withIncontext != 0) {
          if (!RUNTIME_STATE(interp)->guardCount && ml->clientData) {
            guardOk = GuardCall(object, interp, ml->clientData, NULL);
          }
        }
        if (mixin && guardOk == TCL_OK) {
          Tcl_HashTable *cmdTablePtr = Tcl_Namespace_cmdTablePtr(mixin->nsPtr);
          if (!MethodSourceMatches(withSource, mixin, NULL)) {
            continue;
          }
          ListMethodKeys(interp, cmdTablePtr, NULL, pattern, methodType,
                         withCallprotection, withPath,
                         dups, object, withPer_object);
        }
      }
    }
  }

  result = ListMethodKeysClassList(interp, PrecedenceOrder(object->cl),
                                   withSource, pattern,
                                   methodType, withCallprotection,
                                   (withPath == 1), dups, object, withPer_object);

  Tcl_DeleteHashTable(dups);
  return result;
}

/*
objectInfoMethod lookupmixins NsfObjInfoLookupMixinsMethod {
  {-argName "-guards" -nrargs 0 -type switch}
  {-argName "pattern" -type objpattern}
}
*/
static int
NsfObjInfoLookupMixinsMethod(Tcl_Interp *interp, NsfObject *object, int withGuards,
                             const char *patternString, NsfObject *patternObject) {
  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  if ((object->flags & NSF_MIXIN_ORDER_VALID) == 0u) {
    MixinComputeDefined(interp, object);
  }
  return MixinInfo(interp, object->mixinOrder, patternString, (withGuards == 1), patternObject);
}


/*
objectInfoMethod lookupslots NsfObjInfoLookupSlotsMethod {
  {-argName "-source" -nrargs 1 -type "all|application|system" -default all}
  {-argName "-type" -required 0 -nrargs 1 -type class}
  {-argName "pattern" -required 0}
}
*/
static int
NsfObjInfoLookupSlotsMethod(Tcl_Interp *interp, NsfObject *object,
                            DefinitionsourceIdx_t withSource,
                            NsfClass *typeClass,
                            const char *pattern) {
  Tcl_Obj *listObj = Tcl_NewListObj(0, NULL);
  NsfClasses *precedenceList, *clPtr;
  Tcl_HashTable slotTable;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  precedenceList = ComputePrecedenceList(interp, object, NULL /* pattern*/,
                                         NSF_TRUE, NSF_TRUE);
  assert(precedenceList != NULL);

  if (withSource == 0) {
    withSource = 1;
  }

  Tcl_InitHashTable(&slotTable, TCL_STRING_KEYS);
  MEM_COUNT_ALLOC("Tcl_InitHashTable", &slotTable);

  /*
   * First add the slot objects provided by the object.
   */
  if (MethodSourceMatches(withSource, NULL, object)) {
    AddSlotObjects(interp, object, "::per-object-slot", &slotTable,
                   typeClass, pattern, listObj);
  }

  /*
   * Then add the slot object provided by the class.
   */
  for (clPtr = precedenceList; likely(clPtr != NULL); clPtr = clPtr->nextPtr) {
    if (MethodSourceMatches(withSource, clPtr->cl, NULL)) {
      AddSlotObjects(interp, &clPtr->cl->object, "::slot", &slotTable,
                     typeClass, pattern, listObj);
    }
  }

  Tcl_DeleteHashTable(&slotTable);
  MEM_COUNT_FREE("Tcl_InitHashTable", &slotTable);

  NsfClassListFree(precedenceList);
  Tcl_SetObjResult(interp, listObj);

  return TCL_OK;
}

/*
objectInfoMethod method NsfObjInfoMethodMethod {
  {-argName "infomethodsubcmd" -type "args|body|definition|exists|registrationhandle|definitionhandle|origin|parameter|syntax|type|precondition|postcondition|submethods"}
  {-argName "name" -required 1 -type tclobj}
}
*/
static int
NsfObjInfoMethodMethod(Tcl_Interp *interp, NsfObject *object,
                       InfomethodsubcmdIdx_t subcmd, Tcl_Obj *nameObj) {
  return ListMethodResolve(interp, subcmd, NULL, NULL, object->nsPtr, object, nameObj, NSF_FALSE);
}

/*
objectInfoMethod methods NsfObjInfoMethodsMethod {
  {-argName "-callprotection" -type "all|public|protected|private" -default all}
  {-argName "-type" -nrargs 1 -typeName "methodtype" -type "all|scripted|builtin|alias|forwarder|object|setter"}
  {-argName "-path" -nrargs 0}
  {-argName "pattern"}
}
*/
static int
NsfObjInfoMethodsMethod(Tcl_Interp *interp, NsfObject *object,
                        CallprotectionIdx_t withCallprotection,
                        MethodtypeIdx_t withType,
                        int withPath,
                        const char *pattern) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  return ListDefinedMethods(interp, object, pattern, 1 /* per-object */,
                            AggregatedMethodType(withType), withCallprotection,
                            withPath);
}

/*
objectInfoMethod mixins NsfObjInfoMixinsMethod {
  {-argName "-guards" -nrargs 0 -type switch}
  {-argName "pattern" -type objpattern}
}
*/
static int
NsfObjInfoMixinsMethod(Tcl_Interp *interp, NsfObject *object, int withGuards,
                       const char *patternString, NsfObject *patternObject) {
  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  return (object->opt != NULL) ?
    MixinInfo(interp, object->opt->objMixins, patternString, (withGuards == 1), patternObject) :
    TCL_OK;
}

/*
objectInfoMethod mixinguard NsfObjInfoMixinguardMethod {
  {-argName "mixin"  -required 1}
}
*/
static int
NsfObjInfoMixinguardMethod(Tcl_Interp *interp, NsfObject *object, const char *mixin) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);
  nonnull_assert(mixin != NULL);

  return (object->opt != NULL) ? GuardList(interp, object->opt->objMixins, mixin) : TCL_OK;
}

/*
objectInfoMethod name NsfObjInfoNameMethod {
}
*/
static int
NsfObjInfoNameMethod(Tcl_Interp *interp, NsfObject *object) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  Tcl_SetObjResult(interp,  Tcl_NewStringObj(Tcl_GetCommandName(interp, object->id), -1));
  return TCL_OK;
}

/*
objectInfoMethod parent NsfObjInfoParentMethod {
}
*/
static int
NsfObjInfoParentMethod(Tcl_Interp *interp, NsfObject *object) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  if (object->id != NULL) {
    Tcl_Namespace *nsPtr = Tcl_Command_nsPtr(object->id);
    Tcl_SetObjResult(interp, Tcl_NewStringObj((nsPtr != NULL) ? nsPtr->fullName : "", -1));
  }
  return TCL_OK;
}

/*
objectInfoMethod precedence NsfObjInfoPrecedenceMethod {
  {-argName "-intrinsic"}
  {-argName "pattern" -required 0}
}
*/
static int
NsfObjInfoPrecedenceMethod(Tcl_Interp *interp, NsfObject *object,
                           int withIntrinsic, const char *pattern) {
  NsfClasses *precedenceList, *pl;
  Tcl_Obj    *resultObj = Tcl_NewObj();

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  precedenceList = ComputePrecedenceList(interp, object, pattern,
                                         (withIntrinsic == 0), NSF_TRUE);
  for (pl = precedenceList; pl != NULL; pl = pl->nextPtr) {
    assert(pl->cl != NULL);
    Tcl_ListObjAppendElement(interp, resultObj, pl->cl->object.cmdName);
  }
  if (precedenceList != NULL) {
    NsfClassListFree(precedenceList);
  }

  Tcl_SetObjResult(interp, resultObj);
  return TCL_OK;
}

/*
objectInfoMethod slotobjects NsfObjInfoSlotobjectsMethod {
  {-argName "-type" -required 0 -nrargs 1 -type class}
  {-argName "pattern" -required 0}
}
*/
static int
NsfObjInfoSlotobjectsMethod(Tcl_Interp *interp, NsfObject *object,
                      NsfClass *typeClass, const char *pattern) {
  Tcl_Obj *listObj = Tcl_NewListObj(0, NULL);

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  AddSlotObjects(interp, object, "::per-object-slot", NULL,
                 typeClass, pattern, listObj);

  Tcl_SetObjResult(interp, listObj);
  return TCL_OK;
}


/*
objectInfoMethod vars NsfObjInfoVarsMethod {
  {-argName "pattern" -required 0}
}
*/
static int
NsfObjInfoVarsMethod(Tcl_Interp *interp, NsfObject *object, const char *pattern) {
  Tcl_Obj         *okList;
  TclVarHashTable *varTablePtr;

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  okList = Tcl_NewListObj(0, NULL);

  varTablePtr = (object->nsPtr != NULL) ?
    Tcl_Namespace_varTablePtr(object->nsPtr) :
    object->varTablePtr;

  /*
   * Both object->nsPtr and object->varTablePtr might be NULL.
   */
  if (likely(varTablePtr != NULL)) {
    Tcl_Obj  *varList, *element;
    int       i, length;

    ListVarKeys(interp, TclVarHashTablePtr(varTablePtr), pattern);
    varList = Tcl_GetObjResult(interp);

    Tcl_ListObjLength(interp, varList, &length);
    for (i = 0; i < length; i++) {
      Tcl_ListObjIndex(interp, varList, i, &element);
      if (VarExists(interp, object, ObjStr(element), NULL, NSF_VAR_REQUIRE_DEFINED)) {
        Tcl_ListObjAppendElement(interp, okList, element);
      } else {
        /*fprintf(stderr, "must ignore '%s' %d\n", ObjStr(element), i);*/
        /*Tcl_ListObjReplace(interp, varList, i, 1, 0, NULL);*/
      }
    }
  }

  Tcl_SetObjResult(interp, okList);
  return TCL_OK;
}
/***********************************************************************
 * End Object Info Methods
 ***********************************************************************/

/***********************************************************************
 * Begin Class Info methods
 ***********************************************************************/

/*
classInfoMethod filterguard NsfClassInfoFilterguardMethod {
  {-argName "filter" -required 1}
  }
*/
static int
NsfClassInfoFilterguardMethod(Tcl_Interp *interp, NsfClass *class, const char *filter) {

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(filter != NULL);

  return (class->opt != NULL) ? GuardList(interp, class->opt->classFilters, filter) : TCL_OK;
}

/*
classInfoMethod filters NsfClassInfoFiltersMethod {
  {-argName "-guards" -nrargs 0 -type switch}
  {-argName "pattern"}
}
*/
static int
NsfClassInfoFiltersMethod(Tcl_Interp *interp, NsfClass *class,
                          int withGuards, const char *pattern) {

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);

  return (class->opt != NULL) ?
    FilterInfo(interp, class->opt->classFilters, pattern, (withGuards == 1), NSF_FALSE) : TCL_OK;
}

/*
classInfoMethod forward NsfClassInfoForwardMethod {
  {-argName "-definition"}
  {-argName "pattern"}
}
*/
static int
NsfClassInfoForwardMethod(Tcl_Interp *interp, NsfClass *class,
                          int withDefinition, const char *pattern) {

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);

  return ListForward(interp, Tcl_Namespace_cmdTablePtr(class->nsPtr), pattern, withDefinition);
}

/*
classInfoMethod heritage NsfClassInfoHeritageMethod {
  {-argName "pattern"}
}
*/
static int
NsfClassInfoHeritageMethod(Tcl_Interp *interp, NsfClass *class, const char *pattern) {
  NsfClasses *pl, *intrinsic, *checkList = NULL, *mixinClasses = NULL;
  Tcl_Obj *resultObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);

  resultObj = Tcl_NewObj();
  intrinsic = PrecedenceOrder(class);

  NsfClassListAddPerClassMixins(interp, class, &mixinClasses, &checkList);
  for (pl = mixinClasses; pl != NULL; pl = pl->nextPtr) {
    if (NsfClassListFind(pl->nextPtr, pl->cl) == NULL &&
        NsfClassListFind(intrinsic, pl->cl) == NULL) {
      AppendMatchingElement(interp, resultObj, pl->cl->object.cmdName, pattern);
    }
  }

  if (intrinsic != NULL) {
    for (pl = intrinsic->nextPtr; pl != NULL; pl = pl->nextPtr) {
      AppendMatchingElement(interp, resultObj, pl->cl->object.cmdName, pattern);
    }
  }

  if (mixinClasses != NULL) {
    NsfClassListFree(mixinClasses);
  }
  if (checkList != NULL) {
    NsfClassListFree(checkList);
  }

  Tcl_SetObjResult(interp, resultObj);
  return TCL_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * InstancesFromClassList --
 *
 *      Returns a list of instances of the classes in the given list.
 *
 * Results:
 *      See description.
 *
 * Side effects:
 *      See description.
 *
 *----------------------------------------------------------------------
 */

static Tcl_Obj *InstancesFromClassList(
    Tcl_Interp *interp, NsfClasses *subClasses,
    const char *pattern, NsfObject *matchObject
) nonnull(1) nonnull(2) returns_nonnull;

static Tcl_Obj *
InstancesFromClassList(
    Tcl_Interp *interp, NsfClasses *subClasses,
    const char *pattern, NsfObject *matchObject
) {
  Tcl_Obj *resultObj = Tcl_NewObj();

  nonnull_assert(interp != NULL);
  nonnull_assert(subClasses != NULL);

  do {
    Tcl_HashTable *tablePtr = &subClasses->cl->instances;
    const Tcl_HashEntry *hPtr;
    Tcl_HashSearch search;

    for (hPtr = Tcl_FirstHashEntry(tablePtr, &search);
         hPtr != NULL;
         hPtr = Tcl_NextHashEntry(&search)) {
      NsfObject *inst = (NsfObject *) Tcl_GetHashKey(tablePtr, hPtr);

      if (matchObject != NULL && inst == matchObject) {
        Tcl_SetStringObj(resultObj, ObjStr(matchObject->cmdName), -1);
        return resultObj;
      }
      AppendMatchingElement(interp, resultObj, inst->cmdName, pattern);
    }
    subClasses = subClasses->nextPtr;
  } while (subClasses != NULL);

  return resultObj;
}

/*
classInfoMethod instances NsfClassInfoInstancesMethod {
  {-argName "-closure" -nrargs 0}
  {-argName "pattern" -type objpattern}
}
*/
static int
NsfClassInfoInstancesMethod(
    Tcl_Interp *interp, NsfClass *class,
    int withClosure, const char *patternString,
    NsfObject *patternObject
) {
  NsfClasses clElement, *subClasses;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);

  if (withClosure != 0) {
    subClasses = TransitiveSubClasses(class);
  } else {
    subClasses = &clElement;
    clElement.cl = class;
    clElement.nextPtr = NULL;
  }

  Tcl_SetObjResult(interp, InstancesFromClassList(interp, subClasses, patternString, patternObject));

  if (withClosure != 0) {
    NsfClassListFree(subClasses);
  }

  return TCL_OK;
}

/*
classInfoMethod method NsfClassInfoMethodMethod {
  {-argName "infomethodsubcmd" -type "args|body|definition|exists|registrationhandle|definitionhandle|origin|parameter|syntax|type|precondition|postcondition|submethods|returns"}
  {-argName "name" -required 1 -type tclobj}
}
*/
static int
NsfClassInfoMethodMethod(
    Tcl_Interp *interp, NsfClass *class,
    InfomethodsubcmdIdx_t subcmd, Tcl_Obj *nameObj
) {
  return ListMethodResolve(interp, subcmd, NULL, NULL, class->nsPtr, &class->object, nameObj, NSF_TRUE);
}

/*
classInfoMethod methods NsfClassInfoMethodsMethod {
  {-argName "-callprotection" -type "all|public|protected|private" -default all}
  {-argName "-closure" -nrargs 0}
  {-argName "-type" -typeName "methodtype" -nrargs 1 -type "all|scripted|builtin|alias|forwarder|object|setter"}
  {-argName "-path" -nrargs 0}
  {-argName "-source" -nrargs 1 -type "all|application|system"}
  {-argName "pattern"}
}
*/
static int
NsfClassInfoMethodsMethod(
    Tcl_Interp *interp, NsfClass *class,
    CallprotectionIdx_t withCallprotection,
    int withClosure,
    MethodtypeIdx_t withType,
    int withPath,
    DefinitionsourceIdx_t withSource,
    const char *pattern
) {
  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);

  if (withClosure != 0) {
    NsfClasses *checkList = NULL, *mixinClasses = NULL;
    Tcl_HashTable dupsTable, *dups = &dupsTable;
    int result;

#if 0
    if (withCallprotection == CallprotectionNULL) {
      withCallprotection = CallprotectionPublicIdx;
    }
#endif
    if (withSource == DefinitionsourceNULL) {
      withSource = DefinitionsourceAllIdx;
    }

    Tcl_InitHashTable(dups, TCL_STRING_KEYS);
    /*
     * Guards are ignored.
     */
    NsfClassListAddPerClassMixins(interp, class, &mixinClasses, &checkList);
    (void) ListMethodKeysClassList(interp, mixinClasses,
                                   withSource, pattern,
                                   AggregatedMethodType(withType), withCallprotection,
                                   withPath, dups, &class->object, NSF_FALSE);
    if (checkList != NULL) {
      NsfClassListFree(checkList);
    }
    if (mixinClasses != NULL) {
      NsfClassListFree(mixinClasses);
    }

    result = ListMethodKeysClassList(interp, PrecedenceOrder(class),
                                     withSource, pattern,
                                     AggregatedMethodType(withType), withCallprotection,
                                     withPath, dups, &class->object, NSF_FALSE);

    Tcl_DeleteHashTable(dups);
    return result;
  } else {
    if (withSource != 0) {
      return NsfPrintError(interp, "-source cannot be used without -closure\n");
    }
    return ListDefinedMethods(interp, &class->object, pattern, 0 /* per-object */,
                              AggregatedMethodType(withType), withCallprotection,
                              withPath);
  }
}

/*
classInfoMethod mixins NsfClassInfoMixinsMethod {
  {-argName "-closure" -nrargs 0 -type switch}
  {-argName "-guards" -nrargs 0 -type switch}
  {-argName "-heritage" -nrargs 0 -type switch}
  {-argName "pattern" -type objpattern}
}
*/
static int
NsfClassInfoMixinsMethod(
    Tcl_Interp *interp, NsfClass *class,
    int withClosure, int withGuards, int withHeritage,
    const char *patternString, NsfObject *patternObject
) {
  NsfClassOpt *opt;
  Tcl_Obj *resultObj;
  int result = TCL_OK;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);

  opt = class->opt;
  Tcl_ResetResult(interp);
  resultObj = Tcl_GetObjResult(interp);

  if (withHeritage != 0) {
    NsfClasses *checkList = NULL, *mixinClasses = NULL, *clPtr;

    if (withGuards != 0) {
      return NsfPrintError(interp, "-guards cannot be used together with -heritage\n");
    }

    NsfClassListAddPerClassMixins(interp, class, &mixinClasses, &checkList);
    for (clPtr = mixinClasses; clPtr != NULL; clPtr = clPtr->nextPtr) {
      if (NsfClassListFind(clPtr->nextPtr, clPtr->cl)) {
        continue;
      }
      AppendMatchingElement(interp, resultObj, clPtr->cl->object.cmdName, patternString);
    }

    if (checkList != NULL) {
      NsfClassListFree(checkList);
    }
    if (mixinClasses != NULL) {
      NsfClassListFree(mixinClasses);
    }

  } else if (withClosure != 0) {
    Tcl_HashTable objTable, *commandTable = &objTable;
    bool          done;

    MEM_COUNT_ALLOC("Tcl_InitHashTable", commandTable);
    Tcl_InitHashTable(commandTable, TCL_ONE_WORD_KEYS);
    done = GetAllClassMixins(interp, commandTable, resultObj,
                             class, (withGuards == 1),
                             patternString, patternObject);
    if (patternObject != NULL && done && !withGuards) {
      Tcl_SetObjResult(interp, patternObject->cmdName);
    }
    Tcl_DeleteHashTable(commandTable);
    MEM_COUNT_FREE("Tcl_InitHashTable", commandTable);

  } else {
    result = (opt != NULL) ?
      MixinInfo(interp, opt->classMixins, patternString, (withGuards == 1), patternObject) : TCL_OK;
  }

  return result;
}

/*
classInfoMethod mixinguard NsfClassInfoMixinguardMethod {
  {-argName "mixin"  -required 1}
}
*/
static int
NsfClassInfoMixinguardMethod(Tcl_Interp *interp, NsfClass *class, const char *mixin) {

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);
  nonnull_assert(mixin != NULL);

  return (class->opt != NULL) ? GuardList(interp, class->opt->classMixins, mixin) : TCL_OK;
}

/*
classInfoMethod mixinof NsfClassInfoMixinOfMethod {
  {-argName "-closure" -nrargs 0}
  {-argName "-scope" -required 0 -nrargs 1 -type "all|class|object"}
  {-argName "pattern" -type objpattern}
}
*/
static int
NsfClassInfoMixinOfMethod(
    Tcl_Interp *interp, NsfClass *class,
    int withClosure,
    MixinscopeIdx_t withScope,
    const char *patternString,
    NsfObject *patternObject
) {
  NsfClassOpt *opt;
  bool         perClass, perObject, done = NSF_FALSE;
  Tcl_Obj     *resultObj;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);

  opt = class->opt;
  Tcl_ResetResult(interp);
  resultObj = Tcl_GetObjResult(interp);

  if (withScope == MixinscopeNULL || withScope == MixinscopeAllIdx) {
    perClass  = NSF_TRUE;
    perObject = NSF_TRUE;
  } else if (withScope == MixinscopeClassIdx) {
    perClass  = NSF_TRUE;
    perObject = NSF_FALSE;
  } else {
    perClass  = NSF_FALSE;
    perObject = NSF_TRUE;
  }

  if (opt != NULL && !withClosure) {
    if (perClass && opt->isClassMixinOf != NULL) {
      done = AppendMatchingElementsFromCmdList(interp, opt->isClassMixinOf, resultObj,
                                             patternString, patternObject);
      if (done && (patternObject != NULL)) {
        goto finished;
      }
    }
    if (perObject && opt->isObjectMixinOf) {
      done = AppendMatchingElementsFromCmdList(interp, opt->isObjectMixinOf, resultObj,
                                               patternString, patternObject);
    }
  } else if (withClosure != 0) {
    Tcl_HashTable objTable, *commandTable = &objTable;

    MEM_COUNT_ALLOC("Tcl_InitHashTable", commandTable);
    Tcl_InitHashTable(commandTable, TCL_ONE_WORD_KEYS);
    if (perClass) {
      done = GetAllClassMixinsOf(interp, commandTable, resultObj,
                                 class, NSF_FALSE, NSF_TRUE, patternString, patternObject);
      if (done && (patternObject != NULL)) {
        goto finished;
      }
    }
    if (perObject) {
      done = GetAllObjectMixinsOf(interp, commandTable, resultObj,
                                  class, NSF_FALSE, NSF_TRUE, patternString, patternObject);
    }
    Tcl_DeleteHashTable(commandTable);
    MEM_COUNT_FREE("Tcl_InitHashTable", commandTable);
  }

 finished:
  if (patternObject != NULL) {
    Tcl_SetObjResult(interp, done ? patternObject->cmdName : NsfGlobalObjs[NSF_EMPTY]);
  } else {
    Tcl_SetObjResult(interp, resultObj);
  }
  return TCL_OK;
}

/*
classInfoMethod slots NsfClassInfoSlotobjectsMethod {
  {-argName "-closure" -nrargs 0}
  {-argName "-source" -nrargs 1 -type "all|application|system"}
  {-argName "-type" -required 0 -nrargs 1 -type class}
  {-argName "pattern" -required 0}
}
*/
static int
NsfClassInfoSlotobjectsMethod(Tcl_Interp *interp,
                              NsfClass *class,
                              int withClosure,
                              DefinitionsourceIdx_t withSource,
                              NsfClass *typeClass,
                              const char *pattern) {
  NsfClasses    *clPtr, *intrinsicClasses, *precedenceList = NULL;
  Tcl_Obj       *listObj = Tcl_NewListObj(0, NULL);
  Tcl_HashTable  slotTable;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);

  Tcl_ResetResult(interp);
  intrinsicClasses = PrecedenceOrder(class);

  if (withClosure != 0) {
    NsfClasses *checkList = NULL, *mixinClasses = NULL;
    /*
     * Compute the closure: first the transitive mixin-classes...
     */
    NsfClassListAddPerClassMixins(interp, class, &mixinClasses, &checkList);
    for (clPtr = mixinClasses; clPtr != NULL; clPtr = clPtr->nextPtr) {
      if (NsfClassListFind(clPtr->nextPtr, clPtr->cl) == NULL &&
          NsfClassListFind(intrinsicClasses, clPtr->cl) == NULL) {
        NsfClassListAdd(&precedenceList, clPtr->cl, NULL);
      }
    }
    /*
     * ... followed by the intrinsic classes.
     */
    NsfClassListAdd(&precedenceList, class, NULL);
    for (clPtr = intrinsicClasses->nextPtr; clPtr != NULL; clPtr = clPtr->nextPtr) {
      NsfClassListAdd(&precedenceList, clPtr->cl, NULL);
    }
    if (checkList != NULL) {
      NsfClassListFree(checkList);
    }
    if (mixinClasses != NULL) {
      NsfClassListFree(mixinClasses);
    }

  } else {
    NsfClassListAdd(&precedenceList, class, NULL);
  }
  /* NsfClassListPrint("precedence", precedenceList); */
  if (withSource == 0) {
    withSource = 1;
  }

  /*
   * Use a hash table to eliminate potential duplicates.
   */
  Tcl_InitHashTable(&slotTable, TCL_STRING_KEYS);
  MEM_COUNT_ALLOC("Tcl_InitHashTable", &slotTable);

  for (clPtr = precedenceList; clPtr != NULL; clPtr = clPtr->nextPtr) {
    if (MethodSourceMatches(withSource, clPtr->cl, NULL)) {
      AddSlotObjects(interp, &clPtr->cl->object, "::slot", &slotTable,
                     typeClass, pattern, listObj);
    }
  }

  Tcl_DeleteHashTable(&slotTable);
  MEM_COUNT_FREE("Tcl_InitHashTable", &slotTable);

  if (precedenceList != NULL) {
    NsfClassListFree(precedenceList);
  }
  Tcl_SetObjResult(interp, listObj);

  return TCL_OK;
}


/*
classInfoMethod subclass NsfClassInfoSubclassMethod {
  {-argName "-closure" -nrargs 0 -type switch}
  {-argName "-dependent" -nrargs 0 -type switch}
  {-argName "pattern" -type objpattern}
}
*/
static int
NsfClassInfoSubclassMethod(Tcl_Interp *interp, NsfClass *class,
                           int withClosure, int withDependent,
                           const char *patternString, NsfObject *patternObject) {
  bool found = NSF_FALSE;

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);

  if (withClosure && withDependent) {
    return NsfPrintError(interp, "only -closure or -dependent can be specified, not both");
  }

  if (withClosure || withDependent) {
    NsfClasses *subClasses = (withClosure != 0) ? TransitiveSubClasses(class) : DependentSubClasses(class);

    if (subClasses != NULL) {
      found = AppendMatchingElementsFromClasses(interp, subClasses, patternString, patternObject);
      NsfClassListFree(subClasses);
    }
  } else if (class->sub != NULL) {
    found = AppendMatchingElementsFromClasses(interp, class->sub, patternString, patternObject);
  }

  if (patternObject != NULL) {
    Tcl_SetObjResult(interp, found ? patternObject->cmdName : NsfGlobalObjs[NSF_EMPTY]);
  }

  return TCL_OK;
}

/*
classInfoMethod superclass NsfClassInfoSuperclassMethod {
  {-argName "-closure" -nrargs 0}
  {-argName "pattern" -type tclobj}
}
*/
static int
NsfClassInfoSuperclassMethod(Tcl_Interp *interp, NsfClass *class, int withClosure, Tcl_Obj *patternObj) {

  nonnull_assert(interp != NULL);
  nonnull_assert(class != NULL);

  return ListSuperClasses(interp, class, patternObj, (withClosure == 1));
}

/***********************************************************************
 * End Class Info methods
 ***********************************************************************/

/*
 * Initialization and Exit handlers.
 */

#ifdef DO_FULL_CLEANUP
/*
 * Delete global variables and procs.
 */
static void DeleteProcsAndVars(
    Tcl_Interp *interp, Tcl_Namespace *nsPtr, bool withKeepvars
) nonnull(1) nonnull(2);

static void
DeleteProcsAndVars(
    Tcl_Interp *interp, Tcl_Namespace *nsPtr, bool withKeepvars
) {
  Tcl_HashTable *varTablePtr, *cmdTablePtr, *childTablePtr;
  Tcl_HashSearch search;
  Tcl_Command cmd;
  register Tcl_HashEntry *entryPtr;

  nonnull_assert(interp != NULL);
  nonnull_assert(nsPtr != NULL);

  /* fprintf(stderr, "DeleteProcsAndVars in %s\n", nsPtr->fullName); */

  varTablePtr = (Tcl_HashTable *)Tcl_Namespace_varTablePtr(nsPtr);
  cmdTablePtr = Tcl_Namespace_cmdTablePtr(nsPtr);
  childTablePtr = Tcl_Namespace_childTablePtr(nsPtr);

  /*
   * Deleting the procs and vars in the child namespaces probably isn't
   * necessary, but do it anyway.
   */
  for (entryPtr = Tcl_FirstHashEntry(childTablePtr, &search);
       entryPtr != NULL;
       entryPtr = Tcl_NextHashEntry(&search)) {
    Tcl_Namespace *childNsPtr = (Tcl_Namespace *) Tcl_GetHashValue(entryPtr);
    DeleteProcsAndVars(interp, childNsPtr, withKeepvars);
  }

  if (!withKeepvars) {
    for (entryPtr = Tcl_FirstHashEntry(varTablePtr, &search);
         entryPtr != NULL;
         entryPtr = Tcl_NextHashEntry(&search)) {
      Tcl_Obj *nameObj;
      Var *varPtr;

      GetVarAndNameFromHash(entryPtr, &varPtr, &nameObj);
      if (!TclIsVarUndefined(varPtr) || TclIsVarNamespaceVar(varPtr)) {
        /* fprintf(stderr, "unsetting var %s\n", ObjStr(nameObj));*/
        Tcl_UnsetVar2(interp, ObjStr(nameObj), (char *)NULL, TCL_GLOBAL_ONLY);
      }
    }
  }

  for (entryPtr = Tcl_FirstHashEntry(cmdTablePtr, &search);
       entryPtr != NULL;
       entryPtr = Tcl_NextHashEntry(&search)) {
    cmd = (Tcl_Command)Tcl_GetHashValue(entryPtr);

    if (Tcl_Command_objProc(cmd) == RUNTIME_STATE(interp)->objInterpProc) {
      /*fprintf(stderr, "cmdname = %s cmd %p proc %p objProc %p %d\n",
        Tcl_GetHashKey(cmdTablePtr, entryPtr), cmd, Tcl_Command_proc(cmd), Tcl_Command_objProc(cmd),
        Tcl_Command_proc(cmd)==RUNTIME_STATE(interp)->objInterpProc);*/

      Tcl_DeleteCommandFromToken(interp, cmd);
    }
  }
}
#endif

/*
 *----------------------------------------------------------------------
 *
 * FinalObjectDeletion --
 *
 *      Should be called when an object is finally deleted, which typically
 *      happens during the final cleanup.  Among other things, tests the
 *      activation count of the object.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Deletes the object.
 *
 *----------------------------------------------------------------------
 */
static void
FinalObjectDeletion(
    Tcl_Interp *interp, NsfObject *object
) {

  nonnull_assert(interp != NULL);
  nonnull_assert(object != NULL);

  /*
   * If a call to exit happens from a higher stack frame, the object refCount
   * might not be decremented correctly. If this is the round for physical
   * destruction, set the counter to an appropriate value to ensure deletion.
   */
#if defined(NSF_DEVELOPMENT_TEST)
  if (unlikely(object->refCount != 1)) {
    if (object->refCount > 1) {
      NsfLog(interp, NSF_LOG_WARN,  "RefCount for obj %p %d (name %s) > 1",
             (void *)object, object->refCount, ObjectName_(object));
    } else {
      NsfLog(interp, NSF_LOG_WARN,  "Refcount for obj %p %d > 1",
             (void *)object, object->refCount);
    }
    /*object->refCount = 1;*/
  }
#endif

#if !defined(NDEBUG)
  if (RUNTIME_STATE(interp)->exitHandlerDestroyRound != NSF_EXITHANDLER_ON_PHYSICAL_DESTROY) {
    assert(object->activationCount == 0);
  } else if (object->activationCount != 0) {
    NsfLog(interp, NSF_LOG_WARN, "FinalObjectDeletion obj %p activationcount %d\n",
           (void *)object, object->activationCount);
  }
#endif

  if (likely(object->id != NULL)) {
    /*fprintf(stderr, "  ... cmd dealloc %p final delete refCount %d\n",
      object->id, Tcl_Command_refCount(object->id));*/

    if (NSF_DTRACE_OBJECT_FREE_ENABLED()) {
      NSF_DTRACE_OBJECT_FREE(ObjectName(object), ClassName(object->cl));
    }

    Tcl_DeleteCommandFromToken(interp, object->id);
  }
}

#ifdef DO_CLEANUP
/*
 *----------------------------------------------------------------------
 *
 * DeleteNsfProcs --
 *
 *      Deletes all nsfprocs in the namespaces rooted at nsPtr.  If nsPtr is
 *      NULL the global namespace is used as the root.  Used to trigger the
 *      freeing of the parameter definitions.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      See description.
 *
 *----------------------------------------------------------------------
 */
static void DeleteNsfProcs(
    Tcl_Interp *interp, Tcl_Namespace *nsPtr
) nonnull(1);

static void
DeleteNsfProcs(
    Tcl_Interp *interp, Tcl_Namespace *nsPtr
) {
  Tcl_HashTable *cmdTablePtr, *childTablePtr;
  register Tcl_HashEntry *entryPtr;
  Tcl_HashSearch search;

  nonnull_assert(interp != NULL);

  if (nsPtr == NULL) {
    nsPtr = Tcl_GetGlobalNamespace(interp);
  }

  nonnull_assert(nsPtr != NULL);
  /*fprintf(stderr, "### DeleteNsfProcs current namespace '%s'\n", (nsPtr != NULL) ? nsPtr->fullName : "NULL");*/

  cmdTablePtr = Tcl_Namespace_cmdTablePtr(nsPtr);
  childTablePtr = Tcl_Namespace_childTablePtr(nsPtr);

  for (entryPtr = Tcl_FirstHashEntry(cmdTablePtr, &search);
       entryPtr != NULL;
       entryPtr = Tcl_NextHashEntry(&search)) {
    Tcl_Command cmd = (Tcl_Command)Tcl_GetHashValue(entryPtr);

    if (Tcl_Command_objProc(cmd) == NsfProcStub) {
      /*fprintf(stderr, "cmdname = %s cmd %p\n",
        Tcl_GetHashKey(cmdTablePtr, entryPtr), cmd);*/
      Tcl_DeleteCommandFromToken(interp, cmd);
    }
  }
  for (entryPtr = Tcl_FirstHashEntry(childTablePtr, &search);
       entryPtr != NULL;
       entryPtr = Tcl_NextHashEntry(&search)) {
    Tcl_Namespace *childNsPtr = (Tcl_Namespace *) Tcl_GetHashValue(entryPtr);

    DeleteNsfProcs(interp, childNsPtr);
  }
}

/*
 *----------------------------------------------------------------------
 *
 * ClassHasSubclasses --
 *
 *      Returns true if the given class has subclasses.
 *
 * Results:
 *      See description.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */
static bool ClassHasSubclasses(
    const NsfClass *class
) nonnull(1) NSF_pure;

static bool
ClassHasSubclasses(
    const NsfClass *class
) {
  nonnull_assert(class != NULL);

  return (class->sub != NULL);
}

/*
 *----------------------------------------------------------------------
 *
 * ClassHasInstances --
 *
 *      Returns true if the given class has instances.
 *
 * Results:
 *      See description.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */
static bool ClassHasInstances(
    NsfClass *class
) nonnull(1) NSF_pure;

static bool
ClassHasInstances(
    NsfClass *class
) {
  Tcl_HashSearch hSrch;

  nonnull_assert(class != NULL);

  return (Tcl_FirstHashEntry(&class->instances, &hSrch) != NULL);
}

/*
 *----------------------------------------------------------------------
 *
 * ObjectHasChildren --
 *
 *      Returns true if the the given object has children.
 *
 * Results:
 *      See description.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */
static bool ObjectHasChildren(
    const NsfObject *object
) nonnull(1) NSF_pure;

static bool
ObjectHasChildren(
    const NsfObject *object
) {
  const Tcl_Namespace *ns;
  bool                 result = NSF_FALSE;

  nonnull_assert(object != NULL);

  ns = object->nsPtr;
  if (ns != NULL) {
    const Tcl_HashEntry *hPtr;
    Tcl_HashSearch hSrch;
    Tcl_HashTable *cmdTablePtr = Tcl_Namespace_cmdTablePtr(ns);

    for (hPtr = Tcl_FirstHashEntry(cmdTablePtr, &hSrch);
         hPtr != NULL;
         hPtr = Tcl_NextHashEntry(&hSrch)) {
      Tcl_Command cmd = Tcl_GetHashValue(hPtr);
      const NsfObject *childObject = NsfGetObjectFromCmdPtr(cmd);

      if (childObject != NULL) {
        result = NSF_TRUE;
        break;
      }
    }
  }
  return result;
}

/*
 *----------------------------------------------------------------------
 *
 * FreeAllNsfObjectsAndClasses --
 *
 *      Destroys and frees all objects and classes defined in the interp.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      See description.
 *
 *----------------------------------------------------------------------
 */
static void FreeAllNsfObjectsAndClasses(
    Tcl_Interp *interp, NsfCmdList **instances
) nonnull(1) nonnull(2);

static void
FreeAllNsfObjectsAndClasses(
    Tcl_Interp *interp, NsfCmdList **instances
) {
  NsfCmdList *entry, *lastEntry;
  int nrDeleted = 0;

  nonnull_assert(interp != NULL);
  nonnull_assert(instances != NULL);

  /*fprintf(stderr, "FreeAllNsfObjectsAndClasses in %p\n", interp);*/

  RUNTIME_STATE(interp)->exitHandlerDestroyRound = NSF_EXITHANDLER_ON_PHYSICAL_DESTROY;

  /*
   * First, for all objects, delete each child command which is not itself an
   * object, e.g. commands imported from other namespaces and direct methods of
   * the object.  This resolves potential loops in the dependency graph and
   * results in a plain object/class hierarchy.
   */

  for (entry = *instances; entry != NULL; entry = entry->nextPtr) {
    NsfObject *object = (NsfObject *)entry->clorobj;

    /*
     * Delete object methods.
     */
    if (object != NULL && object->nsPtr != NULL) {
      const Tcl_HashEntry *hPtr;
      Tcl_HashSearch hSrch;

      for (hPtr = Tcl_FirstHashEntry(Tcl_Namespace_cmdTablePtr(object->nsPtr), &hSrch);
           hPtr != NULL;
           hPtr = Tcl_NextHashEntry(&hSrch)) {
        Tcl_Command cmd = Tcl_GetHashValue(hPtr);

        if (cmd != NULL) {
          if (CmdIsNsfObject(cmd)) {
            AliasDeleteObjectReference(interp, cmd);
            continue;
          }
          Tcl_DeleteCommandFromToken(interp, cmd);
          nrDeleted ++;
        }
      }
    }

    /*
     * Delete class methods, eliminating the reference back to the object that
     * exists for each method.
     */
    if (object != NULL && NsfObjectIsClass(object)) {
      const Tcl_HashEntry *hPtr;
      Tcl_HashSearch hSrch;

      for (hPtr = Tcl_FirstHashEntry(Tcl_Namespace_cmdTablePtr(((NsfClass *)object)->nsPtr),
                                      &hSrch);
           hPtr != NULL;
           hPtr = Tcl_NextHashEntry(&hSrch)) {
        Tcl_Command cmd = Tcl_GetHashValue(hPtr);

        if ((cmd != NULL) && CmdIsNsfObject(cmd)) {
          AliasDeleteObjectReference(interp, cmd);
          continue;
        }
      }
    }
  }

  /*fprintf(stderr, "deleted %d cmds\n", nrDeleted);*/

  /*
   * Finally, delete the object/class hierarchy from the bottom up, iteratively
   * deleting each object that has nothing depending on it. Finally, only the
   * root classes remain, and they are deleted separately.
   */

  while (1) {
    /*
     * Delete each plain object, i.e. each object that nothing depends on.
     */
    nrDeleted = 0;
    for (entry = *instances, lastEntry = NULL;
         entry != NULL;
         lastEntry = entry, entry = entry->nextPtr) {
      NsfObject *object = (NsfObject *)entry->clorobj;

      /*
       * The list of instances should contain only objects that are alive, and
       * no duplicates.
       */

      /* Detect duplicates by checking that deletion of one object hasn't set
       * the CMD_IS_DELETED flag on the cmdPtr of another object.
       */
      assert(((unsigned int)Tcl_Command_flags(entry->cmdPtr) & CMD_IS_DELETED) == 0u);

      if (object != NULL && !NsfObjectIsClass(object) && !ObjectHasChildren(object)) {
        /*fprintf(stderr, "check %p obj->flags %.6x cmd %p deleted %d\n",
                object, object->flags, entry->cmdPtr,
                Tcl_Command_flags(entry->cmdPtr) & CMD_IS_DELETED); */
        assert(object->id != NULL);
        /*fprintf(stderr, "  ... delete object %s %p, class=%s id %p ns %p\n",
          ObjectName(object), object,
          ClassName(object->cl), object->id, object->nsPtr);*/

        FreeUnsetTraceVariable(interp, object);
        FinalObjectDeletion(interp, object);

        if (entry == *instances) {
          *instances = entry->nextPtr;
          CmdListDeleteCmdListEntry(entry, NULL);
          entry = *instances;
        } else {
          lastEntry->nextPtr = entry->nextPtr;
          CmdListDeleteCmdListEntry(entry, NULL);
          entry = lastEntry;
        }
        assert(entry != NULL);

        nrDeleted++;
      }
    }
    /*fprintf(stderr, "deleted %d Objects without dependencies\n", nrDeleted);*/

    if (nrDeleted > 0) {
      continue;
    }

    /*
     * Delete each classes that nothing depends on.
     */
    for (entry = *instances, lastEntry = NULL;
         entry != NULL;
         (entry != NULL ? (lastEntry = entry, entry = entry->nextPtr) : NULL)) {
      NsfClass *class = entry->clorobj;

      assert(class != NULL);

      if (!NsfObjectIsClass(&class->object)) {
        continue;
      }

      /*fprintf(stderr, "### cl key = %s %p\n", ClassName(class), class); */

      /*
       * Manually remove mixinRegObjs to maintain correct order of deletion so
       * that refcount checking for NsfObjects doesn't result in complaints
       * during shutdown, and no references are left dangling.
       */
      if (class->opt != NULL && class->opt->mixinRegObjs != NULL) {
        NsfMixinregInvalidate(interp, class->opt->mixinRegObjs);
        DECR_REF_COUNT2("mixinRegObjs", class->opt->mixinRegObjs);
        class->opt->mixinRegObjs = NULL;
      }

      if (!ObjectHasChildren((NsfObject *)class)
          && !ClassHasInstances(class)
          && !ClassHasSubclasses(class)
          && !IsBaseClass(&class->object)
          ) {
        /*fprintf(stderr, "  ... delete class %s %p\n", ClassName(class), class); */
        assert(class->object.id);

        FreeUnsetTraceVariable(interp, &class->object);
        FinalObjectDeletion(interp, &class->object);

        if (entry == *instances) {
          *instances = entry->nextPtr;
          /*fprintf(stderr, "... delete first entry %p\n", entry);*/
          CmdListDeleteCmdListEntry(entry, NULL);
          entry = *instances;
        } else {
          /*fprintf(stderr, "... delete entry %p\n", entry);*/
          lastEntry->nextPtr = entry->nextPtr;
          CmdListDeleteCmdListEntry(entry, NULL);
          entry = lastEntry;
        }

        nrDeleted++;
      }
    }

    /*fprintf(stderr, "deleted %d Classes\n", nrDeleted);*/

    if (nrDeleted == 0) {
      int nrReclassed = 0;

      /*
       * If there are no cyclical dependencies there should only be base
       * classes remaining.  If this is not the case, reclass the remaining
       * objects to their base classes and set the superClasses to the most
       * general superclass.
       */
      for (entry = *instances;
           entry != NULL;
           entry = entry->nextPtr) {
        NsfObject       *object = (NsfObject *)entry->clorobj;
        NsfClass        *baseClass;
        NsfObjectSystem *osPtr;

        if (NsfObjectIsClass(object) && IsBaseClass(object)) {
          continue;
        }

        osPtr = GetObjectSystem(object);

        /*
         * Check the superclass hierarchy of classes.
         */
        if (NsfObjectIsClass(object)) {
          NsfClass   *cl = (NsfClass *)object;
          NsfClasses *sc;

          for (sc = cl->super; sc != NULL; sc = sc->nextPtr) {
            if (sc->cl != osPtr->rootClass) {
              Tcl_Obj *objectName = osPtr->rootClass->object.cmdName;

              SuperclassAdd(interp, cl, 1, &objectName, objectName);
              nrReclassed ++;
              break;
            }
          }
        }

        /*
         * Change the class of the object to the base class.
         */
        baseClass = NsfObjectIsClass(object) ? osPtr->rootMetaClass : osPtr->rootClass;
        if (object->cl != baseClass) {
          ChangeClass(interp, object, baseClass);
          nrReclassed ++;
        }
      }
      /*fprintf(stderr, "We have reclassed %d objects\n", nrReclassed);*/

      if (nrReclassed == 0) {
        break;
      }
    }
  }
}

#endif /* DO_CLEANUP */

/*
 *  Exit Handler
 */

static void
ExitHandler(ClientData clientData) {
  Tcl_Interp      *interp = (Tcl_Interp *)clientData;
  int              flags;
  NsfRuntimeState *rst;

  nonnull_assert(clientData != NULL);

  rst = RUNTIME_STATE(interp);
  /*fprintf(stderr, "+++ (%lx) ExitHandler interp %p deleted %d exitHandlerDestroyRound %d\n",
          (long)(void*)pthread_self(), interp, (Tcl_Interp_flags(interp) & DELETED),
          rst->exitHandlerDestroyRound);*/

  /*
   * Don't use the exit handler if the interpreter is already destroyed.  The
   * exit handler is called after namespaces are freed, commands deleted, etc.
   * This might happen, for example, when Tk calls Tcl_DeleteInterp directly,
   * or if a Window is killed.
   */

  /*
   * Ahem ...
   *
   * Since destroy methods *must* run, *cheat* (I mean CHEAT) here: Flip the
   * interp flag, saying, "hey boy, you're not deleted any more".  After the
   * handlers are done, restore the old state...  All this is needed in order
   * to evaluate scripts in the interp which is may have been marked as deleted
   * already.
   *
   * I know, I know, this is not really elegant. But...  I'd need a
   * standard way of invoking some code at interpreter delete time
   * but JUST BEFORE the actual deletion process starts. Sadly,
   * there is no such hook in Tcl as of Tcl8.4.*, that I know of.
   *
   * So, for the rest of this routine, assume the interp is alive!
   */
  flags = Tcl_Interp_flags(interp);
  Tcl_Interp_flags(interp) &= ~DELETED;

  CallStackPopAll(interp);

#if defined(NSF_MEM_COUNT)
  /* The Tcl history list stores commands and scripts in the array
   * ::tcl::history, and can retain Tcl_Obj references beyond the scope of the
   * nsf shutdown procedures (::nsf::finalize, ExitHandler). Therefore, on
   * MEM_COUNT_RELEASE() there might be unbalanced refcounts which are false
   * positives. Therefore, clear the history list.
   *
   * See also Tcl bug report 1ae12987cb.
  */

  if (unlikely(Tcl_Eval(interp, "::history clear") != TCL_OK)) {
    NsfLog(interp, NSF_LOG_WARN, "Clearing the Tcl history list failed! "
           "Memcounts could be reported as unbalanced on MEM_COUNT_RELEASE(). "
           "Error: %s\n",
           ObjStr(Tcl_GetObjResult(interp)));
  }
#endif

  if (rst->exitHandlerDestroyRound == NSF_EXITHANDLER_OFF) {
    NsfFinalizeCmd(interp, NSF_FALSE);
  }

  /*
   * Do this before freeing NsfGlobalObjs.
   */
  NsfShadowTclCommands(interp, SHADOW_UNLOAD);

  MEM_COUNT_FREE("Tcl_InitHashTable", &rst->activeFilterTablePtr);
  Tcl_DeleteHashTable(&rst->activeFilterTablePtr);

  /*
   * Free the "global", i.e. per-main-interp objects.
   */
  {
    int i;

    for (i = 0; i < nr_elements(NsfGlobalStrings); i++) {
      DECR_REF_COUNT(NsfGlobalObjs[i]);
    }
  }
  NsfStringIncrFree(&rst->iss);

  /*
   * Remove from hash tables all data for managing pointer converters,
   * enumerations, and method definitions.
   */
  Nsf_PointerExit(interp);
  Nsf_EnumerationTypeRelease();
  Nsf_CmdDefinitionRelease();

#if defined(NSF_PROFILE)
  NsfProfileFree(interp);
#endif

  FREE(Tcl_Obj**, NsfGlobalObjs);

#if defined(TCL_MEM_DEBUG)
  TclDumpMemoryInfo((ClientData) stderr, 0);
  Tcl_DumpActiveMemory("./nsfActiveMem");
  /* Tcl_Eval(interp, "puts {checkmem to checkmemFile};
     checkmem checkmemFile"); */
#endif

  /*
   * Free the runtime state.
   */
  /*fprintf(stderr, "+++ ExiHandler frees run time state of interp %p\n", interp);*/
  ckfree((char *) rst);
#if defined(USE_ASSOC_DATA)
  Tcl_DeleteAssocData(interp, "NsfRuntimeState");
#else
  Tcl_Interp_globalNsPtr(interp)->clientData = NULL;
#endif

#if defined(NSF_MEM_COUNT) && !defined(PRE86)
  /*
   * When raising an error, the Tcl_Obj structures on the error stack and in
   * the inner context are refCount-incremented. When Tcl exits it does not
   * normally perform the corresponding decrementing. Decrement the refCounts
   * here and reset the lists.
   */
  {
    Interp *iPtr = (Interp *) interp;

    if (iPtr->innerContext != NULL) {
      Tcl_DecrRefCount(iPtr->errorStack);
      iPtr->errorStack = Tcl_NewListObj(0, NULL);
      Tcl_IncrRefCount(iPtr->errorStack);
      Tcl_DecrRefCount(iPtr->innerContext);
      iPtr->innerContext = Tcl_NewListObj(0, NULL);
      Tcl_IncrRefCount(iPtr->innerContext);
    }
  }
#endif

  Tcl_Interp_flags(interp) = flags;
  Tcl_Release(interp);

  MEM_COUNT_RELEASE();
}


#if defined(TCL_THREADS)
/*
 * Activated at thread exit.
 */

static void
Nsf_ThreadExitProc(ClientData clientData) {

  nonnull_assert(clientData != NULL);

  /*fprintf(stderr, "+++ (%lx) Nsf_ThreadExitProc %p\n", (long)(void*)pthread_self(), clientData);*/

  Tcl_DeleteThreadExitHandler(Nsf_ThreadExitProc, clientData);
  Tcl_DeleteExitHandler(Nsf_ExitProc, clientData);
  ExitHandler(clientData);
}
#endif

/*
 * Activated at application exit.
 */

static void
Nsf_ExitProc(ClientData clientData) {

  nonnull_assert(clientData != NULL);

  /*fprintf(stderr, "+++ (%lx) Nsf_ExitProc %p\n", (long)(void*)pthread_self(), clientData);*/
#if defined(TCL_THREADS)
  Tcl_DeleteExitHandler(Nsf_ExitProc, clientData);
  Tcl_DeleteThreadExitHandler(Nsf_ThreadExitProc, clientData);
#endif
  ExitHandler(clientData);
}

/*
 * Registers thread/application exit handlers.
 */
static void RegisterExitHandlers(ClientData clientData)
  nonnull(1);

static void
RegisterExitHandlers(ClientData clientData) {

  nonnull_assert(clientData != NULL);

  Tcl_Preserve(clientData);
#if defined(TCL_THREADS)
  Tcl_CreateThreadExitHandler(Nsf_ThreadExitProc, clientData);
#endif
  Tcl_CreateExitHandler(Nsf_ExitProc, clientData);
}

/*
 * Tcl extension initialization routine
 */

#if 0
#include <google/profiler.h>
#endif


int
Nsf_Init(
    Tcl_Interp *interp
) {
  static NsfMutex  initMutex = 0;
  ClientData       runtimeState;
  NsfRuntimeState *rst;
  int              result, i;
  Tcl_Obj         *tmpObj;
#ifdef NSF_BYTECODE
  /*NsfCompEnv *interpstructions = NsfGetCompEnv();*/
#endif
#ifdef USE_TCL_STUBS
  static int stubsInitialized = 0;
#endif

  nonnull_assert(interp != NULL);

#if 0
  ProfilerStart("profiler");
#endif

#ifdef USE_TCL_STUBS
  /*
   * Since the stub tables are initialized globally and not per interp,
   * initialize these only once.  The read operation on "stubsInitialized" is
   * potentially a dirty read, but Tcl_MutexLock() requires, at least on some
   * platforms, initialized stub-tables, so it is not available.
   . The dirty read of stubsInitialized is not so
   * invasive as the dirty reads caused by overwriting the stub tables.
   *
   * NsfMutexLock(&stubFlagMutex);
   * ...
   * NsfMutexUnlock(&stubFlagMutex);
   */

  if (stubsInitialized == 0) {
    if (Tcl_InitStubs(interp, "8.5", 0) == NULL) {
      return TCL_ERROR;
    }
# if TCL_MAJOR_VERSION > 8 || TCL_MINOR_VERSION > 6
    /* Tcl_TomMath_InitStubs() is not needed */
# else
    if (Tcl_TomMath_InitStubs(interp, "8.5") == NULL) {
      return TCL_ERROR;
    }
# endif
    stubsInitialized = 1;
  }
#endif

#if defined(TCL_MEM_DEBUG)
  TclDumpMemoryInfo((ClientData) stderr, 0);
#endif

  /*
   * In order to avoid global state information, store runtimeState in the
   * client data of the global namespace of Interp, setting all fields to zero
   * by default.
   */
  runtimeState = ckalloc((int)sizeof(NsfRuntimeState));
  memset(runtimeState, 0, sizeof(NsfRuntimeState));

#if defined(USE_ASSOC_DATA)
  Tcl_SetAssocData(interp, "NsfRuntimeState", NULL, runtimeState);
#else
  Tcl_Interp_globalNsPtr(interp)->clientData = runtimeState;
#endif

  /*
   * If MEM_COUNT is activated the tables have to be initialized before the
   * first call to the MEM_COUNT macros, including e.g. INCR_REF_COUNT, but
   * runtimeState must already be associated with the interp.
   */
  MEM_COUNT_INIT();

  /*
   * Init global variables for Tcl_Obj types.
   */
  NsfMutexLock(&initMutex);
  Nsf_OT_byteCodeType = Tcl_GetObjType("bytecode");
  assert(Nsf_OT_byteCodeType != NULL);

  Nsf_OT_tclCmdNameType = Tcl_GetObjType("cmdName");
  assert(Nsf_OT_tclCmdNameType != NULL);

  Nsf_OT_listType = Tcl_GetObjType("list");
  assert(Nsf_OT_listType != NULL);

  Nsf_OT_doubleType = Tcl_GetObjType("double");
  assert(Nsf_OT_doubleType != NULL);

  /*
   * The types "int" and "wideInt" are moving targets in Tcl 8.7a+, so, get the
   * type from the Tcl_Obj directly, which will continue to work.
   */
  tmpObj = Tcl_NewIntObj(0);
  Nsf_OT_intType = tmpObj->typePtr;
  Tcl_DecrRefCount(tmpObj);
  assert(Nsf_OT_intType != NULL);

  Nsf_OT_byteArrayType = Tcl_GetObjType("bytearray");
  assert(Nsf_OT_byteArrayType != NULL);

  { mp_int bignumValue;

    tmpObj = Tcl_NewStringObj("10000000000000000000000", -1);
    Tcl_GetBignumFromObj(NULL, tmpObj, &bignumValue);
    Nsf_OT_bignumType =  tmpObj->typePtr;
    assert(Nsf_OT_bignumType != NULL);
    Tcl_DecrRefCount(tmpObj);
  }

  /*
   * Get bytearray and proper bytearray from Tcl if available.  The latter was
   * introduced in Tcl 8.7a+.
   */
  tmpObj = Tcl_NewByteArrayObj(NULL, 0);
  Nsf_OT_properByteArrayType = tmpObj->typePtr;
  if (Nsf_OT_properByteArrayType == Nsf_OT_byteArrayType) {
    /*
     * When both values are the same, the Tcl version is lower than 8.7 and
     * there is no properByteArrayTypePtr. Set it to an invalid value to avoid
     * potential confusion. Without this stunt, several ifdefs would be
     * required.
     */
    Nsf_OT_properByteArrayType = (Tcl_ObjType *)0xffffff;
  }
  Tcl_DecrRefCount(tmpObj);
  assert(Nsf_OT_properByteArrayType != NULL);

  NsfMutexUnlock(&initMutex);

  /*
   * Initialize the pointer converter, the enumeration types and cmd definition
   * tables and load them with the generated information for introspection.
   */
  Nsf_PointerInit();

  Nsf_EnumerationTypeInit();
  result = Nsf_EnumerationTypeRegister(interp, enumeratorConverterEntries);
  if (unlikely(result != TCL_OK)) {
    return result;
  }

  Nsf_CmdDefinitionInit();
  Nsf_CmdDefinitionRegister(interp, method_definitions);

  /*
    fprintf(stderr, "SIZES: obj=%d, tcl_obj=%d, DString=%d, class=%d, namespace=%d, command=%d, HashTable=%d\n",
    sizeof(NsfObject), sizeof(Tcl_Obj), sizeof(Tcl_DString), sizeof(NsfClass),
    sizeof(Namespace), sizeof(Command), sizeof(Tcl_HashTable));
  */

#if defined(NSF_PROFILE)
  NsfProfileInit(interp);
#endif
  rst = RUNTIME_STATE(interp);
  rst->logSeverity = NSF_LOG_NOTICE;
  rst->doFilters = 1;
  rst->doCheckResults = 1;
  rst->doCheckArguments = NSF_ARGPARSE_CHECK;
  NsfDListInit(&rst->freeDList);

#if defined(NSF_STACKCHECK)
  { int someVar;
    /*
     * Nsf_Init() is typically called via [package require], so this is just a
     * first approximation of the bottom of the stack.
     */
    rst->bottomOfStack = &someVar;
    rst->maxStack = rst->bottomOfStack;
  }
#endif

  /*
   * Create the namespace if it doesn't exist.
   */
  rst->NsfNS = Tcl_FindNamespace(interp, "::nsf", NULL, TCL_GLOBAL_ONLY);
  if (rst->NsfNS == NULL) {
    rst->NsfNS = Tcl_CreateNamespace(interp, "::nsf", NULL,
                                     (Tcl_NamespaceDeleteProc *)NULL);
  }
  MEM_COUNT_ALLOC("TclNamespace", rst->NsfNS);

  /*
   * Initialize an empty, faked proc structure.
   */
  rst->fakeProc.iPtr = (Interp *)interp;
  rst->fakeProc.refCount = 1;
  rst->fakeProc.cmdPtr = NULL;
  rst->fakeProc.bodyPtr = NULL;
  rst->fakeProc.numArgs = 0;
  rst->fakeProc.numCompiledLocals = 0;
  rst->fakeProc.firstLocalPtr = NULL;
  rst->fakeProc.lastLocalPtr = NULL;

  /*
   * NsfClasses reside in separate Namespaces/Objects.
   */
  rst->NsfClassesNS =
    Tcl_CreateNamespace(interp, nsfClassesPrefix, NULL,
                        (Tcl_NamespaceDeleteProc *)NULL);

#if !defined(PRE86)
  ((Namespace *)rst->NsfClassesNS)->flags |= NS_SUPPRESS_COMPILATION;
#endif

  MEM_COUNT_ALLOC("TclNamespace", rst->NsfClassesNS);

  /*
   * Cache the objInterpProc of the interpreter.
   */
  rst->objInterpProc = TclGetObjInterpProc();
  rst->exitHandlerDestroyRound = NSF_EXITHANDLER_OFF;

  RegisterExitHandlers(interp);
  NsfStringIncrInit(&RUNTIME_STATE(interp)->iss);
  /*
   * Initialize global a Tcl_Obj array for global objects.
   */
  NsfGlobalObjs = NEW_ARRAY(Tcl_Obj*, nr_elements(NsfGlobalStrings));

  for (i = 0; i < nr_elements(NsfGlobalStrings); i++) {
    NsfGlobalObjs[i] = Tcl_NewStringObj(NsfGlobalStrings[i], -1);
    INCR_REF_COUNT(NsfGlobalObjs[i]);
  }

  Tcl_InitHashTable(&rst->activeFilterTablePtr, TCL_STRING_KEYS);
  MEM_COUNT_ALLOC("Tcl_InitHashTable", &rst->activeFilterTablePtr);

  /*
   * Create namespaces for the different command types.
   */
  Tcl_CreateNamespace(interp, "::nsf::cmd", 0, (Tcl_NamespaceDeleteProc *)NULL);
  for (i = 0; i < nr_elements(method_command_namespace_names); i++) {
    Tcl_CreateNamespace(interp, method_command_namespace_names[i], 0, (Tcl_NamespaceDeleteProc *)NULL);
  }

  /*
   * Create all method commands.  They use the namespaces above.
   */
  for (i = 0; i < nr_elements(method_definitions)-1; i++) {
    Tcl_CreateObjCommand(interp, method_definitions[i].methodName, method_definitions[i].proc, 0, 0);
  }

  /*
   * Override some Tcl commands.
   */
  result = NsfShadowTclCommands(interp, SHADOW_LOAD);
  if (unlikely(result != TCL_OK)) {
    return result;
  }
  /*
   * Create new Tcl commands.
   */
#ifdef NSF_BYTECODE
  instructions[INST_NEXT].cmdPtr = (Command *)
#endif
    Tcl_CreateObjCommand(interp, "::nsf::xotclnext", NsfNextObjCmd, 0, 0);
#ifdef NSF_BYTECODE
  instructions[INST_SELF].cmdPtr =
    (Command *)Tcl_FindCommand(interp, "::nsf::current", NULL, TCL_GLOBAL_ONLY);
#endif
  /*Tcl_CreateObjCommand(interp, "::nsf::K", NsfKObjCmd, 0, 0);*/

#ifdef NSF_BYTECODE
  NsfBytecodeInit();
#endif
  NsfInitPkgConfig(interp);

  Tcl_AddInterpResolvers(interp, "nsf",
                         (Tcl_ResolveCmdProc *)InterpColonCmdResolver,
                         InterpColonVarResolver,
                         (Tcl_ResolveCompiledVarProc *)InterpCompiledColonVarResolver);
  rst->colonCmd = Tcl_FindCommand(interp, "::nsf::colon", NULL, TCL_GLOBAL_ONLY);

  /*
   *  Tcl occasionally uses the cmd structure of a procedure without verifying
   *  that it actually exists, e.g. in [info frame /number/] or
   *  TclInfoFrame()), but Nsf non-proc frames, in particular initcmd blocks,
   *  point to the fakeProc structure which does not contain an initialized
   *  Command pointer. For now, default to an internal command.  It might be
   *  necessary to revisit this decision since non-proc frames, e.g. initcmds,
   *  report a "proc" entry for C-based functions with a proc scope, e.g.
   *  "::nsf::colon", which can lead to confusion. "proc" does not mean "Tcl
   *  proc", but an entry with a proc frame for local vars.
  */
  rst->fakeProc.cmdPtr = (Command *)RUNTIME_STATE(interp)->colonCmd;

  {
    /*
     * "predefined.h" contains some methods and library procs implemented in
     * Tcl.  They could be placed into .tcl file, but are embedded here with
     * Tcl_Eval to avoid the need to carry around a separate file at runtime.
     */

#include "predefined.h"

    /* fprintf(stderr, "predefined=<<%s>>\n", cmd);*/
    if (
        (Tcl_Eval(interp, predefined_part1) != TCL_OK)
        || (Tcl_Eval(interp, predefined_part2) != TCL_OK)
        ) {
      static char reportingCmd[] =
        "puts stderr \"Error in predefined code\n\
         $::errorInfo\"";
      Tcl_EvalEx(interp, reportingCmd, -1, 0);
      return TCL_ERROR;
    }
  }

#ifndef AOL_SERVER
  /*
   * AOL server uses a different package loading mechanism.
   */
# ifdef COMPILE_NSF_STUBS
  Tcl_PkgProvideEx(interp, "nsf", PACKAGE_VERSION, &nsfStubs);
# else
  Tcl_PkgProvide(interp, "nsf", PACKAGE_VERSION);
# endif
#endif

  /*
   * Obtain the type for parsed var name.
   */
  if (Nsf_OT_parsedVarNameType == NULL) {
    Tcl_Obj *varNameObj = Tcl_NewStringObj("::nsf::version", -1);
    Var *arrayPtr;

    INCR_REF_COUNT(varNameObj);
    TclObjLookupVar(interp, varNameObj, NULL, 0, "access",
                    /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
    Nsf_OT_parsedVarNameType = varNameObj->typePtr;
    assert(Nsf_OT_parsedVarNameType != NULL);
    DECR_REF_COUNT(varNameObj);
  }

#if !defined(TCL_THREADS)
  if ((Tcl_GetVar2(interp, "tcl_platform", "threaded", TCL_GLOBAL_ONLY) != NULL)) {
    /*
     * A non-threaded version of Nsf is loaded into a threaded environment.
     */
    fprintf(stderr, "\n A non threaded version of the Next Scripting Framework "
            "is loaded into threaded environment.\n"
            "Please reconfigure nsf with --enable-threads!\n\n\n");
  }
#endif

  Tcl_ResetResult(interp);
  Tcl_SetIntObj(Tcl_GetObjResult(interp), 1);

  return TCL_OK;
}

EXTERN int
Nsf_SafeInit(Tcl_Interp *interp) {

  nonnull_assert(interp != NULL);

  /*** dummy for now **/
  return Nsf_Init(interp);
}



/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 2
 * fill-column: 78
 * indent-tabs-mode: nil
 * eval: (c-guess)
 * End:
 */
